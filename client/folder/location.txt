Start!!!

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.codec.serialization.ClassResolvers;
import io.netty.handler.codec.serialization.ObjectDecoder;
import io.netty.handler.codec.serialization.ObjectEncoder;
import io.netty.handler.stream.ChunkedWriteHandler;

public class ServerApp {
private int port;

    public ServerApp(int port) {
        this.port = port;
    }

    public void run() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() { // (4)
                        @Override
                        public void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(
                                    new ObjectDecoder(50 * 1024 * 1024, ClassResolvers.cacheDisabled(null)),
                                    new ObjectEncoder(),
                                    new MainHandler());
                        }
                    })
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture f = b.bind(port).sync();
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        new ServerApp(8199).run();
    }
}

public class MainHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        try {
            if (msg == null) {
                return;
            }
            if (msg instanceof FileRequest) {
                FileRequest fr = (FileRequest) msg;
                if (Files.exists(Paths.get("server_storage/" + fr.getFilename()))) {
                    FileMessage fm = new FileMessage(Paths.get("server_storage/" + fr.getFilename()));
                    ctx.writeAndFlush(fm);
                }
            }
        } finally {
            ReferenceCountUtil.release(msg);
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}


public class Main extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) throws Exception {
        Parent root = FXMLLoader.load(getClass().getResource("/sample.fxml"));
        primaryStage.setTitle("MyCloud");
        primaryStage.setScene(new Scene(root, 700, 700));
        primaryStage.show();
    }
}







import com.geekbrains.mycloud.common.AbstractMessage;
import com.geekbrains.mycloud.common.FileMessage;
import com.geekbrains.mycloud.common.FileRequest;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.PooledByteBufAllocator;
import io.netty.util.ByteProcessor;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.geometry.Insets;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.input.*;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import java.awt.Desktop;
import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.FileChannel;
import java.nio.channels.GatheringByteChannel;
import java.nio.channels.ScatteringByteChannel;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.*;

import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.TextArea;
import javafx.scene.layout.VBox;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import java.awt.*;
import java.io.*;
import java.net.URL;
import java.util.Arrays;
import java.util.List;

public class Controller implements Initializable {

//    @FXML
//    TextArea mainTextArea;

    @FXML
    TextField textField;

    @FXML
    VBox mainVBox;

    @FXML
    StackPane mainStackPane;

    @FXML
    ListView<String> myListView;

    @FXML
    Label filesDragAndDrop;

    @FXML
    Button btn;

    Desktop desktop = Desktop.getDesktop();
    FileChooser fileChooser = new FileChooser();

    @Override
    public void initialize(URL location, ResourceBundle resources) {
        ObservableList<String> list = FXCollections.observableArrayList();
        initializeWindowDragAndDropLabel();
        initializeDragAndDropLabel();
        Network.start();
        Thread t = new Thread(() -> {
            try {
                while (true) {
                    AbstractMessage am = Network.readObject();
                    if (am instanceof FileMessage) {
                        FileMessage fm = (FileMessage) am;
                        Files.write(Paths.get("client_storage/" + fm.getFilename()), fm.getData(), StandardOpenOption.CREATE);
                        refreshLocalFilesList();

                    }
                }
            } catch (ClassNotFoundException | IOException e) {
                e.printStackTrace();
            } finally {
                Network.stop();
            }
        });
        t.setDaemon(true);
        t.start();
 //       refreshLocalFilesList();
    }

    public void pressOnDownloadBtn(ActionEvent actionEvent) {
        if (textField.getLength() > 0) {
            Network.sendMsg(new FileRequest(textField.getText()));
            NettyNetwork.getInstance().sendData();
   //         myListView.getItems().add(textField.getText() + "\n");
        textField.clear();
  //      textField.requestFocus();
        }
    }

    public void refreshLocalFilesList() {
        if (Platform.isFxApplicationThread()) {
            try {
                textField.clear();
                Files.list(Paths.get("client_storage")).map(p -> p.getFileName().toString()).forEach(o ->  myListView.getItems().add(o));
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            Platform.runLater(() -> {
                try {

                    Files.list(Paths.get("client_storage")).map(p -> p.getFileName().toString()).forEach(o ->  myListView.getItems().add(o));
                    textField.clear();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });
        }
    }

    public void pressOnSendData(ActionEvent actionEvent) {
        NettyNetwork.getInstance().sendData();

}


    List<String> l=new ArrayList<>();

    public void addFiles(ActionEvent event) throws Exception {

        Stage stage = new Stage();
        File file = fileChooser.showOpenDialog(stage);
        if (file != null) {
            filesDragAndDrop.setText("");
            l.add(file.getName());
            for (String a : l) {
                String s = " -  " + a + "\n";
                filesDragAndDrop.setText(filesDragAndDrop.getText() + s);
            }
        }

        try (BufferedReader bf = new BufferedReader(new FileReader(file.getAbsolutePath()))) {
            Network.sendMsg(new FileRequest(file.getName()));
            String str;
            if ((str = bf.readLine()) != null) {
                System.out.println(file.getPath());
            }
        } catch (IOException e) {
            e.printStackTrace();
        }


            FileRequest fr = new FileRequest(file.getName());

            Object msg = fr.getFilename();
            String str = (String) msg;
            byte[] arr = str.getBytes();
            ByteBufAllocator al = new PooledByteBufAllocator();
            ByteBuf buf = al.buffer(arr.length);
            buf.writeBytes(arr);
            buf.release();

        NettyNetwork.getInstance().sendData();


//        Path path = Paths.get(file.getName());
//        byte[] dat = Files.readAllBytes(path);
//            Files.write(Paths.get("server_storage/" + file.getName()), dat, StandardOpenOption.CREATE);


//       FileReader reader=new FileReader("server_storage/" + file.getName());
//       FileWriter writer=new FileWriter("client_storage/" + file.getName());
//       while(reader.ready())   {
//                int data =reader.read();
//                 reader.close();
//                 writer.close();}

        try  (PrintWriter out = new PrintWriter("server_storage/" + file.getName())) {
              out.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }



    public void initializeDragAndDropLabel() {

        filesDragAndDrop.setOnDragOver(event -> {
            if (event.getGestureSource() != filesDragAndDrop && event.getDragboard().hasFiles()) {
                event.acceptTransferModes(TransferMode.COPY_OR_MOVE);
            }
            event.consume();
        });

        filesDragAndDrop.setOnDragDropped(event -> {
            Dragboard db = event.getDragboard();

            boolean success = false;
            if (db.hasFiles()) {
                filesDragAndDrop.setText("");
                 for (File o : db.getFiles()) {
                     filesDragAndDrop.setText("");
                     l.add(o.getName());
                     for (String a: l){
                      String s= a+ "\n";
                      filesDragAndDrop.setText(filesDragAndDrop.getText()+s);
                 }
                    String s= o.getName() + "\n";

                     try (BufferedReader bf = new BufferedReader(new FileReader(o.getAbsolutePath()))) {
                         Network.sendMsg(new FileRequest(o.getAbsolutePath()));
                         String str;
                         if ((str = bf.readLine()) != null) {
                             System.out.println(o.getAbsolutePath());
                             NettyNetwork.getInstance().sendData();
                         }
                     } catch (IOException e) {
                         e.printStackTrace();
                     }

                         FileRequest fr = new FileRequest(o.getName());
                         Object msg = fr.getFilename();
                         String str = (String) msg;
                         byte[] arr = str.getBytes();
                         ByteBufAllocator al = new PooledByteBufAllocator();
                         ByteBuf buf = al.buffer(arr.length);
                         buf.writeBytes(arr);
                         buf.release();

                     NettyNetwork.getInstance().sendData();
//                     try (PrintWriter out = new PrintWriter( "server_storage/" +"1.txt")) {
//                         out.println("Results: "+ o.getName());
                     try (PrintWriter out = new PrintWriter("server_storage/" + o.getName())) {

                         out.flush();
                     } catch (IOException e) {
                         e.printStackTrace();
                     }


                    filesDragAndDrop.setOnMousePressed(new EventHandler<MouseEvent>() {
                        @Override
                        public void handle(MouseEvent mouseEvent) {
                            openFile(o);
                        }
                    });
                }
                success = true;
            }
            event.setDropCompleted(success);
            event.consume();
        });
    }

    double dragDeltaX, dragDeltaY;

    public void initializeWindowDragAndDropLabel() {
        Platform.runLater(() -> {
            Stage stage = (Stage) mainVBox.getScene().getWindow();

            filesDragAndDrop.setOnMousePressed(new EventHandler<MouseEvent>() {
                @Override
                public void handle(MouseEvent mouseEvent) {

                    dragDeltaX = stage.getX() - mouseEvent.getScreenX();
                    dragDeltaY = stage.getY() - mouseEvent.getScreenY();
                }
            });
            filesDragAndDrop.setOnMouseDragged(new EventHandler<MouseEvent>() {
                @Override
                public void handle(MouseEvent mouseEvent) {
                    stage.setX(mouseEvent.getScreenX() + dragDeltaX);
                    stage.setY(mouseEvent.getScreenY() + dragDeltaY);
                }
            });
        });
    }


    private void openFile(File file) {
        try {
            this.desktop.open(file);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    public void deleteFile(ActionEvent actionEvent) {
         filesDragAndDrop.setText("Drop files here!");

    }
}






import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.ListView;
import javafx.scene.control.TextField;

import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ResourceBundle;

public class NettyController implements Initializable {
    @FXML
    TextField tfFileName;

    @FXML
    ListView<String> filesList;

    @Override
    public void initialize(URL location, ResourceBundle resources) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                NettyNetwork.getInstance().start();
            }
        }).start();

        refreshLocalFilesList();
    }

    public void pressOnSendData(ActionEvent actionEvent) {
        NettyNetwork.getInstance().sendData();
    }

    public void refreshLocalFilesList() {
        if (Platform.isFxApplicationThread()) {
            try {
                filesList.getItems().clear();
                Files.list(Paths.get("client_storage")).map(p -> p.getFileName().toString()).forEach(o -> filesList.getItems().add(o));
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            Platform.runLater(() -> {
                try {
                    filesList.getItems().clear();
                    Files.list(Paths.get("client_storage")).map(p -> p.getFileName().toString()).forEach(o -> filesList.getItems().add(o));
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });
        }
    }
}



import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.PooledByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;

import java.net.InetSocketAddress;

public class NettyNetwork {
    private static NettyNetwork ourInstance = new NettyNetwork();

    public static NettyNetwork getInstance() {
        return ourInstance;
    }

    private NettyNetwork() {
    }

    private Channel currentChannel;

    public Channel getCurrentChannel() {
        return currentChannel;
    }

    public void start() {
        EventLoopGroup group = new NioEventLoopGroup();
        try {
            Bootstrap clientBootstrap = new Bootstrap();
            clientBootstrap.group(group);
            clientBootstrap.channel(NioSocketChannel.class);
            clientBootstrap.remoteAddress(new InetSocketAddress("localhost", 8199));
            clientBootstrap.handler(new ChannelInitializer<SocketChannel>() {
                protected void initChannel(SocketChannel socketChannel) throws Exception {
                    socketChannel.pipeline().addLast();
                    currentChannel = socketChannel;
                }
            });
            ChannelFuture channelFuture = clientBootstrap.connect().sync();
            channelFuture.channel().closeFuture().sync();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                group.shutdownGracefully().sync();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }


    public void sendData() {
        ByteBufAllocator allocator = new PooledByteBufAllocator();
        ByteBuf buf = allocator.buffer(16);


                if (buf.isWritable()) {
                    buf.writeByte(16);
                } else {
                    try {
                        currentChannel.writeAndFlush(buf).await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    buf.clear();
                    buf.retain();
                }
            }


    public boolean isConnectionOpened() {
        return currentChannel != null && currentChannel.isActive();
    }

    public void closeConnection() {
        currentChannel.close();
    }
}



import com.geekbrains.mycloud.common.AbstractMessage;
import io.netty.handler.codec.serialization.ObjectDecoderInputStream;
import io.netty.handler.codec.serialization.ObjectEncoderOutputStream;

import java.io.IOException;
import java.net.Socket;

public class Network {
    private static Socket socket;
    private static ObjectEncoderOutputStream out;
    private static ObjectDecoderInputStream in;

    public static void start() {
        try {
            socket = new Socket("localhost", 8199);
            out = new ObjectEncoderOutputStream(socket.getOutputStream());
            in = new ObjectDecoderInputStream(socket.getInputStream(), 50 * 1024 * 1024);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void stop() {
        try {
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            in.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static boolean sendMsg(AbstractMessage msg) {
        try {
            out.writeObject(msg);
            return true;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return false;
    }

    public static AbstractMessage readObject() throws ClassNotFoundException, IOException {
        Object obj = in.readObject();
        return (AbstractMessage) obj;
    }
}






                     COMMON:
import java.io.Serializable;

public abstract class AbstractMessage implements Serializable {
}

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

public class FileMessage extends AbstractMessage {
    private String filename;
    private byte[] data;

    public String getFilename() {
        return filename;
    }

    public byte[] getData() {
        return data;
    }

    public FileMessage(Path path) throws IOException {
        filename = path.getFileName().toString();
        data = Files.readAllBytes(path);
    }
}


public class FileRequest extends AbstractMessage {
    private String filename;

    public String getFilename() {
        return filename;
    }

    public FileRequest(String filename) {
        this.filename = filename;
    }
}
===
package sample;

import java.io.*;
import java.net.Socket;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.ReadableByteChannel;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class ClientHandler extends Thread{

    private Socket client;

    public ClientHandler(Socket clientSocket) {
        client = clientSocket;
    }

    public void run() {
        try {
            InputStream inputStream = client.getInputStream();

            String name = "";
            String ext = "";
            long size = 0;

            DataInputStream dIn = new DataInputStream(inputStream);

            boolean done = false;
            while (!done) {
                byte messageType = dIn.readByte();

                switch (messageType) {
                    case 1: // name
                        name = dIn.readUTF();
                        System.out.println(name);
                        break;
                    case 2: // extension
                        ext = dIn.readUTF();
                        System.out.println(ext);
                        break;
                    case 3: // size
                        size = dIn.readLong();
                        System.out.println(size);
                        break;
                    default:
                        done = true;
                }
            }

            Path path = Paths.get(name + "." + ext);
            Path dir = Files.createDirectories(Paths.get("test"));

            ReadableByteChannel inChannel = Channels.newChannel(inputStream);
            FileChannel outFile =
                    new FileOutputStream(dir.toString() + "\\" + path.toFile()).getChannel();

            outFile.transferFrom(inChannel, 0, size);

            dIn.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

    private Socket socket;
    private Path filePath;
    private OutputStream out;
    private DataOutputStream dOut;

    public void initConnection() {
        try {
            socket = new Socket(SERVER_ADDRESS, SERVER_PORT);

            out = socket.getOutputStream();

            dOut = new DataOutputStream(out);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void sendFile() {

        try {
            File file = filePath.toFile();
            long size = file.length();
            String[] fileName = file.getName().split("\\.");
            String name = fileName[0];
            String ext = fileName[1];

            // Send file name
            dOut.writeByte(1);
            dOut.writeUTF(name);
            dOut.flush();

            // Send send file extension
            dOut.writeByte(2);
            dOut.writeUTF(ext);
            dOut.flush();

            // Send file size
            dOut.writeByte(3);
            dOut.writeLong(size);
            dOut.flush();

            // Send the exit message
            dOut.writeByte(-1);
            dOut.flush();


            WritableByteChannel writeIn = Channels.newChannel(out);
            FileChannel inFile = new FileInputStream(file).getChannel();
            inFile.transferTo(0, size, writeIn);

        } catch (IOException e) {
            e.printStackTrace();

    public void closeConnection() {
        try {
            dOut.close();
            socket.close();

        } catch (IOException exc) {
===
public class Controller {
    final String IP_ADRESS = "localhost";
    final int PORT = 8091;
    final String CLIENT_FOLDER = "client/folder/";

    Socket socket;
    FileOutputStream out;
    FileInputStream in;

    @FXML
    HBox authorizationPanel;

    @FXML
    VBox workingPanel;

    @FXML
    TableView<UserFile> clientFile;

    private void setAuthorized(boolean isAuthorized) {
        if (isAuthorized) {
            authorizationPanel.setVisible(!isAuthorized);
            workingPanel.setVisible(isAuthorized);

            initializeFilesTable();

            if (socket == null || socket.isClosed()) {
//create  socket
                try {
                    socket = new Socket(IP_ADRESS, PORT);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

        } else {
            authorizationPanel.setVisible(isAuthorized);
            workingPanel.setVisible(!isAuthorized);
        }
    }

    public void tryToAuth(ActionEvent actionEvent) {
        setAuthorized(true);
    }

    public void sendFile(ActionEvent actionEvent) {
        String fileName = "location.txt";
        new SendFiles(socket, CLIENT_FOLDER, fileName);
    }

    public void downloadFile(ActionEvent actionEvent) {
        String fileName = "location.txt";
        new DownloadFiles(socket, CLIENT_FOLDER, fileName);
    }

    public void initializeFilesTable() {
        TableColumn<UserFile, String> tcName = new TableColumn<>("Name");
        tcName.setCellValueFactory(new PropertyValueFactory<>("name"));

        TableColumn<UserFile, String> tcSize = new TableColumn<>("Size");
        tcSize.setCellValueFactory(new PropertyValueFactory<>("size"));

        clientFile.getColumns().addAll(tcName, tcSize);

//        UserFiles userFiles = new UserFiles();
//        userFiles.scanFiles();

        clientFile.getItems().addAll();
    }
}

public class SendFiles {
    public SendFiles(Socket socket, String clientFolder, String fileName) {
        try {
            long start = System.currentTimeMillis();
            //* for sending to socket with BufferedOutputStream
            BufferedOutputStream buffOut = new BufferedOutputStream(socket.getOutputStream());
            //* reference to file
            File file = new File(clientFolder + fileName);
            //* read data from file
            FileInputStream inFile = new FileInputStream(file);

            /**/
            //sending command "send file"
            buffOut.write(15);
            buffOut.flush();
            //sending length of file
            buffOut.write((byte) file.length());
            buffOut.flush();
            //sending length of file name
//            buffOut.write(fileName.length());
//            buffOut.flush();
            //sending name of file
            buffOut.write(fileName.getBytes());
            buffOut.flush();
            /**/

            int bufLen;
            byte[] arr = new byte[8192];
            while ((bufLen = inFile.read(arr)) > 0){
                buffOut.write(arr, 0, bufLen);
            }

            System.out.println("Time " + (System.currentTimeMillis() - start));
            buffOut.close();
            inFile.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

public class DownloadFiles {
    public DownloadFiles(Socket socket, String clientFolder, String fileName) {
        try {
            long start = System.currentTimeMillis();
            //* create file
            FileOutputStream outFile = new FileOutputStream(clientFolder + fileName);
            //* for sending to socket with BufferedOutputStream
            BufferedOutputStream buffOut = new BufferedOutputStream(socket.getOutputStream());
            //* take stream for receiving data from client by BufferedInputStream
            BufferedInputStream buffIn = new BufferedInputStream(socket.getInputStream());

            /**/
            //sending command "download file"
            buffOut.write(16);
            buffOut.flush();
            //send length of file name
            buffOut.write(fileName.length());
            System.out.println(fileName.length() + " " + fileName);
            buffOut.flush();
            //sending name of file
            buffOut.write(fileName.getBytes());
            buffOut.flush();
            /**/

//            byte[] arr = new byte[8192];
//            int bufLen;
//            while (( bufLen = buffIn.read(arr)) > 0){
//                outFile.write(arr, 0, bufLen);
//            }

            System.out.println("Time " + (System.currentTimeMillis() - start));

            buffIn.close();
            outFile.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

public class NettyServer {
    public void run() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            socketChannel.pipeline().addLast(new ClientHandler());
                        }
                    })
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture f = b.bind(8091).sync();
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }
}

public class ClientHandler extends ChannelInboundHandlerAdapter {

    String fileName = null;
    private int state = -1;
    private int reqLen = -1;
    private int nameLen = 0;
    private DataType dataType = DataType.EMPTY;

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ByteBuf buf = ((ByteBuf) msg);

        if (state == -1) {
            byte firstByte = buf.readByte();
            dataType = DataType.getDataTypeFromByte(firstByte);
            state = 0;
        }
        if (state == 0) {
            switch (dataType) {
                case SEND_FILES: /*send file*/
                    System.out.println("send file");
                    if (state == 0) {
                        reqLen = buf.readInt();
                        state = 1;
                        System.out.println("file size is " + reqLen);
                    }
                    //
                    if (state == 1) {
                        nameLen = buf.readInt();
                        state = 2;
                        System.out.println("file name length is " + nameLen);
                    }
                    //
                    if (state == 2) {
                        buf.readBytes(nameLen);
                        fileName = new String(buf.array());
                        state = 3;
                        System.out.println(fileName);
                    }
                    if (state == 3) {
                        //
                        //* create file
                        FileOutputStream outFile = new FileOutputStream("server/folder/" + fileName);
                        byte[] arr = new byte[8192];
                        int bufLen;
                        while (( bufLen = buf.readBytes(arr).capacity()) > 0){
                            outFile.write(arr, 0, bufLen);
                        }
                        outFile.close();

                    }
                    break;
                case DOWNLOAD_FILES: /*download file*/
                    System.out.println("download file");
                    if (state == 0) {
                        if (buf.readableBytes() < 4) {
                            return;
                        }
                        nameLen = buf.readInt();
                        state = 2;
                        System.out.println("name length " + nameLen);
                    }
                    if (state == 2) {
                        if (buf.readableBytes() < nameLen) {
                            return;
                        }
                        byte[] data = new byte[nameLen];
                        buf.readBytes(data);
                        String str = new String(data);
                        System.out.println(str);
                    }
                    //
                    break;
                default: /* add late */
            }
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }

    //create ENUM for defining what we've got?
    private enum DataType {
        EMPTY((byte) - 1), SEND_FILES((byte)15), DOWNLOAD_FILES((byte)16);
        byte firstMessageByte;
        DataType(byte firstMessageByte) {
            this.firstMessageByte = firstMessageByte;
        }

        static DataType getDataTypeFromByte(byte b) {
            if (b == SEND_FILES.firstMessageByte) {
                return SEND_FILES;
            }
            if (b == DOWNLOAD_FILES.firstMessageByte) {
                return DOWNLOAD_FILES;
            }
            return EMPTY;
        }
    }
}
===
Client:

public class Main extends Application {


    public Main() {
        Network.start();
    }

    @Override
    public void start(Stage primaryStage) throws Exception {
        Parent root = FXMLLoader.load(getClass().getResource("/storage.fxml"));
        primaryStage.setTitle("One More Pet Cloud");
        primaryStage.setScene(new Scene(root));
        primaryStage.show();
        primaryStage.setOnCloseRequest(we -> Network.stop());
    }

    public static void main(String[] args) {
        launch(args);
    }
}

class Network {
    private static final String HOST = "localhost";
    private static final int PORT = 8189;
    private static Socket socket;
    private static DataInputStream in;
    private static DataOutputStream out;

    static void start() {
        try {
            socket = new Socket(HOST, PORT);
            if (socket.isConnected()) {
                System.out.println("connected to server");
                in = new DataInputStream(socket.getInputStream());
                out = new DataOutputStream(socket.getOutputStream());
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    static void sendMsg(String tag, String...body){
        try {
            out.write(new CommandEncoder(tag).wrapToBytes(body));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    static void sendFile(String tag, FileMsg file){
        try {
            out.write(new CommandEncoder(tag).wrapToBytes(file.getFileName()));
            out.flush();
            out.write(file.getData());
            out.flush();
			out.write("\n".getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    static String  readStringMsg() throws IOException {
        StringBuilder builder = new StringBuilder();
        int countBytes;
        while ((countBytes = in.read()) != -1) {
            builder.append((char) countBytes);
        }
        return builder.toString();
    }

    static void stop() {
        if (in != null) {
            try {
                in.close();
            } catch (IOException ignored) {}
        }
        if (out != null) {
            try {
                out.flush();
                out.close();
            } catch (IOException ignored) {}
        }
        if (!socket.isClosed()) {
            try {
                socket.close();
            } catch (IOException ignored) {}
        }
    }
}


public class StorageController {
    @FXML
    ListView<String> localStorageListView;

    @FXML
    ListView<String> cloudStorageListView;

    @FXML
    Button updateLocalStorage;

    @FXML
    Button upgradeCloudStorage;

    @FXML
    Button sendFile;

    private final Path USERPATH = Paths.get(".", "users", "user"); //Р±СѓРґРµС‚ Р±СЂР°С‚СЊСЃСЏ РёР· login.getText()

    public void sendFile() throws IOException {
        String selectedFile = localStorageListView.getFocusModel().getFocusedItem();
        if (selectedFile != null) {
            FileMsg file = new FileMsg(Paths.get(USERPATH + File.separator + selectedFile));
            Network.sendFile("ADD", file);
            Network.readStringMsg();
        } else {
            Alert alert = new Alert(Alert.AlertType.WARNING, "Choose File", ButtonType.OK);
            alert.showAndWait();
        }
    }

    public void updateLocalStorage() {
        try {
            localStorageListView.getItems().clear();
            Files.walkFileTree(USERPATH, new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                    localStorageListView.getItems().add(file.getFileName().toString());
                    return FileVisitResult.CONTINUE;
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void upgradeCloudStorage() throws IOException {
        Network.sendMsg("UPG");
        cloudStorageListView.getItems().clear();
        cloudStorageListView.getItems().add(Network.readStringMsg());
    }

    public void downloadFile() throws IOException {
        String selectedFile = cloudStorageListView.getFocusModel().getFocusedItem();
        if (selectedFile != null) {
            Network.sendMsg("DWN", selectedFile);
            //add file reception
        } else {
            Alert alert = new Alert(Alert.AlertType.WARNING, "Choose File", ButtonType.OK);
            alert.showAndWait();
        }
    }
}

Server:

public class Main {
    public static void main(String[] args) {
        try {
            new Server().run();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


class Server {
//    private final Path USERPATH = Paths.get(".", "serverUsers", "user");
    void run() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            socketChannel.pipeline().addLast(new LineBasedFrameDecoder(Integer.MAX_VALUE, true, false),
                                    new FileServerHandler());
                        }
                    })
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture f = b.bind(8189).sync();
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }


	public class FileServerHandler extends ChannelInboundHandlerAdapter {

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ByteBuf in = (ByteBuf) msg;
        while (in.isReadable()){
            System.out.print((char) in.readByte());
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
===
РџРѕРєР° СѓРґР°Р»РѕСЃСЊ СЂРµР°Р»РёР·РѕРІР°С‚СЊ РїСЂРѕСЃС‚РµР№С€РёР№ РїСЂРѕС‚РѕРєРѕР». РЎР°РјР°СЏ РіР»Р°РІРЅР°СЏ РїСЂРѕР±Р»РµРјР°, СЃ РєРѕС‚РѕСЂРѕР№ РЅРµ СЃРјРѕРі СЂР°Р·РѕР±СЂР°С‚СЊСЃСЏ - РєРѕРіРґР° Рё РєР°Рє РїСЂР°РІРёР»СЊРЅРѕ РѕСЃРІРѕР±РѕР¶РґР°С‚СЊ Р±СѓС„РµСЂ РІ С…РµРЅРґР»РµСЂРµ. Р•СЃР»Рё РїСЂРё РєР°Р¶РґРѕР№ РѕРїРµСЂР°С†РёРё РЅР° РєР»РёРµРЅС‚Рµ РѕС‚РєСЂС‹РІР°С‚СЊ\Р·Р°РєСЂС‹РІР°С‚СЊ СЃРѕРєРµС‚, С‚Рѕ РІСЃС‘ СЂР°Р±РѕС‚Р°РµС‚ С…РѕСЂРѕС€Рѕ. Р•СЃР»Рё СЌС‚РѕРіРѕ РЅРµ РґРµР»Р°С‚СЊ, С‚Рѕ РѕРґРЅР° РѕРїРµСЂР°С†РёСЏ РїСЂРѕС…РѕРґРёС‚ РЅРѕСЂРјР°Р»СЊРЅРѕ, РїРѕС‚РѕРј РІ РєР°РєРѕР№-С‚Рѕ РјРѕРјРµРЅС‚ Р±Р°Р№С‚С‹ РѕС‚ СЂР°Р·РЅС‹С… РѕРїРµСЂР°С†РёР№ "СЃРјРµС€РёРІР°СЋС‚СЃСЏ", РІ Р±Р°Р№С‚Р±СѓС„Рµ РєР°РєР°СЏ-С‚Рѕ РєР°С€Р° Рё СЃРѕРµРґРёРЅРµРЅРёРµ РІРёСЃРёС‚. Р’РѕС‚ СЌС‚РѕС‚ РјРѕРјРµРЅС‚ С…РѕС‚РµР»РѕСЃСЊ Р±С‹ СЂР°Р·РѕР±СЂР°С‚СЊ РїРѕРґСЂРѕР±РЅРµРµ. (РќСѓ Рё РєРѕРґ РїРѕРєР° СЃРѕРІСЃРµРј СЃС‹СЂРѕР№, СЂР°Р±РѕС‚Р°СЋС‚ С‚РѕР»СЊРєРѕ РѕСЃРЅРѕРІРЅС‹Рµ РѕРїРµСЂР°С†РёРё РїРѕ РїСЂРѕС‚РѕРєРѕР»Сѓ)

package com.geekbrains.cloud.client;

import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.*;
import javafx.scene.control.TableColumn.CellEditEvent;
import javafx.scene.control.cell.TextFieldTableCell;
import javafx.stage.DirectoryChooser;
import javafx.stage.Stage;

import java.io.IOException;
import java.net.URL;


import java.util.Optional;
import java.util.ResourceBundle;

public class Controller implements Initializable {
    final private DirectoryChooser directoryChooser = new DirectoryChooser();

    private Network net;
    private Stage primaryStage;
    private ObservableList<File> filelist;
    private ObservableList<File> srvFilelist;



    public void setStage(Stage stage){
        this.primaryStage = stage;
    }

    @FXML
    TableView<File> fileListTable;

    @FXML
    TableView<File> srvFileListTable;

    @FXML
    TableColumn<File, String> srvColName;

    @FXML
    TableColumn<File, String> colName;

    @FXML
    Label currentDir;



    @Override
    public void initialize(URL location, ResourceBundle resources)  {
        try {
            net = new Network();
        } catch (IOException e) {
            e.printStackTrace();
        }
        configureDirectoryChooser();
        currentDir.setText(new java.io.File("./client_storage/").getAbsolutePath());

        try {
            initializeFilelistTable();
            initializeSrvFilelistTable();
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }

    private void configureDirectoryChooser() {
        directoryChooser.setTitle("Р’С‹Р±РµСЂРёС‚Рµ РїР°РїРєСѓ");
        directoryChooser.setInitialDirectory(new java.io.File(System.getProperty("user.home")));
    }

    private void initializeFilelistTable() throws IOException {
        fileListTable.getSelectionModel().setSelectionMode(javafx.scene.control.SelectionMode.MULTIPLE);
        refreshDir(currentDir.getText());
        colName.setCellFactory(TextFieldTableCell.forTableColumn());
        colName.setOnEditCommit((CellEditEvent<File, String> event) -> {
            TablePosition<File, String> pos = event.getTablePosition();
            String newFilename = event.getNewValue();
            int row = pos.getRow();
            File file = event.getTableView().getItems().get(row);
            if(!file.renameFile(newFilename)) {
                Alert alert = new Alert(Alert.AlertType.ERROR, "РќРµ СѓРґР°Р»РѕСЃСЊ РїРµСЂРµРёРјРµРЅРѕРІР°С‚СЊ С„Р°Р№Р»", ButtonType.OK);
                alert.showAndWait();
            }
            try {
                refreshDir(currentDir.getText());
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
    }

    private void initializeSrvFilelistTable() throws IOException, InterruptedException {
        srvFileListTable.getSelectionModel().setSelectionMode(javafx.scene.control.SelectionMode.MULTIPLE);
        refreshSrvDir();
        srvColName.setCellFactory(TextFieldTableCell.forTableColumn());
        srvColName.setOnEditCommit((CellEditEvent<File, String> event) -> {
            TablePosition<File, String> pos = event.getTablePosition();
            String oldFileName = event.getOldValue();
            String newFilename = event.getNewValue();
            int row = pos.getRow();
            File file = event.getTableView().getItems().get(row);
            file.setName(newFilename);

            try {
                net.renameFile(oldFileName, newFilename);
                refreshSrvDir();
            } catch (IOException | InterruptedException e) {
                e.printStackTrace();
            }
        });
    }

    public void btnChooseDirectory() throws IOException {
        java.io.File dir = directoryChooser.showDialog(primaryStage);
        if(dir != null){
            currentDir.setText(dir.getAbsolutePath());
            refreshDir(dir.getAbsolutePath());
        }
    }

    public void btnRenameFile(){
        int row = fileListTable.getFocusModel().getFocusedIndex();
        fileListTable.getSelectionModel().getTableView().edit(row,colName);
    }

    public void btnRemoveFile() throws IOException {
        Alert alert = new Alert(Alert.AlertType.CONFIRMATION, "РЈРґР°Р»РёС‚СЊ РІС‹Р±СЂР°РЅРЅС‹Рµ С„Р°Р№Р»С‹?", ButtonType.OK, ButtonType.CANCEL);
        Optional<ButtonType> result = alert.showAndWait();
        if (result.get().getText().equals("OK")) {
            ObservableList<File> items = fileListTable.getSelectionModel().getSelectedItems();
            int i = 0;
            for (File item : items) {
                if(!item.delete()) i++;
            }
            if (i>0){
                Alert error = new Alert(Alert.AlertType.ERROR, "РќРµ СѓРґР°Р»РѕСЃСЊ СѓРґР°Р»РёС‚СЊ РЅРµРєРѕС‚РѕСЂС‹Рµ С„Р°Р№Р»С‹", ButtonType.OK);
                error.showAndWait();
            }
            refreshDir(currentDir.getText());
        }
    }

    public void btnRefresh() throws IOException {
        refreshDir(currentDir.getText());
    }

    private void refreshDir(String text) throws IOException {
        filelist = new FileList(text).getFileList();
        fileListTable.setItems(filelist);
    }

    private void refreshSrvDir() throws IOException, InterruptedException {
        srvFilelist = new FileList().getFileList(net.getFilelist());
        srvFileListTable.setItems(srvFilelist);
    }

    public void btnSrvRenameFile(ActionEvent actionEvent) {
        int row = srvFileListTable.getFocusModel().getFocusedIndex();
        srvFileListTable.getSelectionModel().getTableView().edit(row,srvColName);
    }

    public void btnSrvRemoveFile(ActionEvent actionEvent) throws IOException, InterruptedException {
        String filename = srvFileListTable.getSelectionModel().getSelectedItem().getName();
        net.deleteFile(filename);
        refreshSrvDir();
    }

    public void btnSrvRefresh(ActionEvent actionEvent) throws IOException, InterruptedException {
        refreshSrvDir();
    }

    public void btnUpload(ActionEvent actionEvent) throws IOException, InterruptedException {
        java.io.File file = new java.io.File(fileListTable.getSelectionModel().getSelectedItem().getAbsolutePath());
        net.sendFile(file);

    }

    public void btnDownload(ActionEvent actionEvent) throws IOException {
        String filename = srvFileListTable.getSelectionModel().getSelectedItem().getName();
        net.getFile(filename);
        refreshDir(currentDir.getText());
    }
}



package com.geekbrains.cloud.client;

import java.nio.file.Path;
import java.nio.file.Paths;

public class File {
    private String name;
    private long size;
    private String strSize;
    private String absolutePath;
    private Path file;

    public File(String name, long size){
        this.name = name;
        this.size = size;
        this.strSize = strSize(size, true);
    }

    public File(String name, long size, String absolutePath){
        this.name = name;
        this.size = size;
        this.strSize = strSize(size, true);
        this.absolutePath = absolutePath;
        this.file = Paths.get(this.absolutePath);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public long getSize() {
        return size;
    }

    public void setSize(long size) {
        this.size = size;
        this.strSize = strSize(size, true);
    }

    public String getStrSize() {
        return strSize;
    }

    public String getAbsolutePath() {
        return absolutePath;
    }

    public void setAbsolutePath(String absolutePath) {
        this.absolutePath = absolutePath;
    }

    @Override
    public String toString() {
        return this.name;
    }

    private static String strSize(long bytes, boolean si) {
        int unit = si ? 1000 : 1024;
        if (bytes < unit) return bytes + " B";
        int exp = (int) (Math.log(bytes) / Math.log(unit));
        String pre = (si ? "kMGTPE" : "KMGTPE").charAt(exp-1) + (si ? "" : "i");
        return String.format("%.1f %sB", bytes / Math.pow(unit, exp), pre);
    }

    public boolean renameFile(String name){

        if(file.toFile().renameTo(new java.io.File(name))) {
            setAbsolutePath(file.getParent().toAbsolutePath().normalize() + "\\" + name);
            this.name = name;
            return true;
        }
        return false;
    }


    public boolean delete(){
        return file.toFile().delete();
    }
}
package com.geekbrains.cloud.client;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.EnumSet;

public class FileList {
    private String strPath;

    public FileList(){

    }

    public FileList(String strPath){
        this.strPath = strPath;
    }



    public ObservableList<File> getFileList() throws IOException {
        ObservableList<File> list = FXCollections.observableArrayList();
        Path path = Paths.get(strPath);
        Files.walkFileTree(path, EnumSet.noneOf(FileVisitOption.class), 1, new FileVisitor<Path>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                String fileName = file.getFileName().toString();
                long fileSize = file.toFile().length();
                String absolutePath = file.toAbsolutePath().toString();
                if (!file.toFile().isDirectory()){
                    list.add(new File(fileName, fileSize, absolutePath));
                }
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                return FileVisitResult.CONTINUE;
            }
        });

        return list;
    }

    public ObservableList<File> getFileList(ArrayList<String> arrayList) throws IOException {
        ObservableList<File> list = FXCollections.observableArrayList();
        for (String s :
                arrayList) {
            String name = s.split("\t")[0];
            long size = Long.parseLong(s.split("\t")[1]);
            list.add(new File(name, size));
        }

        return list;
    }


}
package com.geekbrains.cloud.client;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;

public class Main extends Application {
    @Override
    public void start(Stage primaryStage) throws Exception{
        FXMLLoader loader = new FXMLLoader(getClass().getResource("/Main.fxml"));
        Parent root = (Parent)loader.load();
        Controller controller = (Controller)loader.getController();
        controller.setStage(primaryStage);
        primaryStage.setTitle("eddy");
        primaryStage.setScene(new Scene(root, 1024, 768));
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
package com.geekbrains.cloud.client;

import java.io.File;
import java.io.*;
import java.net.Socket;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.Arrays;

public class Network {

    private Socket socket;
    private DataOutputStream out;
    private DataInputStream in;

    public Network() throws IOException {

    }


    public void connect() throws IOException {
        socket = new Socket("localhost", 8189);
        //out = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));
        //in = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
        out = new DataOutputStream(socket.getOutputStream());
        in = new DataInputStream(socket.getInputStream());

    }

    public void disconnect() throws IOException {
        in.close();
        out.close();
        socket.close();
    }

    public void getFile(String filename) throws IOException {
        connect();
        out.write(16);
        byte[] filenameBytes = filename.getBytes();
        out.writeInt(filenameBytes.length);
        out.write(filenameBytes);
        System.out.println(out.size());
        long fileSize = in.readLong();
        System.out.println("get file size: " + fileSize);
        FileOutputStream fos = new FileOutputStream("./client_storage/"+filename);
        FileChannel channel = fos.getChannel();
        long count = 0;
        while(count != fileSize) {
            count = channel.transferFrom(Channels.newChannel(in), channel.position(), fileSize);
            System.out.println(count);
        }
        channel.close();
        fos.close();
        out.flush();
        disconnect();
    }

    public void sendFile(File file) throws IOException {
        connect();
        out.write(15);
        FileInputStream fis = new FileInputStream(file);
        byte[] filenameBytes = file.getName().getBytes();
        System.out.println(filenameBytes.length);
        out.writeInt(filenameBytes.length);
        out.write(filenameBytes);
        long fileSize = file.length();
        out.writeLong(fileSize);
        byte[] buf = new byte[8192];
        int count;
        long countL = 0;
        while ((count = fis.read(buf)) > 0) {
            out.write(buf, 0, count);
            countL += count;
            System.out.println(countL+":"+fileSize);
        }
        fis.close();
        out.flush();
        disconnect();
    }

    public void renameFile(String targetFilename, String newFilename) throws IOException {
        connect();
        out.write(26);
        System.out.println("send rename 26 byte");
        byte[] targetFilenameBytes = targetFilename.getBytes();
        byte[] newFilenameBytes = newFilename.getBytes();
        out.writeInt(targetFilenameBytes.length);
        out.write(targetFilenameBytes);
        out.writeInt(newFilenameBytes.length);
        out.write(newFilenameBytes);
        out.flush();
        disconnect();
    }

    public void deleteFile(String filename) throws IOException {
        connect();
        out.write(27);
        byte[] filenameBytes = filename.getBytes();
        out.writeInt(filenameBytes.length);
        out.write(filenameBytes);
        out.flush();
        disconnect();
    }

    public ArrayList<String> getFilelist() throws IOException, InterruptedException {
        connect();
        ArrayList<String> fileList = new ArrayList<>();
        out.write(33);
        int arrLength = in.readInt();
        if(arrLength!=-1) {
            String strFilelist = in.readUTF();
            System.out.println(strFilelist);
            System.out.println(strFilelist.length());
            fileList.addAll(Arrays.asList(strFilelist.split("\n")));
        }
        disconnect();
        return fileList;
    }


}
package com.geekbrains.cloud.server;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;

public class ProtocolServer {
    private int port;

    public ProtocolServer(int port) {
        this.port = port;
    }

    public void run() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() { // (4)
                        @Override
                        public void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(
                                    new ProtocolHandler());
                        }
                    })
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture f = b.bind(port).sync();
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        new ProtocolServer(8189).run();
    }
}
package com.geekbrains.cloud.server;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufOutputStream;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.DefaultFileRegion;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class Proto {


    public enum DataType {
        EMPTY((byte)-1), GETFILE((byte)15), SENDFILE((byte)16), RENAME((byte)26), DELETE((byte)27), FILELIST((byte)33);

        byte firstMessageByte;

        DataType(byte firstMessageByte) {
            this.firstMessageByte = firstMessageByte;
        }

        static DataType getDataTypeFromByte(byte b) {
            if (b == GETFILE.firstMessageByte) {
                return GETFILE;
            }
            if (b == SENDFILE.firstMessageByte) {
                return SENDFILE;
            }
            if (b == RENAME.firstMessageByte) {
                return RENAME;
            }
            if (b == DELETE.firstMessageByte) {
                return DELETE;
            }
            if (b == FILELIST.firstMessageByte) {
                return FILELIST;
            }

            return EMPTY;
        }
    }

//    private ByteBuf buf;

    private int state = -1;
    private int reqLen = -1;
    private long fileLen = 0;
    private long countL = 0;
    private FileOutputStream fos;
    private FileChannel channelIn;
    private FileInputStream fis;
    private File targetFile;

    public Proto() {

    }

    public int getState() {
        return state;
    }

    public void setState(int state) {
        this.state = state;
    }

    public int getReqLen() {
        return reqLen;
    }

    public void setReqLen(int reqLen) {
        this.reqLen = reqLen;
    }


    public void sendFile(ByteBuf buf, ChannelHandlerContext ctx) throws IOException {
        if (state == 0) {
            if (buf.readableBytes() < reqLen) {
                return;
            }

            reqLen = buf.readInt();
            state = 1;
            System.out.println("filename length: " + reqLen);
        }

        if (state == 1) {
            if (buf.readableBytes() < reqLen) {
                return;
            }
            byte[] data = new byte[reqLen];
            buf.readBytes(data);
            String str = new String(data);
            System.out.println(str);
            RandomAccessFile raf = null;
            raf = new RandomAccessFile("./server_storage/"+str, "r");
            File file = new File("./server_storage/"+str);
            fis = new FileInputStream(file);
            fileLen = file.length();
            System.out.println(fileLen);
            final DefaultFileRegion dfr = new DefaultFileRegion(raf.getChannel(),0,fileLen);
            ctx.writeAndFlush(Unpooled.wrappedBuffer(longToBytes(fileLen)))
                    .addListener((ChannelFutureListener) future -> ctx.writeAndFlush(dfr)
                            .addListener((ChannelFutureListener) future1 -> {
                                            fis.close();
                                            state = -1;
                                            reqLen = -1;
                                            System.out.println("done");
            }));


        }


    }

    public void getFile(ByteBuf buf, ChannelHandlerContext ctx) throws IOException {
        if (state == 0) {
            if (buf.readableBytes() < reqLen) {
                return;
            }

            reqLen = buf.readInt();
            state = 1;
            System.out.println("filename length: " + reqLen);
        }

        if (state == 1) {
            if (buf.readableBytes() < reqLen) {
                return;
            }
            byte[] data = new byte[reqLen];
            buf.readBytes(data);
            String str = new String(data);
            state = 2;
            reqLen = 8;
            System.out.println(str);
            fos = new FileOutputStream("./server_storage/"+str);
        }

        if (state == 2) {
            if (buf.readableBytes() < reqLen) {
                return;
            }
            fileLen = buf.readLong();
            state = 3;
            System.out.println("file size: " + fileLen);
            channelIn = fos.getChannel();
        }

        if (state == 3) {

            byte[] bytes = new byte[buf.readableBytes()];
            buf.readBytes(bytes);
            ByteBuffer nioBuf = ByteBuffer.wrap(bytes);
            countL += nioBuf.remaining();
            while(nioBuf.hasRemaining()) {
                channelIn.write(nioBuf);
            }


        }

        if (state == 3 && countL == fileLen) {
            channelIn.close();
            fos.close();
            state = -1;
            reqLen = -1;
            System.out.println("close");
        }
    }

    public void renameFile(ByteBuf buf, ChannelHandlerContext ctx) throws FileNotFoundException {
        if (state == 0) {
            if (buf.readableBytes() < reqLen) {
                return;
            }

            reqLen = buf.readInt();
            state = 1;
            System.out.println("target filename length: " + reqLen);
        }

        if (state == 1) {
            if (buf.readableBytes() < reqLen) {
                return;
            }
            byte[] data = new byte[reqLen];
            buf.readBytes(data);
            String targetFilename = new String(data);
            state = 2;
            reqLen = 4;
            System.out.println(targetFilename);
            targetFile = new File("./server_storage/"+targetFilename);
        }

        if (state == 2) {
            if (buf.readableBytes() < reqLen) {
                return;
            }

            reqLen = buf.readInt();
            state = 3;
            System.out.println("new filename length: " + reqLen);
        }

        if (state == 3) {
            if (buf.readableBytes() < reqLen) {
                return;
            }
            byte[] data = new byte[reqLen];
            buf.readBytes(data);
            String newFilename = new String(data);
            System.out.println(newFilename);
            File newFile = new File(targetFile.getParent()+"/"+newFilename);
            if (!targetFile.renameTo(newFile)) {
                System.out.println("error rename to " + newFile.getAbsolutePath());
            }
            state = -1;
            reqLen = -1;
            targetFile = null;
            System.out.println("also " + buf.readableBytes());
        }

    }

    public void deleteFile(ByteBuf buf, ChannelHandlerContext ctx) {
        if (state == 0) {
            if (buf.readableBytes() < reqLen) {
                return;
            }

            reqLen = buf.readInt();
            state = 1;
            System.out.println("filename to delete length: " + reqLen);
        }

        if (state == 1) {
            if (buf.readableBytes() < reqLen) {
                return;
            }
            byte[] data = new byte[reqLen];
            buf.readBytes(data);
            String targetFilename = new String(data);
            System.out.println(targetFilename);
            targetFile = new File("./server_storage/"+targetFilename);
            if(!targetFile.delete()){
                System.out.println("delete file error");
            }
            state = -1;
            reqLen = -1;
        }

    }

    public void filelist(ByteBuf buf, ChannelHandlerContext ctx) throws IOException {
        if (state == 0) {
            System.out.println("send filelist");

            ByteBuf bb = Unpooled.buffer();
            ByteBufOutputStream out = new ByteBufOutputStream(bb);

            File dir = new File("./server_storage/");
            System.out.println(dir.getAbsolutePath());
            File[] filelist = dir.listFiles();
            StringBuilder sb = new StringBuilder();
            if(filelist!=null) {
                for (File f :
                        filelist) {
                    System.out.println(f.getName() + " " + f.length());
                    sb.append(f.getName() +"\t" + f.length() + "\n");
                }

                System.out.println(sb + "\t" + sb.length());


                    out.writeInt(sb.length());
                    out.writeUTF(sb.toString());


            } else out.writeInt(-1);

            out.close();
            ctx.write(bb);
            ctx.flush();
        }
    }

    private byte[] longToBytes(long l) {
        byte[] result = new byte[8];
        for (int i = 7; i >= 0; i--) {
            result[i] = (byte)(l & 0xFF);
            l >>= 8;
        }
        return result;
    }


}
package com.geekbrains.cloud.server;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.PooledByteBufAllocator;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;

public class ProtocolHandler extends ChannelInboundHandlerAdapter {

    private Proto proto = new Proto();
    private Proto.DataType type;
    private ByteBuf buf = new PooledByteBufAllocator().buffer(0);

    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        System.out.println(ctx.name() + " hadler added");

    }

    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
        System.out.println(ctx.name() + "handler removed");

    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {


        ByteBuf msgbuf = ((ByteBuf) msg);
        buf.writeBytes(msgbuf, msgbuf.readableBytes());


            if (proto.getState() == -1) {
                byte firstByte = buf.readByte();
                type = Proto.DataType.getDataTypeFromByte(firstByte);
                proto.setState(0);
                proto.setReqLen(4);
                System.out.println(firstByte);
                System.out.println(type);
            }

            switch (type) {
                case GETFILE:
                    proto.getFile(buf, ctx);
                    break;
                case SENDFILE:
                    proto.sendFile(buf, ctx);
                    break;
                case RENAME:
                    proto.renameFile(buf, ctx);
                    break;
                case DELETE:
                    proto.deleteFile(buf, ctx);
                    break;
                case FILELIST:
                    proto.filelist(buf, ctx);
                    break;
            }

        msgbuf.release();
    }


    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
===
{\rtf1\ansi\ansicpg1251\cocoartf1671\cocoasubrtf400
{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\fnil\fcharset0 HelveticaNeue;\f2\fnil\fcharset0 HelveticaNeue-Italic;
}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs36 \cf0 1. \uc0\u1042  \u1072 \u1088 \u1093 \u1080 \u1074 \u1077  \u1074 \u1072 \u1088 \u1080 \u1072 \u1085 \u1090  \u1093 \u1088 \u1072 \u1085 \u1080 \u1083 \u1080 \u1097 \u1072  \u1075 \u1076 \u1077  \u1082 \u1083 \u1080 \u1077 \u1085 \u1090  \u1080  \u1089 \u1077 \u1088 \u1074 \u1077 \u1088  \u1088 \u1077 \u1072 \u1083 \u1080 \u1079 \u1086 \u1074 \u1072 \u1085 \u1099  \u1085 \u1072  netty, \u1085 \u1086  \u1086 \u1090  \u1082 \u1083 \u1080 \u1077 \u1085 \u1090 \u1072  \u1087 \u1077 \u1088 \u1077 \u1076 \u1072 \u1095 \u1072  \u1092 \u1072 \u1081 \u1083 \u1072  \u1085 \u1072  \u1089 \u1077 \u1088 \u1074 \u1077 \u1088  \u1088 \u1072 \u1073 \u1086 \u1090 \u1072 \u1077 \u1090  \u1085 \u1077 \u1082 \u1086 \u1088 \u1088 \u1077 \u1082 \u1090 \u1085 \u1086  : \u1092 \u1072 \u1081 \u1083  \u1085 \u1072  \u1089 \u1090 \u1086 \u1088 \u1086 \u1085 \u1077  \u1089 \u1077 \u1088 \u1074 \u1077 \u1088 \u1072  \u1089 \u1086 \u1079 \u1076 \u1072 \u1077 \u1090 \u1089 \u1103 , \u1085 \u1086  \u1074 \u1084 \u1077 \u1089 \u1090 \u1086  \u1085 \u1091 \u1078 \u1085 \u1086 \u1075 \u1086  \u1089 \u1086 \u1076 \u1077 \u1088 \u1078 \u1080 \u1084 \u1086 \u1075 \u1086  \u1090 \u1086 \u1083 \u1100 \u1082 \u1086  \u1086 \u1090 \u1087 \u1088 \u1072 \u1074 \u1083 \u1077 \u1085 \u1085 \u1072 \u1103  \u1082 \u1086 \u1084 \u1072 \u1085 \u1076 \u1072 :\
\
\pard\pardeftab560\slleading20\pardirnatural\partightenfactor0

\f1\fs28 \cf0 @Override\
protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception \{\
   Channel incoming = channelHandlerContext.channel();\
       \
      String[] toSplit = s.split(" ");\
//\uc0\u1086 \u1090 \u1087 \u1088 \u1072 \u1074 \u1082 \u1072  \u1076 \u1072 \u1085 \u1085 \u1099 \u1093  \u1082 \u1083 \u1080 \u1077 \u1085 \u1090 \u1091 \
      if(toSplit[0].equals("dwnl"))\{\
          storage = "server_storage/";\
          fileName = toSplit[1];\
\
          incoming.writeAndFlush(new ChunkedStream(new FileInputStream(storage+fileName)));\
      \}\
    else \{\
// \uc0\u1087 \u1086 \u1083 \u1091 \u1095 \u1077 \u1085 \u1080 \u1077  \u1076 \u1072 \u1085 \u1085 \u1099 \u1093  \u1086 \u1090  \u1082 \u1083 \u1080 \u1077 \u1085 \u1090 \u1072 \
          if (toSplit[0].equals("send")) \{\
\
              storage = "server_storage/";\
              fileName = toSplit[1];\
\
              FileOutputStream fileOutputStream = new FileOutputStream(storage + fileName, true);\
              fileOutputStream.write((s + "\\n").getBytes());\
\
              fileOutputStream.close();\
             // System.
\f2\i out
\f1\i0 .println(s);\
          \}\
      \}\
\}
\f0\fs36 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \uc0\u1050 \u1072 \u1082  \u1101 \u1090 \u1086  \u1084 \u1086 \u1078 \u1085 \u1086  \u1080 \u1089 \u1087 \u1088 \u1072 \u1074 \u1080 \u1090 \u1100 ?\
\
2. \uc0\u1059  \u1084 \u1077 \u1085 \u1103  \u1077 \u1089 \u1090 \u1100  \u1079 \u1072 \u1075 \u1086 \u1090 \u1086 \u1074 \u1082 \u1072  \u1075 \u1088 \u1072 \u1092 \u1080 \u1095 \u1077 \u1089 \u1082 \u1086 \u1075 \u1086  \u1080 \u1085 \u1090 \u1077 \u1088 \u1092 \u1077 \u1081 \u1089 \u1072  \u1080  \u1087 \u1086 \u1083 \u1100 \u1079 \u1086 \u1074 \u1072 \u1090 \u1077 \u1083 \u1100 \u1089 \u1082 \u1086 \u1081  \u1072 \u1074 \u1090 \u1086 \u1088 \u1080 \u1079 \u1072 \u1094 \u1080 \u1080  \u1085 \u1072 \u1087 \u1080 \u1089 \u1072 \u1085 \u1085 \u1099 \u1077  \u1089  \u1087 \u1086 \u1084 \u1086 \u1097 \u1100 \u1102  \u1089 \u1090 \u1072 \u1085 \u1076 \u1072 \u1088 \u1090 \u1085 \u1086 \u1081  java i/o.
\f1\fs24 \
\pard\pardeftab560\slleading20\pardirnatural\partightenfactor0

\fs28 \cf0 public class Controller \{\
\
    @FXML\
    HBox bottomPanel;\
    @FXML\
    Button Auth;\
    @FXML\
    TextField loginField;\
    @FXML\
    PasswordField passwordField;\
\
\
    private static Socket
\f2\i clientSocket
\f1\i0 ;\
    private static BufferedReader
\f2\i in
\f1\i0 ;\
    private static BufferedWriter
\f2\i out
\f1\i0 ;\
    private  Command toServer;\
    private  Command fromServer;\
\
    private Channel channel;\
    private EventLoopGroup group;\
    private byte[] buf ;\
\
    final String IP_ADRESS = "localhost";\
    final int PORT = 8080;\
\
\
    public void Auth() throws IOException \{\
        try \{\
            try \{\
\

\f2\i clientSocket
\f1\i0 = new Socket(IP_ADRESS,PORT);\

\f2\i in
\f1\i0 = new BufferedReader(new InputStreamReader(
\f2\i clientSocket
\f1\i0 .getInputStream()));\

\f2\i out
\f1\i0 = new BufferedWriter(new OutputStreamWriter(
\f2\i clientSocket
\f1\i0 .getOutputStream()));\
                String authInfo = loginField.getText()+","+passwordField.getText();\
\
                toServer.setMarker("auth");\
                toServer.setLine(loginField.getText()+passwordField.getText());\
\
\

\f2\i out
\f1\i0 .write(String.
\f2\i valueOf
\f1\i0 (Unpooled.
\f2\i wrappedBuffer
\f1\i0 (toServer.toString().getBytes())));\

\f2\i out
\f1\i0 .flush();\
\
                String serverWord =  (
\f2\i in
\f1\i0 .readLine());\
                fromServer = new ObjectMapper().readValue(serverWord, Command.class);\
                if(fromServer.getMarker().equals("AuthOk")) CreateClientWindow();\
                else System.
\f2\i out
\f1\i0 .println("\uc0\u1072 \u1074 \u1090 \u1086 \u1088 \u1080 \u1079 \u1072 \u1094 \u1080 \u1103  \u1085 \u1077  \u1087 \u1088 \u1086 \u1096 \u1083 \u1072 ");\
            \} catch (SQLException e) \{\
                e.printStackTrace();\
            \} finally \{\
                System.
\f2\i out
\f1\i0 .println("\uc0\u1050 \u1083 \u1080 \u1077 \u1085 \u1090  \u1073 \u1099 \u1083  \u1079 \u1072 \u1082 \u1088 \u1099 \u1090 ...");\

\f2\i clientSocket
\f1\i0 .close();\

\f2\i in
\f1\i0 .close();\

\f2\i out
\f1\i0 .close();\
            \}\
        \} catch (IOException e) \{\
            System.
\f2\i err
\f1\i0 .println(e);\
        \}\
\
    \}
\fs24 \
\

\fs28  public void CreateClientWindow() throws IOException, SQLException \{\
        Stage stage = new Stage();\
        Parent root = FXMLLoader.
\f2\i load
\f1\i0 (getClass().getResource("/clientWindow.fxml"));\
        stage.setTitle("CloudStorage");\
        stage.setScene(new Scene(root, 450, 450));\
        Stage oldStage = (Stage) Auth.getScene().getWindow();\
        oldStage.close();\
        stage.show();\
\
    \}\
\
\}\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs36 \cf0 \uc0\u1042 \u1086 \u1079 \u1084 \u1086 \u1078 \u1085 \u1086  \u1083 \u1080  \u1089 \u1086 \u1074 \u1084 \u1077 \u1089 \u1090 \u1080 \u1090 \u1100  \u1076 \u1074 \u1077  \u1090 \u1077 \u1093 \u1085 \u1086 \u1083 \u1086 \u1075 \u1080 \u1080 ? \u1050 \u1072 \u1082  \u1085 \u1072 \u1087 \u1088 \u1080 \u1084 \u1077 \u1088  \u1087 \u1077 \u1088 \u1077 \u1076 \u1072 \u1074 \u1072 \u1090 \u1100   socket \u1077 \u1089 \u1083 \u1080  \u1091 \u1078 \u1077  \u1082 \u1086 \u1085 \u1090 \u1088 \u1086 \u1083 \u1083 \u1077 \u1088  \u1086 \u1090 \u1074 \u1077 \u1090 \u1089 \u1090 \u1074 \u1077 \u1085 \u1085 \u1099 \u1081  \u1079 \u1072  \u1074 \u1099 \u1073 \u1086 \u1088  \u1080  \u1087 \u1077 \u1088 \u1077 \u1076 \u1072 \u1095 \u1091  \u1092 \u1072 \u1081 \u1083 \u1086 \u1074  \u1073 \u1091 \u1076 \u1077 \u1090  \u1085 \u1072 \u1087 \u1080 \u1089 \u1072 \u1085  \u1085 \u1072  netty \u1082 \u1072 \u1082  \u1084 \u1086 \u1077 \u1084  \u1082 \u1086 \u1085 \u1089 \u1086 \u1083 \u1100 \u1085 \u1086 \u1084  \u1074 \u1072 \u1088 \u1080 \u1072 \u1085 \u1090 \u1077 ?\
\
\pard\pardeftab560\slleading20\pardirnatural\partightenfactor0

\f1\fs28 \cf0 \

\fs24 \

\f0\fs36 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \
}
===
Project name: cloud-core
package com.geekbrains.cloud.client;


public class Controller {
    @FXML
    TextArea mainTextArea;

    public void btnClickMeAction() {
        mainTextArea.appendText("Java\n");
    }
}
package com.geekbrains.cloud.client;


public class Main extends Application {
    @Override
    public void start(Stage primaryStage) throws Exception{
        Parent root = FXMLLoader.load(getClass().getResource("/sample.fxml"));
        primaryStage.setTitle("Cloud Client");
        primaryStage.setScene(new Scene(root, 400, 400));
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
package com.geekbrains.cloud.common.codec.ftp;



public class DefaultFtpRequest implements FtpRequest {

	private final FtpCommand command;
	private final List<CharSequence> parameters;

	public DefaultFtpRequest(FtpCommand command) {
		this.command = ObjectUtil.checkNotNull(command, "command");
		parameters = Collections.emptyList();
	}

	public DefaultFtpRequest(FtpCommand command, CharSequence... parameters) {
		this.command = ObjectUtil.checkNotNull(command, "command");
		this.parameters = (parameters == null || parameters.length == 0) ? Collections.emptyList() : Collections.unmodifiableList(Arrays.asList(parameters));
	}

	public DefaultFtpRequest(String command, CharSequence... parameters) {
		this(FtpCommand.valueOf(command), parameters);
	}

	DefaultFtpRequest(FtpCommand command, List<CharSequence> parameters) {
		this.command = ObjectUtil.checkNotNull(command, "command");
		this.parameters = parameters != null ?
				Collections.unmodifiableList(parameters) : Collections.emptyList();
	}

	@Override
	public FtpCommand command() {
		return command;
	}

	@Override
	public List<CharSequence> parameters() {
		return parameters;
	}
}
package com.geekbrains.cloud.common.codec.ftp;

public class DefaultFtpResponse implements FtpResponse {
	private int code;
	private CharSequence details;

	public DefaultFtpResponse(int code) {
		this(code, null);
	}

	public DefaultFtpResponse(int code, CharSequence details) {
		this.code = code;
		this.details = details;
	}

	@Override
	public int code() {
		return code;
	}

	@Override
	public CharSequence details() {
		return null;
	}

	@Override
	public String toString() {
		return String.valueOf(code) + " " + details + "\r\n";
	}
}
package com.geekbrains.cloud.common.codec.ftp;

public enum FtpCommand {
	AUTH,
	CWD,
	DELE,
	HELP,
	LIST,
	USER,
	PASS;
}
package com.geekbrains.cloud.common.codec.ftp;


public interface FtpRequest {
	FtpCommand command();
	List<CharSequence> parameters();
}
package com.geekbrains.cloud.common.codec.ftp;


public class FtpRequestDecoder extends LineBasedFrameDecoder {
	private enum State {
		COMMAND,
		DATA;
	}

	private State currentState = State.COMMAND;

	public FtpRequestDecoder(int maxLength) {
		super(maxLength);
	}

	@Override
	protected Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception {
		switch(currentState) {
			case COMMAND:
				ByteBuf frame = (ByteBuf) super.decode(ctx, buffer);
				if(frame == null)
					return null;

				String[] parts = frame.toString(CharsetUtil.UTF_8).split(" ");

				return new DefaultFtpRequest(FtpCommand.valueOf(parts[0]), parts[1]);
			case DATA:
			default:
				return null;
		}
	}

	@Override
	public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
		if(evt instanceof IdleStateEvent) {
			IdleStateEvent e = (IdleStateEvent) evt;
			if(e.state() == IdleState.READER_IDLE)
				ctx.close();
		}
	}

	@Override
	public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
		if(ctx.channel().isOpen())
			ctx.channel().writeAndFlush(new DefaultFtpResponse(500, "Unspecified error"));
	}
}
package com.geekbrains.cloud.common.codec.ftp;


public interface FtpResponse {
	int code();
	CharSequence details();
}
package com.geekbrains.cloud.common.codec.ftp;


public class FtpResponseEncoder extends MessageToByteEncoder<FtpResponse> {

	@Override
	protected void encode(ChannelHandlerContext ctx, FtpResponse msg, ByteBuf out) throws Exception {
		ByteBufUtil.writeUtf8(out, msg.toString());
	}
}
package com.geekbrains.cloud.common;

public class MyData {
    private int data;

    public int getData() {
        return data;
    }

    public MyData(int data) {
        this.data = data;
    }
}
package com.geekbrains.cloud.server;


public class GeekCloudServer extends SimpleChannelInboundHandler {
	private boolean isAuthenticated = false;
	private CharSequence userName = null;
	private CharSequence userPass = null;

	@Override
	public void channelActive(ChannelHandlerContext ctx) throws Exception {
		send(ctx, new DefaultFtpResponse(200, "Service ready"));
	}

	@Override
	protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
		if(msg instanceof FtpRequest) {
			switch(((FtpRequest) msg).command()) {
				case USER:
					userName = ((FtpRequest) msg).parameters().get(0);
					send(ctx, new DefaultFtpResponse(331, "Anonymous login ok, send your complete email address as your password"));
				break;
				case PASS:
					userPass = ((FtpRequest) msg).parameters().get(0);
					isAuthenticated = true;
					send(ctx, new DefaultFtpResponse(230, "Logged in anonymously."));
					break;
				default:
					send(ctx, new DefaultFtpResponse(500, "Unimplemented"));
			}
		}
	}

	private static void send(ChannelHandlerContext ctx, DefaultFtpResponse msg) {
		ctx.channel().writeAndFlush(msg);
	}
}
Р‘РѕРґР°СЋСЃСЊ СЃ РіРёР±СЂРёРґРЅС‹Рј РїСЂРѕС‚РѕРєРѕР»РѕРј. Р’ Р°СЂС…РёРІРµ Рѕ-Рѕ-Рѕ-РѕС‡РµРЅСЊ РїСЂРѕРјРµР¶СѓС‚РѕС‡РЅС‹Р№ СЂРµР·СѓР»СЊС‚Р°С‚. Р‘СѓРґСѓ РїРµСЂРµРґРµР»С‹РІР°С‚СЊ Р°РІС‚РѕРјР°С‚ РЅР° С…СЂР°РЅРµРЅРёРµ СЃРѕСЃС‚РѕСЏРЅРёР№ РІ AttributeKey, РґР»СЏ РїРµСЂРµРґР°С‡Рё СЃРѕСЃС‚РѕСЏРЅРёСЏ РјРµР¶РґСѓ РѕР±СЂР°Р±РѕС‚С‡РёРєР°РјРё.

package com.geekbrains.cloud.server;



public class ServerApp {
	static final boolean SSL = System.getProperty("ssl") != null;
	static final int PORT = Integer.parseInt(System.getProperty("port", SSL ? "8992" : "8023"));
	static final int READ_TIMEOUT = Integer.parseInt(System.getProperty("readTimeout", "10"));

	public static void main(String[] args) throws CertificateException, InterruptedException, SSLException {
		final SslContext sslCtx;
		if(SSL) {
			SelfSignedCertificate ssc = new SelfSignedCertificate();
			sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
		} else {
			sslCtx = null;
		}

		EventLoopGroup bossGroup = new NioEventLoopGroup(1);
		EventLoopGroup workerGroup = new NioEventLoopGroup();
		try {
			ServerBootstrap b = new ServerBootstrap();
			b.group(bossGroup, workerGroup)
					.channel(NioServerSocketChannel.class)
					.option(ChannelOption.SO_BACKLOG, 100)
					.handler(new LoggingHandler(LogLevel.INFO))
					.childHandler(new ChannelInitializer<SocketChannel>() {
						@Override
						public void initChannel(SocketChannel ch) throws Exception {
							ChannelPipeline p = ch.pipeline();
							if(sslCtx != null)
								p.addLast(sslCtx.newHandler(ch.alloc()));

							p.addLast(
									new IdleStateHandler(READ_TIMEOUT, 0, 0),
									new FtpResponseEncoder(),
									new FtpRequestDecoder(8192),
									new GeekCloudServer()
							);
						}
					});

			ChannelFuture f = b.bind(PORT).sync();
			f.channel().closeFuture().sync();
		} finally {
			bossGroup.shutdownGracefully();
			workerGroup.shutdownGracefully();
		}
	}
}
========================================
========================================
Project name: cloudcore-alpha
package controller;


/**
 * РљР»Р°СЃСЃ РєРѕРЅС‚СЂРѕР»Р»РµСЂР° РґР»СЏ РѕР±СЂР°Р±РѕС‚РєРё СЃРѕР±С‹С‚РёР№ РѕРєРЅР° Р°РІС‚РѕСЂРёР·Р°С†РёРё.
 * */
public class AuthorisationController {

    @FXML private StackPane rootNode;
    @FXML private TextField login;
    @FXML private PasswordField password;
    @FXML private Label msg;
    final private Timer timer = new Timer(true);              //С‚Р°Р№РјРµСЂ РґР»СЏ Р·Р°РїСѓСЃРєР° Р·Р°РґР°РЅРёР№
    private String name;                                               //РёРјСЏ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ
    private String pswd;                                               //РїР°СЂРѕР»СЊ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ

    /**
     * РќР°Р±РѕСЂ РєРѕРЅСЃС‚Р°РЅС‚ РїРµСЂРµС‡РёСЃР»РёРјРѕРіРѕ С‚РёРїР° РёРЅРєР°РїСЃСѓР»РёСЂСѓСЋС‰РёС… СЂРµР·СѓР»СЊС‚Р°С‚ РІРІРѕРґР° РїР°СЂС‹ Р»РѕРіРёРЅ/РїР°СЂРѕР»СЊ
     * */
    private enum Status {
        EMPTYLOGIN,         //РїСѓСЃС‚РѕР№ Р»РѕРіРёРЅ
        EMPTYPASSWORD,      //РїСѓСЃС‚РѕР№ РїР°СЂРѕР»СЊ
        EMPTYBOTH,          //РїСѓСЃС‚РѕР№ Р»РѕРіРёРЅ Рё РїР°СЂРѕР»СЊ
        BADLOGINORPASSWORD, //РЅРµРїСЂР°РІРёР»СЊРЅС‹Р№ Р»РѕРіРёРЅ РёР»Рё РїР°СЂРѕР»СЊ
        GOOD                //РїСЂР°РІРёР»СЊРЅС‹Р№ Р»РѕРіРёРЅ Рё РїР°СЂРѕР»СЊ
    }

    public void initialize(){
    }
    /**
     * РњРµС‚РѕРґ РѕР±СЂР°Р±РѕС‚РєРё СЃРѕР±С‹С‚РёСЏ РЅР°Р¶Р°С‚РёСЏ РєРЅРѕРїРєРё. РџСЂРё РЅР°Р¶Р°С‚РёРё РєРЅРѕРїРєРё СЃС‡РёС‚С‹РІР°РµС‚СЃСЏ С‚РµРєСЃ РёР· textfield СЃ Р»РѕРіРёРЅРѕРј Рё РїР°СЂРѕР»РµРј.
     * Р”Р°Р»РµРµ РІС‹Р·С‹РІР°РµС‚СЃСЏ РјРµС‚РѕРґ РґР»СЏ РѕР±СЂР°Р±РѕС‚РєРё СЂРµР·СѓР»СЊС‚Р°С‚Р° РІРІРѕРґР° Р»РѕРіРёРЅР° Рё РїР°СЂРѕР»СЏ.
     * @param actionEvent - РѕР±СЉРµРєС‚ СЃРѕР±С‹С‚РёСЏ
     * */
    public void btnClick(ActionEvent actionEvent) {
        name = login.getText();
        pswd = password.getText();
        if(name.isEmpty() && pswd.isEmpty()) {
            statusProcessing(Status.EMPTYBOTH);
        }
        else if(name.isEmpty()) {
            statusProcessing(Status.EMPTYLOGIN);
        }
        else if(pswd.isEmpty()) {
            statusProcessing(Status.EMPTYPASSWORD);
        }
        else if(name.equals("test") && pswd.equals("test")){
            statusProcessing(Status.GOOD);
        } else {
            statusProcessing(Status.BADLOGINORPASSWORD);
        }
    }

    /**
     * РњРµС‚РѕРґ РѕР±СЂР°Р±РѕС‚РєРё СЂРµР·СѓР»СЊС‚Р°С‚ РІРІРѕРґР° Р»РѕРіРёРЅР° Рё РїР°СЂРѕР»СЏ. Р•СЃР»Рё РІРІРµРґРµРЅ РєРѕСЂСЂРµРєС‚РЅС‹Р№ Р»РѕРіРёРЅ Рё РїР°СЂРѕР»СЊ, С‚Рѕ РІС‹Р·СЏРІР°РµС‚СЃСЏ РјРµС‚РѕРґ
     * @createNewScene() РґР»СЏ СЃРѕР·РґР°РЅРёСЏ РЅРѕРІРѕР№ СЃС†РµРЅС‹. Р’ РёРЅС‹С… СЃРёС‚СѓР°С†РёСЏС… РІС‹РІРѕРґРёС‚СЃСЏ СЃРѕРѕР±С‰РµРЅРёРµ Рё РїСЂРµРґР»Р°РіР°РµС‚СЃСЏ РІРІРµСЃС‚Рё Р»РѕРіРёРЅ Рё
     * РїР°СЂРѕР»СЊ РїРѕРІС‚РѕСЂРЅРѕ
     * @param st - РѕР±СЉРµРєС‚ РїРµСЂРµС‡РёСЃР»РёРјРѕРіРѕ С‚РёРїР° РѕРїРёСЃС‹РІР°СЋС‰РёР№ СЂРµР·СѓР»СЊС‚Р°С‚ РІРІРѕРґР° Р»РѕРіРёРЅР° Рё РїР°СЂРѕР»СЏ
     * */
    private void statusProcessing(Status st){
        switch (st){
            case EMPTYLOGIN:
                msg.setText("Login is empty...");
                break;
            case EMPTYPASSWORD:
                msg.setText("Password is empty...");
                break;
            case EMPTYBOTH:
                msg.setText("Login and password is empty...");
                break;
            case BADLOGINORPASSWORD:
                msg.setText("Wrong login or password...");
                break;
            case GOOD:
                createNewScene();
                break;
            default:
                msg.setText("Unknown situation");
        }
        clear();
    }

    /**
     * РЎР»СѓР¶РµР±РЅС‹Р№ РјРµС‚РѕРґ РґР»СЏ РѕС‡РёСЃС‚РєРё С‚РµРєСЃС‚РѕРІРѕРіРѕ РїРѕР»СЏ СЃ Р»РѕРіРёРЅРѕРј Рё РїР°СЂРѕР»РµРј. РњРµС‚РѕРґ С‚Р°РєР¶Рµ Р·Р°РїСѓСЃРєР°РµС‚ Р·Р°РґР°РЅРёРµ (РѕР±СЉРµРєС‚
     * РєР»Р°СЃСЃР° ClearLabelTask) РІ СЂР°РјРєР°С… РєРѕС‚РѕСЂРѕРіРѕ РІ РѕР±СЉРµРєС‚Рµ msg РєР»Р°СЃСЃР° Label РјРµРЅСЏРµС‚СЃСЏ С‚РµРєСЃС‚ СЃРѕРѕР±С‰РµРЅРёСЏ.
     * */
    private void clear(){
        login.clear();
        password.clear();
        timer.schedule(new ClearLabelTask(), 2000);
    }

    /**
     * РЎР»СѓР¶РµР±РЅС‹Р№ РјРµС‚РѕРґ, РєРѕС‚РѕСЂС‹Р№ СЃРѕР·РґР°РµС‚ РЅРѕРІСѓСЋ СЃС†РµРЅСѓ Рё РїСЂРёСЃРІР°РёРІР°РµС‚ РµРµ С‚РµРєСѓС‰РµРјСѓ РѕР±СЉРµРєС‚Сѓ С‚РёРїР° Stage
     * */
    private void createNewScene(){
        Parent root = null;
        try {
            User.SETTING.setName(name);                 //РїСЂРёСЃРІР°РёРІР°РµРј Р»РѕРіРёРЅ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ РѕР±СЉРµРєС‚Сѓ РїРµСЂРµС‡РёСЃР»РёРјРѕРіРѕ С‚РёРїР°
            root = FXMLLoader.load(getClass().getResource("/operatingPanel.fxml"));
            Scene scene = new Scene(root, rootNode.getWidth(), rootNode.getHeight());
            ((Stage)rootNode.getScene().getWindow()).setScene(scene);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * РљР»Р°СЃСЃ РёРЅРєР°РїСЃСѓР»РёСЂСѓРµС‚ Р·Р°РґР°РЅРёРµ РєРѕС‚РѕСЂРѕРµ Р·Р°РїСѓСЃРєР°РµС‚СЃСЏ РѕР±СЉРµРєС‚РѕРј С‚РёРїР° Timer
     * */
    class ClearLabelTask extends TimerTask{
        @Override
        public void run() {
            Platform.runLater(()->msg.setText("Please, try again..."));
        }
    }
}
package controller;



public class ContextMenuController extends Observable {

    public void getMenuCommand(ActionEvent actionEvent) {
        setChanged();
        switch (((MenuItem)actionEvent.getSource()).getId()){
            case "newFile":
                notifyObservers(MenuCommand.NEWFILE);
                break;
            case "newCatalog":
                notifyObservers(MenuCommand.NEWCATALOG);
                break;
            case "move":
                notifyObservers(MenuCommand.MOVE);
                break;
            case "copy":
                notifyObservers(MenuCommand.COPY);
                break;
            case "cut":
                notifyObservers(MenuCommand.CUT);
                break;
            case "paste":
                notifyObservers(MenuCommand.PASTE);
                break;
            case "remname":
                notifyObservers(MenuCommand.REMANE);
                break;
            case "delete":
                notifyObservers(MenuCommand.DELETE);
                break;
            case "search":
                notifyObservers(MenuCommand.SEARCH);
                break;
        }
    }
}
package controller;



public class OperatingPanelController implements Observer {

    @FXML private GridPane rootNode;
    @FXML private TreeView<ExtFile> treeVievClient;
    @FXML private ProgressIndicator progressIndicator;
    @FXML private Label labelStatus;
    @FXML private ContextMenuController cMenuController;    //РґРѕС‡РµСЂРЅРёР№ РєРѕРЅС‚СЂРѕР»Р»РµСЂ (РєРѕРЅС‚РµРєСЃС‚РЅРѕРµ РјРµРЅСЋ)

    public void initialize() throws IOException {

        File[] roots = File.listRoots();
        treeVievClient.setRoot(new TreeItem<>(new ExtFile(User.SETTING.getName())));
        for (int i = 0; i < roots.length; i++) {
            TreeItem<ExtFile> rootChild = new TreeItem<>(new ExtFile(roots[i].getPath()));
            treeVievClient.getRoot().getChildren().addAll(rootChild);
        }
        treeVievClient.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    TreeItem<ExtFile> newV = newValue;
                    if(newV==null || !newV.getValue().canRead()) return;
                    if (!newV.getValue().isDirectory()) {
                    } else {
                        ObservableList<TreeItem<ExtFile>> list = FXCollections.observableArrayList();
                        if (newV.getValue().list()==null) return;
                        int size = newV.getValue().list().length;

                        Platform.runLater(() -> {
                            progressIndicator.setProgress(0f);
                            labelStatus.setText("Р§С‚РµРЅРёРµ РєР°С‚Р°Р»РѕРіР° " + newV.getValue());
                        });

                        for (int i = 0; i < size; i++) {
                            int loc = i + 1;
                            Platform.runLater(() -> progressIndicator.setProgress((loc) * 1.0 / size));
                            list.add(new TreeItem<>(new ExtFile(newValue.getValue(), newValue.getValue().list()[loc-1])));
                        }

                        Platform.runLater(() -> {
                            labelStatus.setText("РљР°С‚Р°Р»РѕРі " + newV.getValue() + " РѕР±РЅРѕРІР»РµРЅ.");
                            progressIndicator.setProgress(1f);
                        });
                        newV.getChildren().setAll(list);
                    }
                }
            }).start();
        });
        cMenuController.addObserver(this::update); //СЂРµРіРёСЃС‚СЂРёСЂСѓРµРј СЃР»СѓС€Р°С‚РµР»СЏ
    }

    //РєР»Р°СЃСЃ РјРѕР¶РЅРѕ Р°РґР°РїС‚РёСЂРѕРІР°С‚СЊ РґР»СЏ РїРѕРёСЃРєР° РёР»Рё СѓРґР°Р»РµРЅРёСЏ С„Р°Р№Р»РѕРІ/РєР°С‚Р°Р»РѕРіРѕРІ


    //СЌРєСЃРїРµСЂРёРјРµРЅС‚Р°Р»СЊРЅС‹Р№ РєР»Р°СЃСЃ, Р·Р°РіСЂСѓР¶Р°РµС‚ СЂРµРєСѓСЂСЃРёРІРЅРѕ РІ РїСЂРёР»РѕР¶РµРЅРёРµ С„Р°Р№Р»РѕРІСѓСЋ СЃС‚СЂСѓРєС‚СѓСЂСѓ Р»РѕРєР°Р»СЊРЅРѕРіРѕ РєРѕРјРїСЊСЋС‚РµСЂР°. РќРµ РїСЂРѕРёР·РІРѕРґРёС‚РµР»СЊРЅС‹Р№ РјРµС‚РѕРґ
//    private void createItemForTree(TreeItem<String> parent, File file){
//        TreeItem<String> child = new TreeItem<>(file.toPath().getFileName().toString());
//        parent.getChildren().addAll(child);
//        if(file.isDirectory()){
//            if(file.list()==null) return;
//            for (String str:
//                    file.list()) {
//                createItemForTree(child, new File(file.getAbsolutePath() + File.separator + str));
//            }
//        }
//    }

    @Override
    public void update(Observable o, Object arg) {
        //РїСЂРѕРІРµСЂСЏРµРј С‚Рѕ, С‡С‚Рѕ СѓРІРµРґРѕРјР»РµРЅРёРµ РїСЂРёС€Р»Рѕ РѕС‚ РєРѕРЅС‚СЂРѕР»Р»РµСЂР° РєРѕРЅС‚РµРєСЃС‚РЅРѕРіРѕ РјРµРЅСЋ
        if(((Observable)cMenuController).equals(o) ){
            switch ((MenuCommand)arg){
                case NEWFILE:
                    TreeViewUtility.createNewFileAndTreeItem(treeVievClient);
                    break;
                case NEWCATALOG:
                    TreeViewUtility.createNewCatalogAndTreeItem(treeVievClient);
                    break;
                case MOVE:
                    TreeViewUtility.moveFileAndTreeItem(treeVievClient);
                    break;
                case COPY:
                    TreeViewUtility.copyFileAndTreeItem(treeVievClient);
                    break;
                case CUT:
                    TreeViewUtility.cutFileAndTreeItem(treeVievClient);
                    break;
                case PASTE:
                    TreeViewUtility.pasteFileAndTreeItem(treeVievClient);
                    break;
                case REMANE:
                    TreeViewUtility.renameFileAndTreeItem(treeVievClient);
                    break;
                case DELETE:
                    TreeViewUtility.deleteObjectAndTreeItem(treeVievClient);
                    break;
                case SEARCH:
                    TreeViewUtility.searchObjectAndTreeItem(treeVievClient);
                    break;
            }
        }
    }
}

package dialog;



public class StaticAlert {
    public static void showAlertFileExists(){
        Alert alert = new Alert(Alert.AlertType.WARNING, "File exists!", ButtonType.OK);
        alert.setHeaderText("Operation could not be performed");
        alert.showAndWait();
    }

    public static Optional<String> getNewName(EnumOption typeInputDialog){
        TextInputDialog textInputDialog = new TextInputDialog("");
        textInputDialog.setTitle(typeInputDialog.getValue());
        textInputDialog.setHeaderText("Help: the rules for writing a name are defined by the file system");
        textInputDialog.setContentText("Please, enter new name:");
        return textInputDialog.showAndWait();
    }

    public static Optional<String> showSearchDialog(){
        TextInputDialog textInputDialog = new TextInputDialog("");
        textInputDialog.setTitle(EnumOption.SEARCH.getValue());
        textInputDialog.setHeaderText("Help: the rules for writing a name are defined by the file system");
        textInputDialog.setContentText("Please, enter the name of the file or directory you want to find: ");
        return textInputDialog.showAndWait();
    }

    public static String getStackTrace(Exception e){
        StringWriter stringWriter = new StringWriter();
        PrintWriter printWriter = new PrintWriter(stringWriter);
        e.printStackTrace(printWriter);
        return stringWriter.toString();
    }

    public static void showAlertError(Exception e){
        LoggerCloud.LOGGER.warning(e.getLocalizedMessage());
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle("Error");
        alert.setHeaderText(e.getMessage());

        VBox dialogPaneContent = new VBox();

        Label label = new Label("Stack Trace:");

        String stackTrace = getStackTrace(e);
        TextArea textArea = new TextArea();
        textArea.setText(stackTrace);

        dialogPaneContent.getChildren().addAll(label, textArea);
        alert.getDialogPane().setContent(dialogPaneContent);
        alert.showAndWait();
    }

    public static ButtonBar.ButtonData confirmOperation(){
        try {
            Alert alert = new Alert(Alert.AlertType.INFORMATION, "Р’С‹ РґРµР№СЃС‚РІРёС‚РµР»СЊРЅРѕ С…РѕС‚РёС‚Рµ РІС‹РїРѕР»РЅРёС‚СЊ СѓРґР°Р»РµРЅРёРµ?", ButtonType.YES, ButtonType.NO);
            alert.showAndWait();
            return alert.getResult().getButtonData();
        } catch (Exception e){
            return null;
        }
    }

    public static void showReport(String report){
        Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setHeaderText(null);
        alert.setTitle("Report");
        VBox dialogPaneContent = new VBox();
        TextArea textArea = new TextArea();
        textArea.setText(report);
        dialogPaneContent.getChildren().addAll(textArea);
        alert.getDialogPane().setContent(dialogPaneContent);
        alert.showAndWait();
    }
}
package logger;





/**
 * РљР»Р°СЃСЃ Logger. Р’ РїРµСЂСЃРїРµРєС‚РёРІРµ Р±СѓР¶РµС‚ Р·Р°РїРёСЃС‹РІР°С‚СЊ СЃС‚РµРєРё РѕС€РёР±РѕРє Рё РїСЂРѕС‡РёРµ СЃРёСЃС‚РµРјРЅС‹Рµ СЃРѕРѕР±С‰РµРЅРёСЏ.
 * */
@NoArgsConstructor
public final class LoggerCloud {

    public static final Logger LOGGER = Logger.getLogger("");
    {
        LOGGER.setLevel(Level.SEVERE);
        Handler handler = null;
        try {
            handler = new FileHandler("logSendMessage.log", 100000,1,true);
        } catch (IOException e) {
            e.printStackTrace();
        }
        handler.setLevel(Level.ALL);
        handler.setFormatter(new SimpleFormatter());
        LOGGER.addHandler(handler);
    }
}



public class Main extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception{
        Parent root = FXMLLoader.load(Objects.requireNonNull(getClass().getClassLoader().getResource("authorisationWindow.fxml")));
        primaryStage.setTitle("Cloud core authorization");
        primaryStage.setScene(new Scene(root, 300, 275));
        primaryStage.show();
    }


    public static void main(String[] args) {
        launch(args);
    }
//
//    public static void main(String[] args) throws InterruptedException {
//        NettyNetwork.getInstance().start();
//        Scanner sc = new Scanner(System.in);
//        while (sc.hasNext()){
//            if(sc.nextInt()==1){
//                NettyNetwork.getInstance().sendData("test", Paths.get("clientA/","1.txt"));
//            }
//            if(sc.nextInt()==2){
//                NettyNetwork.getInstance().loadData("test", Paths.get("2.txt"));
//            }
//        }
//    }
}
package model;

public enum EnumOption{
    RENAME("New name"),
    CREATEFILE("Create new file"),
    CREATECATALOG("Create new catalog"),
    SEARCH("Search file or catalog"),
    COPY(""),
    CUT("");

    private String value;

    EnumOption(String value){
        this.value = value;
    }

    public String getValue() {
        return value;
    }
}
package model;


public class ExtFile extends File{

        public ExtFile(String pathname) {
            super(pathname);
        }

        public ExtFile(File parent, String child) {
            super(parent, child);
        }

        @Override
        public String toString() {
            return getName().isEmpty() ? getPath() : getName();
        }
}
package model;

public enum MenuCommand {
    NEWFILE,
    NEWCATALOG,
    MOVE,
    REMANE,
    DELETE,
    SEARCH,
    COPY,
    CUT,
    PASTE
}
package model;


/**
 * РљР»Р°СЃСЃ РїРµСЂРµС‡РёСЃР»РёРјРѕРіРѕ С‚РёРїР° РёРЅРєР°РїСЃСѓР»РёСЂСѓРµС‚ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ РѕР±Р»Р°С‡РЅРѕРіРѕ С…СЂР°РЅРёР»РёС‰Р°
 * РќРµР»РµРЅРёРІС‹Р№ Singleton РїРѕ РјРЅРµРЅРёСЋ Joshua BlochвЂ™Р° СЌС‚Рѕ Р»СѓС‡С€РёР№ СЃРїРѕСЃРѕР± СЂРµР°Р»РёР·Р°С†РёРё С€Р°Р±Р»РѕРЅР°
 * */
public enum  User {

    SETTING();

    private String name;                    //Р»РѕРіРёРЅ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
package net;



public class NettyNetwork {
    private static NettyNetwork ourInstance = new NettyNetwork();

    public static NettyNetwork getInstance() {
        return ourInstance;
    }

    private NettyNetwork() {
        countDownLatch = new CountDownLatch(1);
    }

    private Channel currentChannel;
    private CountDownLatch countDownLatch;  //Р·Р°С‰РµР»РєР°, РєРѕС‚РѕСЂР°СЏ РѕР¶РёРґР°РµС‚ РЅР°СЃС‚СѓРїР»РµРЅРёСЏ СЃРѕР±С‹С‚РёСЏ СЃРѕРµРґРёРЅРµРЅРёСЏ СЃ СЃРµСЂРІРµСЂРѕРј.

    public Channel getCurrentChannel() {
        return currentChannel;
    }

    public void start() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                EventLoopGroup group = new NioEventLoopGroup();
                try {
                    Bootstrap clientBootstrap = new Bootstrap();
                    clientBootstrap.group(group);
                    clientBootstrap.channel(NioSocketChannel.class);
                    clientBootstrap.remoteAddress(new InetSocketAddress("localhost", 8189));
                    clientBootstrap.handler(new ChannelInitializer<SocketChannel>() {
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            PackageBody packageBody = new PackageBody();
                            socketChannel.pipeline()
                                    .addLast("command",new CommandHandler(packageBody))
                                    .addLast("lengthUserName",new ToIntegerDecoder(packageBody))
                                    .addLast("userName",new ByteToNameUserHandler(packageBody))
                                    .addLast("lengthFileName",new ToIntegerDecoder(packageBody))
                                    .addLast("fileName",new ByteToNameFileHandler(packageBody))
                                    .addLast("lengthFile",new ToLongDecoder(packageBody))
                                    .addLast("loadfile",new ByteToFileClientHandler(packageBody));
                            currentChannel = socketChannel;

                        }
                    });
                    ChannelFuture channelFuture = clientBootstrap.connect().sync();
                    countDownLatch.countDown();     //СЃРЅРёРјР°РµРј Р·Р°С‰РµР»РєСѓ, С‚.Рє. РїСЂРѕРёР·РѕС€Р»Рѕ СЃРѕР±С‹С‚РёРµ СЃРѕРµРґРёРЅРµРЅРёСЏ СЃ СЃРµСЂРІРµСЂРѕРј
                    channelFuture.channel().closeFuture().sync();
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    try {
                        group.shutdownGracefully().sync();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }

    public void loadData(String name, Path path){
        try {
            countDownLatch.await();  //РїСЂРѕРІРµСЂСЏРµРј РЅР°СЃС‚СѓРїРёР»Рѕ Р»Рё СЃРѕР±С‹С‚РёРµ СѓСЃРїРµС€РЅРѕРіРѕ СЃРѕРµРґРёРЅРµРЅРёСЏ СЃ СЃРµСЂРІРµСЂРѕРј
            Packages.loadFromServerToClient(currentChannel, new PackageTransport("test",path));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void sendData(String name, Path path) throws InterruptedException {
        try {
            countDownLatch.await();  //РїСЂРѕРІРµСЂСЏРµРј РЅР°СЃС‚СѓРїРёР»Рѕ Р»Рё СЃРѕР±С‹С‚РёРµ СѓСЃРїРµС€РЅРѕРіРѕ СЃРѕРµРґРёРЅРµРЅРёСЏ СЃ СЃРµСЂРІРµСЂРѕРј
            Packages.sendFromClienToServer(currentChannel, new PackageTransport("test",path));
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public boolean isConnectionOpened() {
        return currentChannel != null && currentChannel.isActive();
    }

    public void closeConnection() {
        currentChannel.close();
    }
}
package utility.file;


public class FileVisionDelete extends SimpleFileVisitor<Path> {

    private StringBuilder report = new StringBuilder();

    public FileVisitResult visitFile(Path path, BasicFileAttributes attrib) throws IOException {
        delete(path);
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
        delete(dir);
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
        report.append("Failed\t" + file.toString() + "\n");
        return FileVisitResult.CONTINUE;
    }

    private void delete(Path path){
        try{
            Files.delete(path);
            report.append("Success\t" + path.toString() + "\n");
        } catch (IOException e){
            report.append("Failed\t" + path.toString() + "\n");
            report.append(e.getMessage() + "\n");
        }
    }

    public StringBuilder getReport() {
        return report;
    }
    public void clear() {
        report.setLength(0);
    }
}
package utility.file;


public class FileVisionSearch extends SimpleFileVisitor<Path> {

    private String nameSearchObject;
    private StringBuilder report = new StringBuilder();

    public FileVisitResult visitFile(Path path, BasicFileAttributes attrib) throws IOException {
        if(path.getFileName().toString().indexOf(nameSearchObject)!=-1) report.append("Success\tfile\t" + path.toString() + "\n");
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
        if(dir.toAbsolutePath().toString().indexOf(nameSearchObject)!=-1) report.append("Success\tcatalog\t" + dir.toString() + "\n");
        return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
        return FileVisitResult.CONTINUE;
    }

    public StringBuilder getReport() {
        return report;
    }
    public void clear() {
        report.setLength(0);
        nameSearchObject = null;
    }

    public void setNameSearchObject(String nameSearchObject) {
        this.nameSearchObject = nameSearchObject;
    }
}
package utility;



public class TreeViewUtility {


    private static FileVisionDelete fileVision = new FileVisionDelete();
    private static FileVisionSearch fileSearch = new FileVisionSearch();
    private static Path bufferForMove = null;
    private static Path bufferForCopyAndCut = null;
    private static TreeItem<ExtFile> itemForCut;
    private static EnumOption option = null;

    public static <T> String getPathFromTreeItem(@NonNull TreeItem<T> item){
        if(item.getParent() == null) return "";
        return  (getPathFromTreeItem(item.getParent()).equals("") ? "" : getPathFromTreeItem(item.getParent()) + File.separator) + item.getValue().toString();
    }

    public static void  renameFileAndTreeItem(@NonNull TreeView<ExtFile> tree){
        TreeItem<ExtFile> selectedItem = tree.getSelectionModel().getSelectedItem();           //СЃСЃС‹Р»РєР° РЅР° РІС‹Р±СЂР°РЅРЅС‹Р№ СЌР»РµРјРµРЅС‚ РґРµСЂРµРІР°
        if(selectedItem != null){
            Path source = Paths.get(TreeViewUtility.getPathFromTreeItem(selectedItem));                                //РїРѕР»СѓС‡Р°РµРј РїРѕР»РЅС‹Р№ РїСѓС‚СЊ Рє РІС‹Р±СЂР°РЅРЅРѕРјСѓ СЌР»РµРјРµРЅС‚Сѓ
            Optional<String> res = StaticAlert.getNewName(EnumOption.RENAME);
            if(res.isPresent())
            {
                String newName = res.get();
                try {
                    Files.move(source, source.resolveSibling(newName));                           //РїРµСЂРµРёРјРµРЅРѕРІС‹РІР°РµРј СЌР»РµРјРµРЅС‚
                    TreeItem<ExtFile> objP = selectedItem.getParent();                                       //РѕРїСЂРµРґРµР»СЏРµРј СЂРѕРґРёС‚РµР»СЏ РІС‹Р±СЂР°РЅРЅРѕРіРѕ СЌР»РµРјРµРЅС‚Р°
                    ObservableList<TreeItem<ExtFile>> listChild = selectedItem.getChildren();                //РѕРїСЂРµРґРµР»СЏРµРј РґРµС‚РµР№ РІС‹Р±СЂР°РЅРЅРѕРіРѕ СЌР»РµРјРµРЅС‚Р°

                    Platform.runLater(() ->{
                        objP.getChildren().remove(selectedItem);                                             //СѓРґР°Р»СЏРµРј РІС‹Р±СЂР°РЅРЅС‹Р№ СЌР»РµРјРµРЅС‚
                        TreeItem<ExtFile> var = new TreeItem<>(new ExtFile(newName));     //СЃРѕР·РґР°РµРј СЌР»РµРјРµРЅС‚ СЃ РЅРѕРІС‹Рј РёРјРµРЅРµРј
                        var.getChildren().setAll(listChild);                                            //РїСЂРёРЅРёРјР°РµРј РІСЃРµС… РґРµС‚РµР№
                        objP.getChildren().add(var);                                                    //РїСЂРёРІСЏР·С‹РІР°РµРј СЂРѕРґРёС‚РµР»СЏ
                    });
                } catch (FileAlreadyExistsException e){
                    StaticAlert.showAlertFileExists();
                } catch (IOException e) {
                    StaticAlert.showAlertError(e);
                }
            }
        }
    }

    public static void copyFileAndTreeItem(@NonNull TreeView<ExtFile> tree){
        TreeItem<ExtFile> selectedItem = tree.getSelectionModel().getSelectedItem();           //СЃСЃС‹Р»РєР° РЅР° РІС‹Р±СЂР°РЅРЅС‹Р№ СЌР»РµРјРµРЅС‚ РґРµСЂРµРІР°
        if(selectedItem != null){
            bufferForCopyAndCut =  Paths.get(TreeViewUtility.getPathFromTreeItem(selectedItem));                                //РїРѕР»СѓС‡Р°РµРј РїРѕР»РЅС‹Р№ РїСѓС‚СЊ Рє РІС‹Р±СЂР°РЅРЅРѕРјСѓ СЌР»РµРјРµРЅС‚Сѓ
            option = EnumOption.COPY;
        }
    }

    public static void cutFileAndTreeItem(@NonNull TreeView<ExtFile> tree){
        TreeItem<ExtFile> selectedItem = tree.getSelectionModel().getSelectedItem();           //СЃСЃС‹Р»РєР° РЅР° РІС‹Р±СЂР°РЅРЅС‹Р№ СЌР»РµРјРµРЅС‚ РґРµСЂРµРІР°
        if(selectedItem != null){
            bufferForCopyAndCut =  Paths.get(TreeViewUtility.getPathFromTreeItem(selectedItem));                                //РїРѕР»СѓС‡Р°РµРј РїРѕР»РЅС‹Р№ РїСѓС‚СЊ Рє РІС‹Р±СЂР°РЅРЅРѕРјСѓ СЌР»РµРјРµРЅС‚Сѓ
            itemForCut = selectedItem;
            option = EnumOption.CUT;
        }
    }

    public static void moveFileAndTreeItem(@NonNull TreeView<ExtFile> tree){
        TreeItem<ExtFile> selectedItem = tree.getSelectionModel().getSelectedItem();           //СЃСЃС‹Р»РєР° РЅР° РІС‹Р±СЂР°РЅРЅС‹Р№ СЌР»РµРјРµРЅС‚ РґРµСЂРµРІР°
        if(selectedItem != null){
            bufferForMove =  Paths.get(TreeViewUtility.getPathFromTreeItem(selectedItem));                                //РїРѕР»СѓС‡Р°РµРј РїРѕР»РЅС‹Р№ РїСѓС‚СЊ Рє РІС‹Р±СЂР°РЅРЅРѕРјСѓ СЌР»РµРјРµРЅС‚Сѓ
        }
    }

    //РЅСѓР¶РЅРѕ РїРѕС‚РµСЃС‚РёС‚СЊ
    public static void pasteFileAndTreeItem(@NonNull TreeView<ExtFile> tree){
        TreeItem<ExtFile> selectedItem = tree.getSelectionModel().getSelectedItem();           //СЃСЃС‹Р»РєР° РЅР° РІС‹Р±СЂР°РЅРЅС‹Р№ СЌР»РµРјРµРЅС‚ РґРµСЂРµРІР°
        if(option == EnumOption.COPY && bufferForCopyAndCut !=null && selectedItem != null){
            TreeItem<ExtFile> parentForNewItemTree = getParentCatalog(selectedItem);
            if(parentForNewItemTree == null) return;
            try {
                Path copyToPath = Files.isDirectory(Paths.get(getPathFromTreeItem(selectedItem))) ? Paths.get(getPathFromTreeItem(selectedItem)) : Paths.get(getPathFromTreeItem(selectedItem)).getParent();
                Files.copy(bufferForCopyAndCut,copyToPath.resolve(bufferForCopyAndCut.getFileName()));
                String temp = bufferForCopyAndCut.getFileName().toString();
                Platform.runLater(() -> {
                    TreeItem<ExtFile> newTreeItem = new TreeItem<>(new ExtFile(temp));     //СЃРѕР·РґР°РµРј СЌР»РµРјРµРЅС‚ СЃ РЅРѕРІС‹Рј РёРјРµРЅРµРј
                    parentForNewItemTree.getChildren().add(newTreeItem);
                    tree.getSelectionModel().select(newTreeItem);
                });
            } catch (IOException e) {
                StaticAlert.showAlertError(e);
            } finally {
                bufferForCopyAndCut = null;
                option = null;
            }
        } else if(option == EnumOption.CUT && bufferForCopyAndCut !=null && selectedItem != null){
            TreeItem<ExtFile> parentForNewItemTree = getParentCatalog(selectedItem);
            if(parentForNewItemTree == null) return;
            try {
                Path copyToPath = Files.isDirectory(Paths.get(getPathFromTreeItem(selectedItem))) ? Paths.get(getPathFromTreeItem(selectedItem)) : Paths.get(getPathFromTreeItem(selectedItem)).getParent();
                Files.copy(bufferForCopyAndCut,copyToPath.resolve(bufferForCopyAndCut.getFileName()));
                String temp = bufferForCopyAndCut.getFileName().toString();
                Files.walkFileTree(bufferForCopyAndCut, fileVision);
                Platform.runLater(() -> {
                    TreeItem<ExtFile> newTreeItem = new TreeItem<>(new ExtFile(temp));     //СЃРѕР·РґР°РµРј СЌР»РµРјРµРЅС‚ СЃ РЅРѕРІС‹Рј РёРјРµРЅРµРј
                    parentForNewItemTree.getChildren().add(newTreeItem);
                    tree.getSelectionModel().select(newTreeItem);
                    if(itemForCut!=null)
                    {
                        itemForCut.getParent().getChildren().remove(itemForCut); //СѓРґР°Р»СЏРµРј РёР· РґРµСЂРµРІР° РІС‹СЂРµР·Р°РЅРЅС‹Р№ СЌР»РµРјРµРЅС‚
                        itemForCut = null;
                    }
                });
            } catch (IOException e) {
                StaticAlert.showAlertError(e);
            } finally {
                bufferForCopyAndCut = null;
                option = null;
                fileVision.clear();
            }
        }
    }

    public static void createNewFileAndTreeItem(@NonNull TreeView<ExtFile> tree){
        createNewObjectAndTreeItem(tree,EnumOption.CREATEFILE);
    }

    public static void createNewCatalogAndTreeItem(@NonNull TreeView<ExtFile> tree){
        createNewObjectAndTreeItem(tree,EnumOption.CREATECATALOG);
    }

    private static void createNewObjectAndTreeItem(@NonNull TreeView<ExtFile> tree, EnumOption option){
        TreeItem<ExtFile> selectedItem = tree.getSelectionModel().getSelectedItem();           //СЃСЃС‹Р»РєР° РЅР° РІС‹Р±СЂР°РЅРЅС‹Р№ СЌР»РµРјРµРЅС‚ РґРµСЂРµРІР°
        if(selectedItem != null){
            TreeItem<ExtFile> parentForNewItemTree = getParentCatalog(selectedItem);
            if(parentForNewItemTree == null) return;
            Optional<String> res = StaticAlert.getNewName(EnumOption.CREATEFILE);
            if(res.isPresent())
            {
                String newNameFile = res.get();
                String catalog = TreeViewUtility.getPathFromTreeItem(parentForNewItemTree);
                try {
                    if(option.equals(EnumOption.CREATEFILE))Files.createFile(Paths.get(catalog, newNameFile));
                    if(option.equals(EnumOption.CREATECATALOG))Files.createDirectory(Paths.get(catalog, newNameFile));
                    Platform.runLater(() -> {
                        TreeItem<ExtFile> newTreeItem = new TreeItem<>(new ExtFile(newNameFile));     //СЃРѕР·РґР°РµРј СЌР»РµРјРµРЅС‚ СЃ РЅРѕРІС‹Рј РёРјРµРЅРµРј
                        parentForNewItemTree.getChildren().add(newTreeItem);
                        tree.getSelectionModel().select(newTreeItem);
                    });
                } catch (FileAlreadyExistsException e){
                    StaticAlert.showAlertFileExists();
                } catch (IOException e) {
                    StaticAlert.showAlertError(e);
                }
            }
        }
    }

    public static void searchObjectAndTreeItem(@NonNull TreeView<ExtFile> tree){
        TreeItem<ExtFile> selectedItem = tree.getSelectionModel().getSelectedItem();           //СЃСЃС‹Р»РєР° РЅР° РІС‹Р±СЂР°РЅРЅС‹Р№ СЌР»РµРјРµРЅС‚ РґРµСЂРµРІР°
        String strPath = getPathFromTreeItem(selectedItem);
        if(selectedItem != null && Files.isDirectory(Paths.get(strPath))) {
            Optional<String> res = StaticAlert.showSearchDialog();
            if (res.isPresent()) {
                String nameSearchObject = res.get();
                fileSearch.setNameSearchObject(nameSearchObject);
                try {
                    Files.walkFileTree(Paths.get(strPath), fileSearch);
                } catch (IOException e) {
                    StaticAlert.showAlertError(e);
                } finally {
                    StaticAlert.showReport(fileSearch.getReport().toString());
                    fileSearch.clear();
                }
            }
        }
    }

    public static void deleteObjectAndTreeItem(@NonNull TreeView<ExtFile> tree){
        TreeItem<ExtFile> selectedItem = tree.getSelectionModel().getSelectedItem();           //СЃСЃС‹Р»РєР° РЅР° РІС‹Р±СЂР°РЅРЅС‹Р№ СЌР»РµРјРµРЅС‚ РґРµСЂРµРІР°
        if(selectedItem != null){


            if(StaticAlert.confirmOperation()== ButtonBar.ButtonData.NO) return;
            Path source = Paths.get(getPathFromTreeItem(selectedItem));
            try {
                Files.walkFileTree(source, fileVision);
                Platform.runLater(() -> {
                    selectedItem.getParent().getChildren().remove(selectedItem); //СѓРґР°Р»СЏРµРј РёР· РґРµСЂРµРІР° РІС‹СЂРµР·Р°РЅРЅС‹Р№ СЌР»РµРјРµРЅС‚
                });
            } catch (IOException e) {
                StaticAlert.showAlertError(e);
            } finally {
                StaticAlert.showReport(fileVision.getReport().toString());
                fileVision.clear();
            }
        }
    }

    private static TreeItem<ExtFile> getParentCatalog(@NonNull TreeItem<ExtFile> selectedItem){
        if(Files.isDirectory(Paths.get(getPathFromTreeItem(selectedItem)))){
            return selectedItem;
        } else {
            return selectedItem.getParent();
        }
    }

//    private static void deleteTreeItem(@NonNull Path path, @NonNull TreeView<ExtFile> tree){
//        ObservableList<TreeItem<ExtFile>> list = null;tree.
//        for (TreeItem<ExtFile> item:
//                tree.getRoot().getChildren()) {
//            if(item.getValue().getName().equals(path.getRoot())) {
//                list = item.getChildren();
//                break;
//            }
//        }
//        for (int i = 0; i < path.getNameCount() && list != null; i++) {
//            if(i == path.getNameCount() - 1){
//                for (TreeItem<ExtFile> item:
//                        list) {
//                    if(item.getValue().getName().equals(path.getName(i).toString())) {
//                        list.remove(item);
//                        return;
//                    }
//                }
//            } else{
//                ObservableList<TreeItem<ExtFile>> temp = null;
//                for (TreeItem<ExtFile> item:
//                        list) {
//                    if(item.getValue().getName().equals(path.getName(i).toString())) {
//                        temp = item.getChildren();
//                        break;
//                    }
//                }
//                list = temp;
//            }
//        }
//    }
}
package model;

/**
 * РљР»Р°СЃСЃ РїРѕР·РІРѕР»СЏРµС‚ РёР· РїРѕС‚РѕРєР° Р±Р°Р№С‚ РїРѕСЃС‚СЂРѕРёС‚СЊ РїР°РєРµС‚ РЅР° СЃС‚РѕСЂРѕРЅРµ СЃРµСЂРІРµСЂР° РёР»Рё РєР»РёРµРЅС‚Р°.
 *
 * @author Mishanin Aleksey
 * */
public class PackageBody {

    //РЅР°Р±РѕСЂ СЃРѕСЃС‚РѕСЏРЅРёР№ РѕРїСЂРµРґРµР»СЏСЋС‰РёС… Р»РѕРіРёРєСѓ СЃР»РµРґСѓСЋС‰РµРіРѕ С€Р°РіР° РїСЂРѕС‚РѕРєРѕР»Р°
    public enum Status{
        NONE,                   //РЅРµС‚ РєРѕРјР°РЅРґС‹
        READLENGTHUSER,         //С‡РёС‚Р°РµРј РґР»РёРЅСѓ РёРјРµРЅРё РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ
        READNAMEUSER,           //С‡РёС‚Р°РµРј РёРјСЏ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ
        READLENGTHNAMEFILE,     //С‡РёС‚Р°РµРј РґР»РёРЅСѓ РёРјРµРЅРё С„Р°Р№Р»Р°
        READNAMEFILE,           //С‡РёС‚Р°РµРј РёРјСЏ С„Р°Р№Р»Р°
        READLENGTHFILE,         //С‡РёС‚Р°РµРј РґР»РёРЅСѓ С„Р°Р№Р»Р°
        READFILE,               //С‡РёС‚Р°РµРј С„Р°Р№Р»
        WRITEFILE;              //Р·Р°РїРёСЃС‹РІР°РµРј С„Р°Р№Р»
    }

    private ProtocolCommand command;    //РєРѕРјР°РЅРґР° РїСЂРѕС‚РѕРєРѕР»Р°
    private Status status;              //СЃРѕСЃС‚РѕСЏРЅРёРµ РїСЂРѕС‚РѕРєРѕР»Р°
    private int lenghUserName;          //РґР»РёРЅР° РёРјРµРЅРё РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ
    private int lenghFileName;          //РґР»РёРЅР° РёРјРµРЅРё С„Р°Р№Р»Р°
    private long lenghFile;             //РґР»РёРЅР° С„Р°Р№Р»Р°
    private String nameUser;            //РёРјСЏ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ
    private String nameFile;            //РёРјСЏ С„Р°Р№Р»Р°

    @Override
    public String toString() {
        return command.toString() + "\n" +
                status.toString() + "\n" +
                lenghUserName + "\n" +
                lenghFileName + "\n" +
                lenghFile + "\n" +
                nameUser + "\n" +
                nameFile + "\n";
    }

    public PackageBody() {
        this.command = null;
        this.status = Status.NONE;
    }

    public ProtocolCommand getCommand() {
        return command;
    }

    public void setCommand(ProtocolCommand command) {

        this.command = command;
        this.status = Status.READLENGTHUSER;
    }


    public Status getStatus() {
        return status;
    }

    public void setStatus(Status status) {
        this.status = status;
    }

    public int getLenghUserName() {
        return lenghUserName;
    }

    public void setLenghUserName(int lenghUserName) {
        this.lenghUserName = lenghUserName;
    }

    public int getLenghFileName() {
        return lenghFileName;
    }

    public void setLenghFileName(int lenghFileName) {
        this.lenghFileName = lenghFileName;
    }

    public long getLenghFile() {
        return lenghFile;
    }

    public void setLenghFile(long lenghFile) {
        this.lenghFile = lenghFile;
    }

    public String getNameUser() {
        return nameUser;
    }

    public void setNameUser(String nameUser) {
        this.nameUser = nameUser;
    }

    public String getNameFile() {
        return nameFile;
    }

    public void setNameFile(String nameFile) {
        this.nameFile = nameFile;
    }

    /**
     * РњРµС‚РѕРґ РѕС‡РёС‰Р°РµС‚ РѕСЃРЅРѕРІРЅС‹Рµ РїРѕР»СЏ РєР»Р°СЃСЃР°.
     * */
    public void clear(){
        command = null;
        status = Status.NONE;
        lenghFile = lenghFileName = lenghUserName = 0;
        nameUser = null;
        nameFile = null;
    }
}
package model;


/**
 * РљР»Р°СЃСЃ РёРЅРєР°РїСЃСѓР»РёСЂСѓРµС‚ РѕР±Р»РµРіС‡РµРЅРЅС‹Р№ РїР°РєРµС‚ РґР°РЅРЅС‹С… РѕС‚РїСЂР°РІР»СЏРµРјС‹С… РЅР° СЃРµСЂРІРµСЂ
 * */
public class PackageTransport {

    private String user;            //РёРјСЏ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ
    private Path pathToFile;        //РїСѓС‚СЊ Рє С„Р°Р№Р»Сѓ

    public PackageTransport(String user, Path pathToFile) {
        this.user = user;
        this.pathToFile = pathToFile;
    }

    public String getUser() {
        return user;
    }

    public void setUser(String user) {
        this.user = user;
    }

    public Path getPathToFile() {
        return pathToFile;
    }

    public void setPathToFile(Path pathToFile) {
        this.pathToFile = pathToFile;
    }
}
package model;

/**
 * РџРµСЂРµС‡РёСЃР»РµРЅРёРµ РѕРїРёСЃС‹РІР°РµС‚ РѕСЃРЅРѕРІРЅС‹Рµ РєРѕРјР°РЅРґС‹ РґРѕСЃС‚СѓРїРЅС‹Рµ РґР»СЏ РёСЃРїРѕР»СЊР·РѕРІР°РЅРёСЏ РІ РїСЂРѕС‚РѕРєРѕР»Рµ
 *
 * @author Mishanin Aleksey
 * */
public enum ProtocolCommand {
    FILE((byte)1),              //РѕС‚РїСЂР°РІРєР° С„Р°Р№Р»Р° РЅР° СЃРµСЂРІРµСЂ
    FILEREQUEST((byte)2),       //Р·Р°РїСЂРѕСЃ С„Р°Р№Р»Р° Сѓ СЃРµСЂРІРµСЂР°
    FILERESPONSE((byte)3),      //РѕС‚РІРµС‚ СЃРµСЂРІРµСЂР° РєР»РёРµРЅС‚Сѓ. РЈСЃРїРµС€РЅР°СЏ РѕС‚РїСЂР°РІРєР° С„Р°Р№Р»Р° РѕС‚ СЃРµСЂРІРµСЂР° РєР»РёРµРЅС‚Сѓ
    FILEERROR((byte)4);         //СЃР±РѕР№ РїСЂРё РѕС‚РїСЂР°РІРєРµ С„Р°Р№Р»Р°

    ProtocolCommand(byte i){
        data = i;
    }

    private byte data;

    public byte getData() {
        return data;
    }

    /**
     * РЎС‚Р°С‚РёС‡РµСЃРєРёР№ РјРµС‚РѕРґ, РєРѕС‚РѕСЂС‹Р№ РїРѕР·РІРѕР»СЏРµС‚ РїРѕ Р·РЅР°С‡РµРЅРёСЋ Р±Р°Р№С‚Р° РїРѕР»СѓС‡РёС‚СЊ
     * РѕР±СЉРµРєС‚ С‚РёРїР° ProtocolCommand
     *
     * @param   value
     *          Р·РЅР°С‡РµРЅРёРµ Р±Р°Р№С‚Р°
     *
     * @return  РѕР±СЉРµРєС‚ ProtocolCommand СЃРѕРѕС‚РІРµС‚СЃС‚РІСѓСЋС‰РёР№ Р·РЅР°С‡РµРЅРёСЋ Р±Р°Р№С‚Р°
     * */
    public static ProtocolCommand getCommand(byte value){
        for (ProtocolCommand temp:
             ProtocolCommand.values()) {
            if(temp.data==value) return temp;
        }
        return null;
    }
}
package protocol;


/**
 * РђР±СЃС‚СЂР°РєС‚РЅС‹Р№ РєР»Р°СЃСЃ РЅР°СЃР»РµРґРЅРёРєР° ChannelHandler. РџРµСЂРµРѕРїСЂРµРґРµР»СЏРµС‚ РјРµС‚РѕРґ exceptionCaught
 * */
public abstract class AbstractHandler extends ChannelInboundHandlerAdapter {

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
package protocol;




/**
 * РљР»Р°СЃСЃ РёРЅРєР°РїСЃСѓР»РёСЂСѓРµС‚ С‡Р°СЃС‚СЊ РїСЂРѕС‚РѕРєРѕР»Р°, РѕС‚РІРµС‡Р°СЋС‰СѓСЋ Р·Р° Р·Р°РіСЂСѓР·РєСѓ С„Р°Р№Р»Р° РЅР° Р»РѕРєР°Р»СЊРЅСѓСЋ РјР°С€РёРЅСѓ РєР»РёРµРЅС‚Р°.
 *
 * @author Mishanin Aleksey
 * */
public class ByteToFileClientHandler extends AbstractHandler {

    private PackageBody packageBody;
	private byte[] bufArr;

    public ByteToFileClientHandler() {
        this.packageBody = packageBody;
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        //РµСЃР»Рё РїР°РєРµС‚ СЃРѕРґРµСЂР¶РёС‚ РЅСѓР¶РЅСѓСЋ РєРѕРјР°РЅРґСѓ Рё СЃС‚Р°С‚СѓСЃ
        if(packageBody.getCommand() ==  ProtocolCommand.FILERESPONSE &&
                packageBody.getStatus() == PackageBody.Status.READFILE) {
            //РїСЂРµРѕР±СЂР°Р·СѓРµРј Object Рє ByteBuf
            ByteBuf buf = ((ByteBuf) msg);
            //System.out.println(7);
            //РµСЃР»Рё РІ Р±СѓС„РµСЂРµ РµСЃС‚СЊ РґР°РЅРЅС‹Рµ РґР»СЏ С‡С‚РµРЅРёСЏ
            while (buf.isReadable()){
                //СЃС‡РёС‚С‹РІР°РµРј РґР°РЅРЅС‹Рµ РІРѕ РІСЂРµРјРµРЅРЅС‹Р№ Р±СѓС„РµСЂ
                buf.readBytes(bufArr);
                //Р·Р°РїРёСЃС‹РІР°РµРј Р±Р°Р№С‚С‹ РІ С„Р°Р№Р»
                Files.write(Paths.get("clientA/", packageBody.getNameFile()), data, CREATE, APPEND);
                //СѓРјРµРЅСЊС€Р°РµРј РґР»РёРЅСѓ С„Р°Р№Р»Р° РІ РїР°РєРµС‚Рµ
                packageBody.setLenghFile(packageBody.getLenghFile()-j);
                //РѕСЃРІРѕР±РѕР¶РґР°РµРј СЃРѕРѕР±С‰РµРЅРёРµ
                ReferenceCountUtil.release(msg);
            }
            //РµСЃР»Рё РЅРµ РѕСЃС‚Р°Р»РѕСЃСЊ Р±Р°Р№С‚ РґР»СЏ Р·Р°РїРёСЃРё
            if (packageBody.getLenghFile() <= 0) {
                //System.out.println(8);
                //РѕС‡РёС‰Р°РµРј СЂР°РєРµС‚
                packageBody.clear();
            }
        } else {
            //РѕС‚РїСЂР°РІР»СЏРµРј СЃРѕРѕР±С‰РµРЅРёРµ Рє СЃР»РµРґСѓСЋС‰РµРјСѓ ChannelHandler
            ctx.fireChannelRead(msg);
        }
    }
}
package protocol;




/**
 * РљР»Р°СЃСЃ РёРЅРєР°РїСЃСѓР»РёСЂСѓРµС‚ С‡Р°СЃС‚СЊ РїСЂРѕС‚РѕРєРѕР»Р°, РѕС‚РІРµС‡Р°СЋС‰СѓСЋ Р·Р° Р·Р°РіСЂСѓР·РєСѓ С„Р°Р№Р»Р° РЅР° СЃРµСЂРІРµСЂ.
 *
 * @author Mishanin Aleksey
 * */
public class ByteToFileServerHandler extends AbstractHandler{

    private PackageBody packageBody;

    public ByteToFileServerHandler(PackageBody packageBody) {
        this.packageBody = packageBody;
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        //РµСЃР»Рё РїР°РєРµС‚ СЃРѕРґРµСЂР¶РёС‚ РЅСѓР¶РЅСѓСЋ РєРѕРјР°РЅРґСѓ Рё СЃС‚Р°С‚СѓСЃ
        if(packageBody.getCommand() == ProtocolCommand.FILE &&
                packageBody.getStatus() == PackageBody.Status.READFILE) {
            //РїСЂРµРѕР±СЂР°Р·СѓРµРј Object Рє ByteBuf
            ByteBuf buf = ((ByteBuf) msg);
            //System.out.println(7);
            //РµСЃР»Рё РІ Р±СѓС„РµСЂРµ РµСЃС‚СЊ РґР°РЅРЅС‹Рµ РґР»СЏ С‡С‚РµРЅРёСЏ
            while (buf.isReadable()){
                //РѕРїСЂРµРґРµР»СЏРµРј РєРѕР»-РІРѕ РґРѕСЃС‚СѓРїРЅС‹С… РґР»СЏ С‡С‚РµРЅРёСЏ Р±Р°Р№С‚
                int j = buf.readableBytes();
                //СЃРѕР·РґР°РµРј РІСЂРµРјРµРЅРЅС‹Р№ Р±СѓС„РµСЂ РїРѕРґ Р±Р°Р№С‚С‹
                byte[] data= new byte[j];
                //СЃС‡РёС‚С‹РІР°РµРј РґР°РЅРЅС‹Рµ РІРѕ РІСЂРµРјРµРЅРЅС‹Р№ Р±СѓС„РµСЂ
                buf.readBytes(data);
                //Р·Р°РїРёСЃС‹РІР°РµРј Р±Р°Р№С‚С‹ РІ С„Р°Р№Р»
                Files.write(Paths.get("serverA/", packageBody.getNameUser() + "/", packageBody.getNameFile()), data, CREATE, APPEND);
                //СѓРјРµРЅСЊС€Р°РµРј РґР»РёРЅСѓ С„Р°Р№Р»Р° РІ РїР°РєРµС‚Рµ
                packageBody.setLenghFile(packageBody.getLenghFile()-j);
                //РѕСЃРІРѕР±РѕР¶РґР°РµРј СЃРѕРѕР±С‰РµРЅРёРµ
                ReferenceCountUtil.release(msg);
            }
            //РµСЃР»Рё РЅРµ РѕСЃС‚Р°Р»РѕСЃСЊ Р±Р°Р№С‚ РґР»СЏ Р·Р°РїРёСЃРё
            if (packageBody.getLenghFile() <= 0) {
                System.out.println(8);
                //РѕС‡РёС‰Р°РµРј СЂР°РєРµС‚
                packageBody.clear();
            }
        } else {
            ctx.fireChannelRead(msg);
        }
    }
}
package protocol;


/**
 * РљР»Р°СЃСЃ РёРЅРєР°РїСЃСѓР»РёСЂСѓРµС‚ С‡Р°СЃС‚СЊ РїСЂРѕС‚РѕРєРѕР»Р°, РѕС‚РІРµС‡Р°СЋС‰СѓСЋ Р·Р° С‡С‚РµРЅРёРµ РёРјРµРЅРё С„Р°Р№Р»Р°.
 *
 * @author Mishanin Aleksey
 * */
public class ByteToNameFileHandler extends AbstractHandler {

    private PackageBody packageBody;

    public ByteToNameFileHandler(PackageBody packageBody) {
        this.packageBody = packageBody;
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        //РµСЃР»Рё РїР°РєРµС‚ СЃРѕРґРµСЂР¶РёС‚ РЅСѓР¶РЅСѓСЋ РєРѕРјР°РЅРґСѓ Рё СЃС‚Р°С‚СѓСЃ
        if((packageBody.getCommand() != ProtocolCommand.FILEERROR ||
                packageBody.getCommand() != null) &&
                packageBody.getStatus() == PackageBody.Status.READNAMEFILE) {
            //РїСЂРµРѕР±СЂР°Р·СѓРµРј Object Рє ByteBuf
            ByteBuf buf = ((ByteBuf) msg);
            //РµСЃР»Рё РєРѕР»-РІРѕ Р±Р°Р№С‚ РґРѕСЃС‚СѓРїРЅС‹С… РґР»СЏ С‡С‚РµРЅРёСЏ РјРµРЅСЊС€Рµ РґР»РёРЅС‹ РёРјРµРЅРё С„Р°Р№Р»Р°
            if (buf.readableBytes() < packageBody.getLenghFileName()) {
                //РїСЂРµРєСЂР°С‰Р°РµРј РѕР±СЂР°Р±РѕС‚РєСѓ
                return;
            }
            //СЃРѕР·РґР°РµРј РІСЂРµРјРµРЅРЅС‹Р№ Р±СѓС„РµСЂ РїРѕРґ РёРјСЏ С„Р°Р№Р»Р°
            byte[] data = new byte[packageBody.getLenghFileName()];
            //С‡РёС‚Р°РµРј РёРјСЏ С„Р°Р№Р»Р° РІРѕ РІСЂРµРјРµРЅРЅС‹Р№ Р±СѓС„РµСЂ
            buf.readBytes(data);
            //РІ РїР°РєРµС‚Рµ РїСЂРёСЃРІР°РёРІР°РµРј РЅРѕРІРѕРµ РёРјСЏ С„Р°Р№Р»Р°
            packageBody.setNameFile(new String(data));
            //РµСЃР»Рё РєРѕРјР°РЅРґР° РІ РїР°РєРµС‚Рµ: Р·Р°РіСЂСѓР·РєР° С„Р°Р№Р»Р° РЅР° СЃРµСЂРІРµСЂ РёР»Рё Р·Р°РіСЂСѓР·РєР° С„Р°Р№Р»Р° РЅР° РјР°С€РёРЅСѓ РєР»РёРµРЅС‚Р°
            if(packageBody.getCommand() == ProtocolCommand.FILE ||
                    packageBody.getCommand() == ProtocolCommand.FILERESPONSE){
                //РїСЂРёСЃРІР°РёРІР°РµРј СЃС‚Р°С‚СѓСЃ: С‡С‚РµРЅРёРµ РґР»РёРЅС‹ С„Р°Р№Р»Р°
                packageBody.setStatus(PackageBody.Status.READLENGTHFILE);
            }
            //РµСЃР»Рё РєРѕРјР°РЅРґР° РІ РїР°РєРµС‚Рµ: Р·Р°РїСЂРѕСЃ С„Р°Р№Р»Р° РЅР° СЃРµСЂРІРµСЂРµ РґР»СЏ СЃРєР°С‡РёРІР°РЅРёСЏ
            if(packageBody.getCommand() == ProtocolCommand.FILEREQUEST){
                //РїСЂРёСЃРІР°РёРІР°РµРј СЃС‚Р°С‚СѓСЃ: СЃРєР°С‡Р°С‚СЊ С„Р°Р№Р»
                packageBody.setStatus(PackageBody.Status.WRITEFILE);
            }
            //System.out.println(5);
        }
        //РѕС‚РїСЂР°РІР»СЏРµРј СЃРѕРѕР±С‰РµРЅРёРµ Рє СЃР»РµРґСѓСЋС‰РµРјСѓ ChannelHandler
        ctx.fireChannelRead(msg);
    }
}
package protocol;


/**
 * РљР»Р°СЃСЃ РёРЅРєР°РїСЃСѓР»РёСЂСѓРµС‚ С‡Р°СЃС‚СЊ РїСЂРѕС‚РѕРєРѕР»Р°, РѕС‚РІРµС‡Р°СЋС‰СѓСЋ Р·Р° С‡С‚РµРЅРёРµ РёРјРµРЅРё РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ.
 *
 * @author Mishanin Aleksey
 * */
public class ByteToNameUserHandler extends AbstractHandler {

    private PackageBody packageBody;

    public ByteToNameUserHandler(PackageBody packageBody) {
        this.packageBody = packageBody;
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        //РµСЃР»Рё РїР°РєРµС‚ СЃРѕРґРµСЂР¶РёС‚ РЅСѓР¶РЅСѓСЋ РєРѕРјР°РЅРґСѓ Рё СЃС‚Р°С‚СѓСЃ
        if((packageBody.getCommand() != ProtocolCommand.FILEERROR ||
                packageBody.getCommand() != null) &&
                packageBody.getStatus() == PackageBody.Status.READNAMEUSER) {
            //РїСЂРµРѕР±СЂР°Р·СѓРµРј Object Рє ByteBuf
            ByteBuf buf = ((ByteBuf) msg);
            //РµСЃР»Рё РєРѕР»-РІРѕ Р±Р°Р№С‚ РґРѕСЃС‚СѓРїРЅС‹С… РґР»СЏ С‡С‚РµРЅРёСЏ РјРµРЅСЊС€Рµ РґР»РёРЅС‹ РёРјРµРЅРё С„Р°Р№Р»Р°
            if (buf.readableBytes() < packageBody.getLenghUserName()) {
                //РїСЂРµРєСЂР°С‰Р°РµРј РѕР±СЂР°Р±РѕС‚РєСѓ
                return;
            }
            //СЃРѕР·РґР°РµРј РІСЂРµРјРµРЅРЅС‹Р№ Р±СѓС„РµСЂ РїРѕРґ РёРјСЏ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ
            byte[] data = new byte[packageBody.getLenghUserName()];
            //С‡РёС‚Р°РµРј РёРјСЏ С„Р°Р№Р»Р° РІРѕ РІСЂРµРјРµРЅРЅС‹Р№ Р±СѓС„РµСЂ
            buf.readBytes(data);
            //РІ РїР°РєРµС‚Рµ РїСЂРёСЃРІР°РёРІР°РµРј РЅРѕРІРѕРµ РёРјСЏ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ
            packageBody.setNameUser(new String(data));
            //РїСЂРёСЃРІР°РёРІР°РµРј СЃС‚Р°С‚СѓСЃ: С‡С‚РµРЅРёРµ РґР»РёРЅС‹ РёРјРµРЅРё С„Р°Р№Р»Р°
            packageBody.setStatus(PackageBody.Status.READLENGTHNAMEFILE);
            //System.out.println(3);
        }
        //РѕС‚РїСЂР°РІР»СЏРµРј СЃРѕРѕР±С‰РµРЅРёРµ Рє СЃР»РµРґСѓСЋС‰РµРјСѓ ChannelHandler
        ctx.fireChannelRead(msg);
    }
}
package protocol;


/**
 * РљР»Р°СЃСЃ РёРЅРєР°РїСЃСѓР»РёСЂСѓРµС‚ С‡Р°СЃС‚СЊ РїСЂРѕС‚РѕРєРѕР»Р°, РѕС‚РІРµС‡Р°СЋС‰СѓСЋ Р·Р° С‡С‚РµРЅРёРµ РєРѕРјР°РЅРґС‹.
 *
 * @author Mishanin Aleksey
 * */
public class CommandHandler extends AbstractHandler {

    private PackageBody packageBody;

    public CommandHandler(PackageBody packageBody) {
        this.packageBody = packageBody;
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        //РµСЃР»Рё РїР°РєРµС‚ РЅРµ СЃРѕРґРµСЂР¶РёС‚ РєРѕРјР°РЅРґС‹ РёР»Рё СЃРѕРґРµСЂР¶РёС‚ РѕС€РёР±РєСѓ
        if((packageBody.getCommand() == ProtocolCommand.FILEERROR ||
                packageBody.getCommand() == null) &&
                packageBody.getStatus() == PackageBody.Status.NONE){
            //РїСЂРµРѕР±СЂР°Р·СѓРµРј Object Рє ByteBuf
            ByteBuf buf = ((ByteBuf) msg);
            //РїСЂРµРѕР±СЂР°Р·СѓРµРј ByteBuf РІ byte
            byte firstByte = buf.readByte();
            //РЅР° РѕСЃРЅРѕРІР°РЅРёРё Р·РЅР°С‡РµРЅРёСЏ Р±Р°Р№С‚Р° РѕРїСЂРµРґРµР»СЏРµРј ProtocolCommand
            packageBody.setCommand(ProtocolCommand.getCommand(firstByte));
            //System.out.println(1);
        }
        //РѕС‚РїСЂР°РІР»СЏРµРј СЃРѕРѕР±С‰РµРЅРёРµ Рє СЃР»РµРґСѓСЋС‰РµРјСѓ ChannelHandler
        ctx.fireChannelRead(msg);
    }
}
package protocol;



/**
 * РљР»Р°СЃСЃ РёРЅРєР°РїСЃСѓР»РёСЂСѓРµС‚ С‡Р°СЃС‚СЊ РїСЂРѕС‚РѕРєРѕР»Р°, РѕС‚РІРµС‡Р°СЋС‰СѓСЋ Р·Р°РїРёСЃСЊ С„Р°Р№Р»Р° РІ РєР°РЅР°Р» СЃРѕ СЃС‚РѕСЂРѕРЅС‹ СЃРµСЂРІРµСЂР°.
 *
 * @author Mishanin Aleksey
 * */
public class FileToByteHandler extends AbstractHandler{

    private PackageBody packageBody;

    public FileToByteHandler(PackageBody packageBody) {
        this.packageBody = packageBody;
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        //РµСЃР»Рё РїР°РєРµС‚ СЃРѕРґРµСЂР¶РёС‚ РЅСѓР¶РЅСѓСЋ РєРѕРјР°РЅРґСѓ Рё СЃС‚Р°С‚СѓСЃ
        if((packageBody.getCommand() == ProtocolCommand.FILEREQUEST) &&
                packageBody.getStatus() == PackageBody.Status.WRITEFILE) {
            //System.out.println(9);
            //РІС‹Р·С‹РІР°РµРј СЃС‚Р°С‚РёС‡РµСЃРєРёР№ РјРµС‚РѕРґ СѓС‚РёР»РёС‚С‹ РґР»СЏ РѕРїС‚Р°РІРєРё С„Р°Р№Р»Р° РєР»РёРµРЅС‚Сѓ
            Packages.sendFromServerToClient(ctx.channel(),new PackageTransport(packageBody.getNameUser(), Paths.get("serverA/", packageBody.getNameUser() + "/", packageBody.getNameFile())));
            //РѕСЃРІРѕР±РѕР¶РґР°РµРј СЃРѕРѕР±С‰РµРЅРёРµ
            ReferenceCountUtil.release(msg);
            //РѕС‡РёС‰Р°РµРј РїР°РєРµС‚
            packageBody.clear();
        } else {
            //РїРµСЂРµСЃС‹Р»Р°РµРј СЃРѕРѕР±РґРµРЅРёРµ СЃР»РµРґСѓСЋС‰РµРјСѓ ChannelHandler
            ctx.fireChannelRead(msg);
        }
    }
}
package protocol;


/**
 * РљР»Р°СЃСЃ РёРЅРєР°РїСЃСѓР»РёСЂСѓРµС‚ С‡Р°СЃС‚СЊ РїСЂРѕС‚РѕРєРѕР»Р°, РѕС‚РІРµС‡Р°СЋС‰СѓСЋ Р·Р° С‡С‚РµРЅРёРµ РґР»РёРЅС‹ РёРјРµРЅРё С„Р°Р№Р»Р° РёР»Рё РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ.
 *
 * @author Mishanin Aleksey
 * */
public class ToIntegerDecoder extends AbstractHandler {

    private PackageBody packageBody;

    public ToIntegerDecoder(PackageBody packageBody) {
        this.packageBody = packageBody;
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        //РїСЂРµРѕР±СЂР°Р·СѓРµРј Object Рє ByteBuf
        ByteBuf buf = (ByteBuf)msg;
        //РµСЃР»Рё РїР°РєРµС‚ СЃРѕРґРµСЂР¶РёС‚ РЅСѓР¶РЅСѓСЋ РєРѕРјР°РЅРґСѓ Рё СЃС‚Р°С‚СѓСЃ
        if((packageBody.getCommand() != ProtocolCommand.FILEERROR ||
                packageBody.getCommand() !=null) &&
                packageBody.getStatus() == PackageBody.Status.READLENGTHUSER) {
            //РµСЃР»Рё РґР»СЏ С‡С‚РµРЅРёСЏ РґРѕСЃС‚СѓРїРЅРѕ РјРµРЅРµРµ 4-С… Р±Р°Р№С‚
            if (buf.readableBytes() < 4) {
                //РїСЂРµРєСЂР°С‰Р°РµРј РѕР±Р°СЂР±РѕС‚РєСѓ
                return;
            }
            //Р·Р°РїРёСЃС‹РІР°РµРј int РІ РїРѕР»Рµ РґР»РёРЅС‹ РёРјРµРЅРё РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ
            packageBody.setLenghUserName(buf.readInt());
            //РїСЂРёСЃРІР°РёРІР°РµРј РїР°РєРµС‚Сѓ СЃС‚Р°С‚СѓСЃ: С‡С‚РµРЅРёРµ РёРјРµРЅРё РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ
            packageBody.setStatus(PackageBody.Status.READNAMEUSER);
            //System.out.println(2);

            //РµСЃР»Рё РїР°РєРµС‚ СЃРѕРґРµСЂР¶РёС‚ РЅСѓР¶РЅСѓСЋ РєРѕРјР°РЅРґСѓ Рё СЃС‚Р°С‚СѓСЃ
        } else if((packageBody.getCommand() != ProtocolCommand.FILEERROR ||
                packageBody.getCommand() != null) &&
                packageBody.getStatus() == PackageBody.Status.READLENGTHNAMEFILE) {
            //РµСЃР»Рё РґР»СЏ С‡С‚РµРЅРёСЏ РґРѕСЃС‚СѓРїРЅРѕ РјРµРЅРµРµ 4-С… Р±Р°Р№С‚
            if (buf.readableBytes() < 4) {
                //РїСЂРµРєСЂР°С‰Р°РµРј РѕР±Р°СЂР±РѕС‚РєСѓ
                return;
            }
            //Р·Р°РїРёСЃС‹РІР°РµРј int РІ РїРѕР»Рµ РґР»РёРЅС‹ РёРјРµРЅРё С„Р°Р№Р»Р°
            packageBody.setLenghFileName(buf.readInt());
            //РїСЂРёСЃРІР°РёРІР°РµРј РїР°РєРµС‚Сѓ СЃС‚Р°С‚СѓСЃ: С‡С‚РµРЅРёРµ РёРјРµРЅРё С„Р°Р№Р»Р°
            packageBody.setStatus(PackageBody.Status.READNAMEFILE);
            //System.out.println(4);
        }
        //РїРµСЂРµСЃС‹Р»Р°РµРј СЃРѕРѕР±С‰РµРЅРёРµ СЃР»РµРґСѓСЋС‰РµРјСѓ ChannelHandler
        ctx.fireChannelRead(msg);
    }
}
package protocol;


/**
 * РљР»Р°СЃСЃ РёРЅРєР°РїСЃСѓР»РёСЂСѓРµС‚ С‡Р°СЃС‚СЊ РїСЂРѕС‚РѕРєРѕР»Р°, РѕС‚РІРµС‡Р°СЋС‰СѓСЋ Р·Р° С‡С‚РµРЅРёРµ РґР»РёРЅС‹ С„Р°Р№Р»Р°.
 *
 * @author Mishanin Aleksey
 * */
public class ToLongDecoder extends AbstractHandler {

    private PackageBody packageBody;

    public ToLongDecoder(PackageBody packageBody) {
        this.packageBody = packageBody;
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        //РїСЂРµРѕР±СЂР°Р·СѓРµРј Object Рє ByteBuf
        ByteBuf buf = (ByteBuf)msg;
        //РµСЃР»Рё РїР°РєРµС‚ СЃРѕРґРµСЂР¶РёС‚ РЅСѓР¶РЅСѓСЋ РєРѕРјР°РЅРґСѓ Рё СЃС‚Р°С‚СѓСЃ
        if((packageBody.getCommand() == ProtocolCommand.FILE ||
                packageBody.getCommand() == ProtocolCommand.FILERESPONSE) &&
                packageBody.getStatus() == PackageBody.Status.READLENGTHFILE) {
            //РµСЃР»Рё РґР»СЏ С‡С‚РµРЅРёСЏ РґРѕСЃС‚СѓРїРЅРѕ РјРµРЅРµРµ 8-Рё Р±Р°Р№С‚
            if (buf.readableBytes() < 8) {
                //РїСЂРµРєСЂР°С‰Р°РµРј РѕР±Р°СЂР±РѕС‚РєСѓ
                return;
            }
            //Р·Р°РїРёСЃС‹РІР°РµРј long РІ РїРѕР»Рµ РґР»РёРЅС‹ С„Р°Р№Р»Р°
            packageBody.setLenghFile(buf.readLong());
            //РїСЂРёСЃРІР°РёРІР°РµРј РїР°РєРµС‚Сѓ СЃС‚Р°С‚СѓСЃ: С‡С‚РµРЅРёРµ С„Р°Р№Р»Р°
            packageBody.setStatus(PackageBody.Status.READFILE);
            //System.out.println(6);
        }
        //РїРµСЂРµСЃС‹Р»Р°РµРј СЃРѕРѕР±С‰РµРЅРёРµ СЃР»РµРґСѓСЋС‰РµРјСѓ ChannelHandler
        ctx.fireChannelRead(msg);
    }
}
package utility;



/**
 * РљР»Р°СЃСЃ СЃРѕРґРµСЂР¶РёС‚ СЂСЏРґ РіРѕС‚РѕРІС‹С… РёРЅСЃС‚СѓРјРµРЅС‚РѕРІ РґР»СЏ РѕС‚РїСЂР°РІРєРё/Р·Р°РіСЂСѓР·РєРё С„Р°Р№Р»РѕРІ
 *
 * @author Mishanin Aleksey
 * */
public class Packages {

    /**
     * РЎС‚Р°С‚РёС‡РµСЃРєРёР№ РјРµС‚РѕРґ РѕС‚РїСЂР°РІРєРё С„Р°Р№Р»Р° РѕС‚ РєР»РёРµРЅС‚Р° РЅР° СЃРµСЂРІРµСЂ
     *
     * @param   channel
     *          РєР°РЅР°Р» РґР»СЏ РѕС‚РїСЂР°РІРєРё Р±Р°Р№С‚
     *
     * @param   pack
     *          РѕР±Р»РµРіС‡РµРЅРЅС‹Р№ РІР°СЂРёР°РЅС‚ РїР°РєРµС‚Р° СЃ РґР°РЅРЅС‹РјРё
     * */
    public static void sendFromClienToServer(Channel channel, PackageTransport pack) throws IOException, InterruptedException {
        send(channel,pack,"server");
    }

    /**
     * РЎС‚Р°С‚РёС‡РµСЃРєРёР№ РјРµС‚РѕРґ РѕС‚РїСЂР°РІРєРё С„Р°Р№Р»Р° РѕС‚ СЃРµСЂРІРµСЂР° РЅР° РєР»РёРµРЅС‚Р°
     *
     * @param   channel
     *          РєР°РЅР°Р» РґР»СЏ РѕС‚РїСЂР°РІРєРё Р±Р°Р№С‚
     *
     * @param   pack
     *          РѕР±Р»РµРіС‡РµРЅРЅС‹Р№ РІР°СЂРёР°РЅС‚ РїР°РєРµС‚Р° СЃ РґР°РЅРЅС‹РјРё
     * */
    public static void sendFromServerToClient(Channel channel, PackageTransport pack) throws IOException, InterruptedException {
        send(channel,pack,"client");
    }

    /**
     * РЎР»СѓР¶РµР±РЅС‹Р№ РјРµС‚РѕРґ РѕС‚РїСЂР°РІРєРё С„Р°Р№Р»Р°
     *
     * @param   channel
     *          РєР°РЅР°Р» РґР»СЏ РѕС‚РїСЂР°РІРєРё Р±Р°Р№С‚
     *
     * @param   pack
     *          РѕР±Р»РµРіС‡РµРЅРЅС‹Р№ РІР°СЂРёР°РЅС‚ РїР°РєРµС‚Р° СЃ РґР°РЅРЅС‹РјРё
     *
     * @param   to
     *          РїСЂРёР·РЅР°Рє РѕРїСЂРµРґРµР»СЏРµС‚ СЃС‚РѕСЂРѕРЅСѓ РґР»СЏ РѕС‚РїСЂР°РІРєРё РґР°РЅРЅС‹С…: РёР»Рё server, РёР»Рё client
     * */
    private static void send(Channel channel, PackageTransport pack, String to) throws InterruptedException, FileNotFoundException, IOException {

        //РёСЃС…РѕРґСЏ РёР· Р·РЅР°С‡РµРЅРёСЏ Р°СЂРіСѓРјРµРЅС‚Р° "to" РѕРїСЂРµРґРµР»СЏРµРј РєРѕРјР°РЅРґСѓ РїСЂРѕС‚РѕРєРѕР»Р°
        byte command = to.equals("server") ? ProtocolCommand.FILE.getData() : to.equals("client") ? ProtocolCommand.FILERESPONSE.getData() : ProtocolCommand.FILEERROR.getData();
        //РїРѕР»СѓС‡Р°РµРј ByteBufAllocator РёР· РєР°РЅР°Р»Р°
        ByteBufAllocator allocator = channel.alloc();
        //РІРѕР·РІСЂР°С‰Р°РµРј Р±СѓС„РµСЂ СЂР°Р·РјРµСЂРЅРѕСЃС‚СЊСЋ 512 Р±Р°Р№С‚. Р—Р°РїРёСЃС‹РІР°РµРј РІ Р±СѓС„РµСЂ РєРѕРјР°РЅРґСѓ РїСЂРѕС‚РѕРєРѕР»Р°
        ByteBuf buf = allocator.buffer(512).writeByte(command);

        if(to.equals("server") || to.equals("client")){
            //РѕС‚РїСЂР°РІР»СЏРµРј Р±Р°Р№С‚С‹ РїРѕ РєР°РЅР°Р»Сѓ, СѓРІРµР»РёС‡РёРІР°РµРј СЃС‡РµС‚С‡РёРє СЃСЃС‹Р»РѕРє РЅР° Р±СѓС„РµСЂ РЅР° 1. РќР°РІРµС€РёРІР°РµРј РѕР±СЂР°Р±РѕС‚С‡РёРє СѓСЃРїРµС€РЅРѕР№ РѕС‚РїСЂР°РІРєРё Р±Р°Р№С‚: СЃР±СЂРѕСЃРёС‚СЊ РІ Р±СѓС„РµСЂРµ СѓРєР°Р·Р°С‚РµР»Рё С‡С‚РµРЅРёСЏ/Р·Р°РїРёСЃРё; Р·Р°РїРёСЃР°С‚СЊ РІ Р±СѓС„РµСЂ РґР»РёРЅСѓ РёРјРµРЅРё РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ. РџРѕРґРѕР¶РґР°С‚СЊ РѕС‚РїСЂР°РІРєРё РІСЃРµС… Р±Р°Р№С‚.
            channel.writeAndFlush(buf.retain()).addListener((n)->{buf.clear(); buf.writeInt(pack.getUser().getBytes().length);}).await();
            //РѕС‚РїСЂР°РІР»СЏРµРј Р±Р°Р№С‚С‹ РїРѕ РєР°РЅР°Р»Сѓ, СѓРІРµР»РёС‡РёРІР°РµРј СЃС‡РµС‚С‡РёРє СЃСЃС‹Р»РѕРє РЅР° Р±СѓС„РµСЂ РЅР° 1. РќР°РІРµС€РёРІР°РµРј РѕР±СЂР°Р±РѕС‚С‡РёРє СѓСЃРїРµС€РЅРѕР№ РѕС‚РїСЂР°РІРєРё Р±Р°Р№С‚: СЃР±СЂРѕСЃРёС‚СЊ РІ Р±СѓС„РµСЂРµ СѓРєР°Р·Р°С‚РµР»Рё С‡С‚РµРЅРёСЏ/Р·Р°РїРёСЃРё; Р·Р°РїРёСЃР°С‚СЊ РІ Р±СѓС„РµСЂ РёРјСЏ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ. РџРѕРґРѕР¶РґР°С‚СЊ РѕС‚РїСЂР°РІРєРё РІСЃРµС… Р±Р°Р№С‚.
            channel.writeAndFlush(buf.retain()).addListener((n)->{buf.clear(); buf.writeBytes(pack.getUser().getBytes());}).await();
            //РѕС‚РїСЂР°РІР»СЏРµРј Р±Р°Р№С‚С‹ РїРѕ РєР°РЅР°Р»Сѓ, СѓРІРµР»РёС‡РёРІР°РµРј СЃС‡РµС‚С‡РёРє СЃСЃС‹Р»РѕРє РЅР° Р±СѓС„РµСЂ РЅР° 1. РќР°РІРµС€РёРІР°РµРј РѕР±СЂР°Р±РѕС‚С‡РёРє СѓСЃРїРµС€РЅРѕР№ РѕС‚РїСЂР°РІРєРё Р±Р°Р№С‚: СЃР±СЂРѕСЃРёС‚СЊ РІ Р±СѓС„РµСЂРµ СѓРєР°Р·Р°С‚РµР»Рё С‡С‚РµРЅРёСЏ/Р·Р°РїРёСЃРё; Р·Р°РїРёСЃР°С‚СЊ РІ Р±СѓС„РµСЂ РґР»РёРЅСѓ РёРјРµРЅРё С„Р°Р№Р»Р°. РџРѕРґРѕР¶РґР°С‚СЊ РѕС‚РїСЂР°РІРєРё РІСЃРµС… Р±Р°Р№С‚.
            channel.writeAndFlush(buf.retain()).addListener((n)->{buf.clear(); buf.writeInt(pack.getPathToFile().getFileName().toString().length());}).await();
            //РѕС‚РїСЂР°РІР»СЏРµРј Р±Р°Р№С‚С‹ РїРѕ РєР°РЅР°Р»Сѓ, СѓРІРµР»РёС‡РёРІР°РµРј СЃС‡РµС‚С‡РёРє СЃСЃС‹Р»РѕРє РЅР° Р±СѓС„РµСЂ РЅР° 1. РќР°РІРµС€РёРІР°РµРј РѕР±СЂР°Р±РѕС‚С‡РёРє СѓСЃРїРµС€РЅРѕР№ РѕС‚РїСЂР°РІРєРё Р±Р°Р№С‚: СЃР±СЂРѕСЃРёС‚СЊ РІ Р±СѓС„РµСЂРµ СѓРєР°Р·Р°С‚РµР»Рё С‡С‚РµРЅРёСЏ/Р·Р°РїРёСЃРё; Р·Р°РїРёСЃР°С‚СЊ РІ Р±СѓС„РµСЂ РёРјСЏ С„Р°Р№Р»Р°. РџРѕРґРѕР¶РґР°С‚СЊ РѕС‚РїСЂР°РІРєРё РІСЃРµС… Р±Р°Р№С‚.
            channel.writeAndFlush(buf.retain()).addListener((n)->{buf.clear(); buf.writeBytes(pack.getPathToFile().getFileName().toString().getBytes());}).await();
            //РѕС‚РїСЂР°РІР»СЏРµРј Р±Р°Р№С‚С‹ РїРѕ РєР°РЅР°Р»Сѓ, СѓРІРµР»РёС‡РёРІР°РµРј СЃС‡РµС‚С‡РёРє СЃСЃС‹Р»РѕРє РЅР° Р±СѓС„РµСЂ РЅР° 1. РџРѕРґРѕР¶РґР°С‚СЊ РѕС‚РїСЂР°РІРєРё РІСЃРµС… Р±Р°Р№С‚.
            channel.writeAndFlush(buf.retain()).await();
            buf.clear();

            //РѕС‚РєСЂС‹РІР°РµРј Р±Р°Р№С‚РѕРІС‹Р№ РїРѕС‚РѕРє РґР»СЏ С„Р°Р№Р»Р°
            try (FileInputStream in = new FileInputStream(pack.getPathToFile().toFile());)
            {
                //С‡РёС‚Р°РµРј РґР»РёРЅСѓ С„Р°Р№Р»Р°
                long len = Files.size(pack.getPathToFile());
                //Р·Р°РїРёСЃС‹РІР°РµРј РґР»РёРЅСѓ С„Р°Р№Р»Р° РІ ByteBuf
                buf.writeLong(len);
                //РѕС‚РїСЂР°РІР»СЏРµРј РґР»РёРЅСѓ С„Р°Р№Р»Р° РІ РєР°РЅР°Р», СѓРІРµР»РёС‡РёРІР°РµРј СЃС‡РµС‚С‡РёРє СЃСЃС‹Р»РѕРє РЅР° 1, Р¶РґРµРј РѕС‚РїСЂР°РІРєРё РІСЃРµС… Р±Р°Р№С‚
                channel.writeAndFlush(buf.retain()).await();
                buf.clear();

                //РЎРѕР·РґР°РµРј РЅРѕРІС‹Р№ DefaultFileRegion РґР»СЏ С„Р°Р№Р»Р°, РЅР°С‡РёРЅР°СЏ СЃ 0 Рё Р·Р°РєР°РЅС‡РёРІР°СЏ РІ РєРѕРЅС†Рµ С„Р°Р№Р»Р°
                FileRegion region = new DefaultFileRegion(in.getChannel(), 0, pack.getPathToFile().toFile().length());
                //Р·Р°Р»РёРІР°РµРј РІ РєР°РЅР°Р» Р±Р°Р№С‚С‹ СЃРѕРґРµСЂР¶РёРјРѕРіРѕ С„Р°Р№Р»Р°
                channel.writeAndFlush(region).await();
            }
        }

    }

    /**
     * РЎС‚Р°С‚РёС‡РµСЃРєРёР№ РјРµС‚РѕРґ РѕС‚РїСЂР°РІРєРё Р·Р°РїСЂРѕСЃР° РЅР° СЃРµСЂРІРµСЂ РґР»СЏ СЃРєР°С‡РёРІР°РЅРёСЏ С„Р°Р№Р»Р°
     *
     * @param   channel
     *          РєР°РЅР°Р» РґР»СЏ РѕС‚РїСЂР°РІРєРё Р±Р°Р№С‚
     *
     * @param   pack
     *          РѕР±Р»РµРіС‡РµРЅРЅС‹Р№ РІР°СЂРёР°РЅС‚ РїР°РєРµС‚Р° СЃ РґР°РЅРЅС‹РјРё
     * */
    public static void loadFromServerToClient(Channel channel, PackageTransport pack) throws InterruptedException {

        byte command = ProtocolCommand.FILEREQUEST.getData();
        ByteBufAllocator allocator = channel.alloc();
        ByteBuf buf = allocator.buffer(512).writeByte(command);
        channel.writeAndFlush(buf.retain()).addListener((n)->{buf.clear(); buf.writeInt(pack.getUser().getBytes().length);}).await();
        channel.writeAndFlush(buf.retain()).addListener((n)->{buf.clear(); buf.writeBytes(pack.getUser().getBytes());}).await();
        channel.writeAndFlush(buf.retain()).addListener((n)->{buf.clear(); buf.writeInt(pack.getPathToFile().getFileName().toString().length());}).await();
        channel.writeAndFlush(buf.retain()).addListener((n)->{buf.clear(); buf.writeBytes(pack.getPathToFile().getFileName().toString().getBytes());}).await();
        channel.writeAndFlush(buf.retain()).await();
        buf.clear();
    }
}
package db;



public class AuthService extends DB_mysql{

    private static AuthService authService = new AuthService();
    private Statement statement = null;

    private AuthService(){
        setURL("localhost", "test", 3306);
        connect("test", "test");
        connect();
    }

    public static AuthService getInstance(){ return authService;}

    public void connect() {
        try {
            statement = getConnection().createStatement();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public boolean verifyLoginAndPass(@NonNull String login, @NonNull String pass){
        String sql = String.format("SELECT id FROM test.users WHERE login =\"%s\" AND password = %d",login,Integer.parseInt(pass));
        try {
            ResultSet rs = statement.executeQuery(sql);
            return rs.next();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

//    public String getNickByLoginAndPass(String login, String password) {
//        String sql = String.format("SELECT nick, password FROM chat.user WHERE login ='%s'", login);
//        int passHash = password.hashCode();
//        ResultSet res = null;
//        try {
//            res = statement.executeQuery(sql);
//            if(res.next()){
//                String nick = res.getString(1);
//                int passBd = res.getInt(2);
//                if(passHash==passBd) return nick;
//            }
//        } catch (SQLException e) {
//            e.printStackTrace();
//        }
//        return null;
//    }

}
package db;

//Р±Р°Р·РѕРІС‹Р№ РєР»Р°СЃСЃ РјРѕРґСѓР»СЏ РґРѕСЃС‚СѓРїР° Рє Р‘Р”


public abstract class DB_base {

    protected String driver = null;         //РґСЂР°Р№РІРµСЂ
    protected String url = null;            //СЃС‚СЂРѕРєР° РїРѕРґРєР»СЋС‡РµРЅРёСЏ
    protected Properties properties = null; //СЃРІРѕР№СЃС‚РІР° РїРѕРґРєР»СЋС‡РµРЅРёСЏ

    public DB_base(String driver){
        this.driver=driver;
    }

    //СЂРµРіРёСЃС‚СЂР°С†РёСЏ РґСЂР°Р№РІРµСЂР°
    protected void registerDriveManager(){
        try{
            Class.forName(driver).newInstance();
        }catch (Exception e){ e.printStackTrace();}
    }

    //РѕРїСЂРµРґРµР»РµРЅРёРµ СЃС‚СЂРѕРєРё РїРѕРґРєР»СЋС‡РµРЅРёСЏ
    public abstract void setURL (String host, String database, int port);

    //РїРѕР»СѓС‡РµРЅРёРµ РѕР±СЉРµРєС‚Р° РїРѕРґРєР»СЋС‡РµРЅРёСЏ
    public abstract Connection getConnection();

    //СЂРµРіРёСЃС‚СЂР°С†РёСЏ РґСЂР°Р№РІРµСЂР° РїРѕРґРєР»СЋС‡РµРЅРёСЏ Рє СЃРµСЂРІРµСЂСѓ Р‘Р” Рё РѕРїСЂРµРґРµР»РµРЅРёРµ СЃРІРѕР№СЃС‚РІ
    public void connect(String login, String password){

        registerDriveManager();
        properties = new Properties();
        properties.setProperty("password", password);
        properties.setProperty("user", login);
        properties.setProperty("useUnicode", "true");
        properties.setProperty("characterEncoding", "utf8");

    }

    //РѕС‚РєР»СЋС‡РµРЅРёРµ РѕС‚ СЃРµСЂРІРµСЂР° Р‘Р”
    public void disconnect(Connection connection){
        try{
            connection.close();
            connection=null;
        }catch (SQLException e) {
            System.err.println("SQLException: code = " + String.valueOf(e.getErrorCode()+ e.getMessage()));
        }
    }

    //С„СѓРЅРєС†РёСЏ РІС‹РїРѕР»РЅРµРЅРёРµСЏ sql-Р·Р°РїСЂРѕСЃР°
    public boolean execSQL(final String sql){
        boolean result = false;
        try{
            if(getConnection()!=null){
                Statement statement = getConnection().createStatement();
                statement.execute(sql);
                statement.close();
                statement=null;
                result=true;
            }
        } catch (SQLException e){
            System.err.println("SQLException: code = " + String.valueOf(e.getErrorCode()+ e.getMessage()));
            System.err.println("SQL: " + sql);
        }
        return result;
    }
}

package db;


public class DB_mysql extends DB_base{

    private com.mysql.jdbc.Connection connection = null;

    public DB_mysql(){
        super("com.mysql.jdbc.Driver");
    }

    @Override
    public void setURL(String host, String database, int port){
        if(database.length()>0){
            this.url = "jdbc:mysql://" + host + ":" + port + "/" + database;
        } else {
            this.url = "jdbc:mysql://" + host + ":" + port;
        }
    }

    @Override
    public Connection getConnection(){
        return connection;
    }

    @Override
    public void connect (String login, String password){
        super.connect(login, password);
        try{
            connection = (com.mysql.jdbc.Connection)DriverManager.getConnection(url,properties);
        } catch (SQLException e){
            System.err.println("SQLException: code = " + String.valueOf(e.getErrorCode()+ e.getMessage()));
        }
    }
}

package server;


/*
РџСЂРѕРµРєС‚ РЅРµ РґРѕРґРµР»Р°РЅ. РќРµ РґРѕРґРµР»Р°РЅРѕ РєР°Рє GUI-РѕРєРѕС€РєРѕ, С‚Р°Рє Рё СЂР°Р±РѕС‚Р° СЃ СЃРµС‚СЊСЋ.
Р¤Р°РєС‚РёС‡РµСЃРєРё РїСЂРѕС‚РµСЃС‚РёСЂРѕРІР°Р» СЃРІРѕР№ РІР°СЂРёР°РЅС‚ СЂР°Р±РѕС‚С‹ СЃ СЃРµС‚СЊСЋ. Р¤Р°Р№Р»С‹ СѓСЃРїРµС€РЅРѕ Р·Р°РіСЂСѓР¶Р°Р»РёСЃСЊ РЅР° СЃРµСЂРІРµСЂ, СЂР°РІРЅРѕ РєР°Рє Рё СЃРєР°С‡РёРІР°Р»РёСЃСЊ (Р±РµР· РёСЃРїРѕР»СЊР·РѕРІР°РЅРёСЏ Р‘Р”). Р’ РЅР°СЃС‚РѕСЏС‰РµРµ РІСЂРµРјСЏ СЂРµС€Р°СЋ РІРѕРїСЂРѕСЃ СЃ Р‘Р”. Р—Р° РјР°Р№СЃРєРёРµ РїСЂР°Р·РЅРёРєРё РґСѓРјР°СЋ СЂР°Р·Р±РµСЂСѓСЃСЊ.
Р”Р»СЏ СЃРїСЂР°РІРєРё, С‡С‚РѕР±С‹ РїРѕРЅРёРјР°С‚СЊ РєР°РєРёРµ РєР»Р°СЃСЃС‹ РІ РїСЂРѕРµРєС‚Рµ Р·Р°С‚СЂР°РіРёРІР°СЋС‚ СЂР°Р±РѕС‚Сѓ СЃ СЃРµС‚СЊСЋ:
РІ РјРѕРґСѓР»Рµ client:
1. РєР»Р°СЃСЃ NettyNetwork. РќР°РіР»Рѕ СЃРїРёРѕРЅРµСЂРёР» Р’Р°С€ РІР°СЂРёР°РЅС‚ СЃ СѓСЂРѕРєР°, РїСЂРё СЌС‚РѕРј РЅРµРјРЅРѕРіРѕ РµРіРѕ РїРµСЂРµРґРµР»Р°Р». NettyNetwork - С‡РёСЃС‚С‹Р№ РєР»РёРµРЅС‚ РЅР° netty. Р’ pipeline РЅР°РїРёС…Р°Р» РЅРµРјРЅРѕРіРѕ ChannelHandler, РєРѕС‚РѕСЂС‹Рµ РІ СЃРѕРІРѕРєСѓРїРЅРѕСЃС‚Рё РїСЂРµРґСЃС‚Р°РІР»СЏСЋС‚ РёР· СЃРµР±СЏ РїСЂРѕС‚РѕРєРѕР». Р›РѕРіРёРєР° СЃР»РµРґСѓСЋС‰Р°СЏ: РІРЅР°С‡Р°Р»Рµ РѕС‚РїСЂР°РІР»СЏРµС‚СЃСЏ 1 Р±Р°Р№С‚ СЃ РєРѕРјР°РЅРґРѕР№, РґР°Р»РµРµ 4 Р±Р°Р№С‚Р° СЃ РґР»РёРЅРѕР№ РёРјРµРЅРё РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ, РґР°Р»РµРµ РёРјСЏ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ, РґР°Р»РµРµ РґР»РёРЅР° РёРјРµРЅРё С„Р°Р№Р»Р°, РґР°Р»РµРµ РёРјСЏ С„Р°Р№Р»Р°, РґР°Р»РµРµ 8 Р±Р°Р№С‚ СЃ РґР»РёРЅРѕР№ С„Р°Р№Р»Р° Рё РІ Р·Р°РІРµСЂС€РµРЅРёРµ СЃР°Рј С„Р°Р№Р». РўР°РєР¶Рµ РІ NettyNetwork РґРѕР±Р°РІРёР» Р·Р°С‰РµР»РєСѓ CountDownLatch, РєРѕС‚РѕСЂР°СЏ СЃРЅРёРјР°РµС‚СЃСЏ РїСЂРё СѓСЃР»РѕРІРёРё СѓСЃРїРµС€РЅРѕРіРѕ СЃРѕРµРґРёРЅРµРЅРёСЏ СЃ СЃРµСЂРІРµСЂРѕРј, РїСЂРµРґРѕС‚РІСЂР°С‰Р°СЏ РІРѕР·РјРѕР¶РЅРѕСЃС‚СЊ РѕС‚РїСЂР°РІРєРё Р·Р°РїСЂРѕСЃР° РЅР° Р·Р°РіСЂСѓР·РєСѓ РёР»Рё СЃРєР°С‡РёРІР°РЅРёРµ С„Р°Р№Р»Р° РїСЂРё СѓСЃР»РѕРІРёРё РѕС‚СЃСѓС‚СЃС‚РІРёРё СЃРѕРµРґРёРЅРµРЅРёСЏ.
РІ РјРѕРґСѓР»Рµ common:
СЃРѕР·РґР°Р» С‚СЂРё РїР°РєРµС‚Р°: model, protocol, utility. Р’ РїР°РєРµС‚Рµ model СЃРѕРґРµСЂР¶РёС‚СЃСЏ РєР»Р°СЃСЃ PackageBody, РєРѕС‚РѕСЂС‹Р№ РїСЂРµРґСЃС‚Р°РІР»СЏРµС‚ РёР· СЃРµР±СЏ РїР°РєРµС‚ СЃРѕР±РёСЂР°РµРјС‹Р№ РёР· Р±Р°Р№С‚ РїРѕР»СѓС‡Р°РµРјС‹С… РёР· СЃРµС‚Рё. РљР»Р°СЃСЃ ProtocolCommand СЃРѕРґРµСЂР¶РёС‚ РІРѕР·РјРѕР¶РЅС‹Рµ РєРѕРјР°РЅРґС‹. РљР»Р°СЃСЃ PackageTransport СЃРѕРґРµСЂР¶РёС‚ РѕР±Р»РµРіС‡РµРЅРЅС‹Р№ РІР°СЂРёР°РЅС‚ РїР°РєРµС‚Р°, РѕС‚РїСЂР°РІР»СЏРµРјС‹Р№ РѕС‚ РєР»РёРµРЅС‚Р° РЅР° СЃРµСЂРІРµСЂ. Р’ РїР°РєРµС‚Рµ protocol СЃРѕРґРµСЂР¶РёС‚СЃСЏ СЂСЏРґ РєР»Р°СЃСЃРѕРІ РїСЂРѕРёР·РІРѕРґРЅС‹С… РѕС‚ ChannelInboundHandlerAdapter, РєРѕС‚РѕСЂС‹Рµ РІ СЃРѕРІРѕРєСѓРїРЅРѕСЃС‚Рё РїСЂРµРґСЃС‚Р°РІР»СЏСЋС‚ РїСЂРѕС‚РѕРєРѕР». Р’ РєР°Р¶РґРѕРј РєР»Р°СЃСЃРµ РѕРїРёСЃР°Р» СЂР°Р±РѕС‚Сѓ РІС‹РїРѕР»РЅСЏРµРјСѓСЋ РґР°РЅРЅС‹Рј РєР»Р°СЃСЃРѕРј. Р’ РїР°РєРµС‚Рµ utility СЃРѕРґРµСЂР¶РёС‚СЃСЏ РєР»Р°СЃСЃ Packages, РєРѕС‚РѕСЂС‹Р№ СЃРѕРґРµСЂР¶РёС‚ СЂСЏРґ СЃС‚Р°С‚РёС‡РµСЃРєРёС… РјРµС‚РѕРґРѕРІ РёСЃРїРѕР»СЊР·СѓРµРјС‹С… РґР»СЏ РѕС‚РїСЂР°РІРєРё С„Р°Р№Р»Р° РёР»Рё РѕС‚ РєР»РёРµРЅС‚Р° РЅР° СЃРµСЂРІРµСЂ, РѕС‚ СЃРµСЂРІРµСЂР° РЅР° РєР»РёРµРЅС‚Р° (РїРµСЂРµРґ РѕС‚РїСЂР°РІРєРѕР№ С„Р°Р№Р»Р° РІ СЃРµС‚СЊ, РѕС‚РїСЂР°РІР»СЏРµС‚СЃСЏ Р·Р°РіРѕР»РѕРІРѕРє: РєРѕРјР°РЅРґР°, РґР»РёРЅР° РёРјРµРЅРё РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ, РёРјСЏ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ, РґР»РёРЅР° РёРјРµРЅРё С„Р°Р№Р»Р°, РёРјСЏ С„Р°Р№Р»Р°, РґР»РёРЅР° С„Р°Р№Р»Р°, Рё РїРѕСЃР»Рµ СЃР°Рј С„Р°Р№Р».
РІ РјРѕРґСѓР»Рµ server:
СЃРѕР·РґР°Р» РїР°РєРµС‚ server, РєРѕС‚РѕСЂС‹Р№ СЃРѕРґРµСЂР¶РёС‚ СЃС‚Р°РЅРґР°СЂС‚РЅС‹Р№ СЃРµСЂРІРµСЂ netty. РџР»Р°РЅРёСЂСѓСЋ РґРѕР±Р°РІРёС‚СЊ РїСѓР» СЃРѕРµРґРёРЅРµРЅРёР№. Р Р°С‚СЂРёР±СѓС‚ РІ channel СЃ id РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ. РўР°РєР¶Рµ СЃРѕР·РґР°Р» РїР°РєРµС‚ db РІ РєРѕС‚РѕСЂРѕРј С‚РѕР»СЊРєРѕ РЅР°С‡Р°Р» СЃРѕР·РґР°РІР°С‚СЊ РєР»Р°СЃСЃС‹ РґР»СЏ СЂР°Р±РѕС‚С‹ СЃ Р‘Р” MySQL.

РџРѕРєР° С‡С‚Рѕ РЅР° СЌС‚РѕРј РІСЃРµ.
*/

public class ServerNetty {

    public void run() throws Exception{
        EventLoopGroup mainGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try{
            ServerBootstrap startSetting = new ServerBootstrap();
            startSetting.group(mainGroup,workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            PackageBody packageBody = new PackageBody();
                            socketChannel.pipeline()
                                    .addLast("command",new CommandHandler(packageBody))
                                    .addLast("lengthUserName",new ToIntegerDecoder(packageBody))
                                    .addLast("userName",new ByteToNameUserHandler(packageBody))
                                    .addLast("lengthFileName",new ToIntegerDecoder(packageBody))
                                    .addLast("fileName",new ByteToNameFileHandler(packageBody))
                                    .addLast("lengthFile",new ToLongDecoder(packageBody))
                                    .addLast("loadfile",new ByteToFileServerHandler(packageBody))
                                    .addLast("sendfile", new FileToByteHandler(packageBody));
                        }
                    })
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture future = startSetting.bind(8189).sync();
            future.channel().closeFuture().sync();
        } finally {
            mainGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        ServerNetty server = new ServerNetty();
        server.run();
    }
}
=================  =======================
========================================
Project name: CloudStorage

public class Main extends Application {
    @Override
    public void start(Stage primaryStage) throws Exception{
        Parent root = FXMLLoader.load(getClass().getResource("/main.fxml"));
        primaryStage.setTitle("Cloud Client");
        primaryStage.setScene(new Scene(root, 800, 600));
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}


public class MainController implements Initializable {

    private NetService net = new NetService();

    @FXML
    VBox authPanel;

    @FXML
    HBox workPanel;

    @FXML
    TextArea mainTextArea;

    @FXML
    TextField loginField;

    @FXML
    PasswordField passwordField;

    @FXML
    Label authStatus;

    @Override
    public void initialize(URL location, ResourceBundle resources) {
        net.init();
        Thread readThread = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    while (true) {
                        Message message = net.readObject();
                        if (message instanceof FileTransferMessage) {

                        }
                        if (message instanceof CommandMessage) {
                            CommandMessage commandMessage = (CommandMessage) message;
                            processComand(commandMessage);
                        }
                    }
                } catch (ClassNotFoundException | IOException e) {
                    e.printStackTrace();
                } finally {
                    net.stop();
                }
            }
        });
        readThread.setDaemon(true);
        readThread.start();
    }

    //РѕР±СЂР°Р±Р°С‚С‹РІР°РµС‚ РєРѕРјР°РЅРґС‹
    private void processComand(CommandMessage message) {
        if (message.getCommand() == Command.AUTH) {
            passwordField.clear();
            String args = message.getArguments();
            if (args.equals("ok")) {
                authPanel.setVisible(false);
                authPanel.setManaged(false);
                workPanel.setVisible(true);
                workPanel.setManaged(true);
            } else {
//                authStatus.setText("Wrong password");
//                Platform.runLater(new Runnable() {
//                    @Override
//                    public void run() {
//                        authStatus.setText("Wrong password");
//                        try {
//                            Thread.sleep(3000);
//                        } catch (InterruptedException e) {
//                            e.printStackTrace();
//                        }
//                        authStatus.setText("");
//                    }
//                });
//                statusThread.setDaemon(true);
//                statusThread.start();
            }
        }
    }

    public void signIn(ActionEvent actionEvent) {
        //authStatus.setText("");
        net.signIn(loginField.getText(), passwordField.getText());
//        loginField.clear();
//        passwordField.clear();
//        if (isAuth) {
//            authPanel.setVisible(false);
//            authPanel.setManaged(false);
//            workPanel.setVisible(true);
//            workPanel.setManaged(true);
//        }
    }

    public void clientUpload(ActionEvent actionEvent) {
        String fileName = "C:\\1.txt";
        net.sendCommand(Command.START_TRANSFER, fileName);
        net.sendFile(fileName);
    }


    public void serverUpload(ActionEvent actionEvent) {

    }

    public void clientRefresh(ActionEvent actionEvent) {
    }

    public void clientDelete(ActionEvent actionEvent) {
    }

    public void servertRefresh(ActionEvent actionEvent) {
    }

    public void serverDelete(ActionEvent actionEvent) {
    }
}


//try {
//        Socket socket = new Socket("localhost", 9999);
//        FileInputStream fileInputStream = new FileInputStream("C:\\1.txt");
//        DataOutputStream dataOutputStream = new DataOutputStream(socket.getOutputStream());
//        int count;
//        byte[] buffer = new byte[4096];
//        while ((count = fileInputStream.read(buffer)) > 0) {
//        dataOutputStream.write(buffer, 0, count);
//        }
//        } catch (IOException e) {
//        e.printStackTrace();
//        }


//try {
//        Socket socket = new Socket("localhost", 9999);
//        FileInputStream fileInputStream = new FileInputStream("C:\\1.txt");
//        ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());
//        int count;
//        byte[] buffer = new byte[4096];
//        while ((count = fileInputStream.read(buffer)) > 0) {
//        FileTransferMessage packet = new FileTransferMessage(buffer, "C:\\1.txt");
//        objectOutputStream.writeObject(packet);
//        }
//        } catch (IOException e) {
//        e.printStackTrace();
//        }


public class NetService {

    private Socket socket;
    private ObjectEncoderOutputStream out;
    private ObjectDecoderInputStream in;

    public void init() {
        try {
            socket = new Socket("localhost", 9999);
            out = new ObjectEncoderOutputStream(socket.getOutputStream());
            in = new ObjectDecoderInputStream(socket.getInputStream(), 100 * 1024* 1024);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void stop() {
        try {
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            in.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public Message readObject() throws ClassNotFoundException, IOException {
        Object obj = in.readObject();
        return (Message) obj;
    }

    //СЂР°Р·Р±РёРІР°РµС‚ С„Р°Р№Р» РЅР° С‡Р°СЃС‚Рё Рё РѕС‚РїСЂР°РІР»СЏРµС‚ РµРіРѕ РІ out
    public boolean sendFile(String fileName) {
        try {
            FileInputStream fileInputStream = new FileInputStream(fileName);
            int count;
            byte[] buffer = new byte[FileTransferMessage.MAX_BUFFER_LENGTH];
            while ((count = fileInputStream.read(buffer)) > 0) {
                out.writeObject(new FileTransferMessage(buffer, fileName, count));
            }
            return true;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return false;
    }

    //РѕС‚РїСЂР°РІР»СЏРµС‚ РєРѕРјР°РЅРґСѓ
    public boolean sendCommand(Command command, String fileName) {
        try {
            out.writeObject(new CommandMessage(command, fileName));
            return true;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return false;
    }

    //РѕС‚РїСЂР°РІР»СЏРµС‚ Р·Р°РїСЂРѕСЃ РЅР° Р°РІС‚РѕСЂРёР·Р°С†РёСЋ, РІРѕР·РІСЂР°С‰Р°РµС‚ СЂРµР·СѓР»СЊС‚Р°С‚ РїСЂРѕРІРµСЂРєРё
    public void signIn(String login, String password) {
        if (socket == null || socket.isClosed()) {
            init();
        }
        try {
            out.writeObject(new AuthMessage(login, password));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
package ru.nemtsov.messages;


public class AnswerMessage implements Message, Serializable {

    private boolean answer;

    public AnswerMessage(boolean answer) {
        this.answer = answer;
    }

    public boolean getAnswer() {
        return answer;
    }

}
package ru.nemtsov.messages;


public class AuthMessage implements Message, Serializable {

    private String login;
    private String password;

    public AuthMessage(String login, String password) {
        this.login = login;
        this.password = password;
    }

    public String getLogin() {
        return login;
    }

    public String getPassword() {
        return password;
    }
}
package ru.nemtsov.messages;

public enum Command {

    AUTH,
    REFRESH,
    START_TRANSFER;

}
package ru.nemtsov.messages;


public class CommandMessage implements Message, Serializable {

    private Command command;
    private String arguments;

    public CommandMessage(Command command, String arguments) {
        this.command = command;
        this.arguments = arguments;
    }

    public Command getCommand() {
        return command;
    }

    public String getArguments() {
        return arguments;
    }
}
package ru.nemtsov.messages;


public class FileTransferMessage implements Message, Serializable {

    private byte[] buffer;
    private String fileName;
    private int length;
    public static final int MAX_BUFFER_LENGTH = 20;

    public FileTransferMessage(byte[] buffer, String fileName, int length) {
        this.buffer = buffer;
        this.fileName = fileName;
        this.length = length;
    }
    public String getFileName() {
        return fileName;
    }

    public int getLength() {
        return length;
    }

    public byte[] getBuffer() {
        return buffer;
    }

}
package ru.nemtsov.messages;

public interface Message {
}
package ru.nemtsov;



/**
 * Unit test for simple App.
 */
public class AppTest
{
    /**
     * Rigorous Test :-)
     */
    @Test
    public void shouldAnswerWithTrue()
    {
        assertTrue( true );
    }
}
package com.flamexander.netty.example.client;


public class MainClient extends Application {
    @Override
    public void start(Stage primaryStage) throws Exception{
        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("/main.fxml"));
        Parent root = fxmlLoader.load();
        primaryStage.setTitle("Box Client");
        Scene scene = new Scene(root);
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
package com.flamexander.netty.example.client;



public class MainController implements Initializable {
    @FXML
    TextField tfFileName;

    @FXML
    ListView<String> filesList;

    @Override
    public void initialize(URL location, ResourceBundle resources) {
        Network.start();
        Thread t = new Thread(() -> {
            try {
                while (true) {
                    AbstractMessage am = Network.readObject();
                    if (am instanceof FileMessage) {
                        FileMessage fm = (FileMessage) am;
                        Files.write(Paths.get("client_storage/" + fm.getFilename()), fm.getData(), StandardOpenOption.CREATE);
                        refreshLocalFilesList();
                    }
                }
            } catch (ClassNotFoundException | IOException e) {
                e.printStackTrace();
            } finally {
                Network.stop();
            }
        });
        t.setDaemon(true);
        t.start();
        refreshLocalFilesList();
    }

    public void pressOnDownloadBtn(ActionEvent actionEvent) {
        if (tfFileName.getLength() > 0) {
            Network.sendMsg(new FileRequest(tfFileName.getText()));
            tfFileName.clear();
        }
    }

    public void refreshLocalFilesList() {
        if (Platform.isFxApplicationThread()) {
            try {
                filesList.getItems().clear();
                Files.list(Paths.get("client_storage")).map(p -> p.getFileName().toString()).forEach(o -> filesList.getItems().add(o));
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            Platform.runLater(() -> {
                try {
                    filesList.getItems().clear();
                    Files.list(Paths.get("client_storage")).map(p -> p.getFileName().toString()).forEach(o -> filesList.getItems().add(o));
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });
        }
    }
}
package com.flamexander.netty.example.client;



public class Network {
    private static Socket socket;
    private static ObjectEncoderOutputStream out;
    private static ObjectDecoderInputStream in;

    public static void start() {
        try {
            socket = new Socket("localhost", 8189);
            out = new ObjectEncoderOutputStream(socket.getOutputStream());
            in = new ObjectDecoderInputStream(socket.getInputStream(), 50 * 1024 * 1024);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void stop() {
        try {
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            in.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static boolean sendMsg(AbstractMessage msg) {
        try {
            out.writeObject(msg);
            return true;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return false;
    }

    public static AbstractMessage readObject() throws ClassNotFoundException, IOException {
        Object obj = in.readObject();
        return (AbstractMessage) obj;
    }
}
package com.flamexander.netty.example.client.protocol;



public class NettyController implements Initializable {
    @FXML
    TextField tfFileName;

    @FXML
    ListView<String> filesList;

    @Override
    public void initialize(URL location, ResourceBundle resources) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                NettyNetwork.getInstance().start();
            }
        }).start();

        refreshLocalFilesList();
    }

    public void pressOnSendData(ActionEvent actionEvent) {
        NettyNetwork.getInstance().sendData();
    }

    public void refreshLocalFilesList() {
        if (Platform.isFxApplicationThread()) {
            try {
                filesList.getItems().clear();
                Files.list(Paths.get("client_storage")).map(p -> p.getFileName().toString()).forEach(o -> filesList.getItems().add(o));
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            Platform.runLater(() -> {
                try {
                    filesList.getItems().clear();
                    Files.list(Paths.get("client_storage")).map(p -> p.getFileName().toString()).forEach(o -> filesList.getItems().add(o));
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });
        }
    }
}
package com.flamexander.netty.example.client.protocol;



public class NettyNetwork {
    private static NettyNetwork ourInstance = new NettyNetwork();

    public static NettyNetwork getInstance() {
        return ourInstance;
    }

    private NettyNetwork() {
    }

    private Channel currentChannel;

    public Channel getCurrentChannel() {
        return currentChannel;
    }

    public void start() {
        EventLoopGroup group = new NioEventLoopGroup();
        try {
            Bootstrap clientBootstrap = new Bootstrap();
            clientBootstrap.group(group);
            clientBootstrap.channel(NioSocketChannel.class);
            clientBootstrap.remoteAddress(new InetSocketAddress("localhost", 8189));
            clientBootstrap.handler(new ChannelInitializer<SocketChannel>() {
                protected void initChannel(SocketChannel socketChannel) throws Exception {
                    socketChannel.pipeline().addLast();
                    currentChannel = socketChannel;
                }
            });
            ChannelFuture channelFuture = clientBootstrap.connect().sync();
            channelFuture.channel().closeFuture().sync();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                group.shutdownGracefully().sync();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    /*
    byteBuf = allocator.buffer(256);
for (int i = 0; i < fullChunksCount; i++) {
	is.read(buf);
	System.out.println("Sending filechunk: " + Arrays.toString(buf));
	byteBuf.writeBytes(buf);
	ctx.writeAndFlush(byteBuf);
	// byteBuf.clear();
}
     */

    public void sendData() {
        ByteBufAllocator allocator = new PooledByteBufAllocator();
        ByteBuf buf = allocator.buffer(16);

        for (int i = 65; i < 75; i++) {
            for (int j = 0; j < 4; j++) {
                if (buf.isWritable()) {
                    buf.writeByte(i);
                } else {
                    try {
                        currentChannel.writeAndFlush(buf).await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    buf.clear();
                    buf.retain();
                }
            }
        }

//        buf.writeByte(15);
//
//        buf.writeLong(8L);
//
//
//
//        for (byte b : "test.txt".getBytes()) {
//            buf.writeByte(b);
//        }
//
//        currentChannel.writeAndFlush(buf);
    }

    public boolean isConnectionOpened() {
        return currentChannel != null && currentChannel.isActive();
    }

    public void closeConnection() {
        currentChannel.close();
    }
}
package com.flamexander.netty.example.common;


public abstract class AbstractMessage implements Serializable {
}
package com.flamexander.netty.example.common;


public class FileMessage extends AbstractMessage {
    private String filename;
    private byte[] data;

    public String getFilename() {
        return filename;
    }

    public byte[] getData() {
        return data;
    }

    public FileMessage(Path path) throws IOException {
        filename = path.getFileName().toString();
        data = Files.readAllBytes(path);
    }
}
package com.flamexander.netty.example.common;

public class FileRequest extends AbstractMessage {
    private String filename;

    public String getFilename() {
        return filename;
    }

    public FileRequest(String filename) {
        this.filename = filename;
    }
}
package com.flamexander.netty.example.server;



public class MainHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        try {
            if (msg == null) {
                return;
            }
            if (msg instanceof FileRequest) {
                FileRequest fr = (FileRequest) msg;
                if (Files.exists(Paths.get("server_storage/" + fr.getFilename()))) {
                    FileMessage fm = new FileMessage(Paths.get("server_storage/" + fr.getFilename()));
                    ctx.writeAndFlush(fm);
                }
            }
        } finally {
            ReferenceCountUtil.release(msg);
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
package com.flamexander.netty.example.server.protocol;



public class ProtocolHandler extends ChannelInboundHandlerAdapter {
    private int state = -1;
    private HashMap<String, Object> map = new HashMap<>();

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ByteBuf buf = (ByteBuf) msg;

        // FileOutputStream fos = new FileOutputStream("1.txt", true);
        while (buf.readableBytes() > 0) {
            // fos.write(buf.readByte());
            System.out.print((char)buf.readByte());
        }
        // fos.close();
//        if (state == -1) {
//            if (buf.readableBytes() >= 1) {
//                map.put("type", buf.readByte());
//                state = 0;
//            }
//        }
//        if (state == 0) {
//            if (buf.readableBytes() >= 8) {
//                state = 1;
//                map.put("fileNameLength", buf.readLong());
//            }
//        }
//        if (state == 1) {
//            if (buf.readableBytes() >= (Long) map.get("fileNameLength")) {
//                byte[] fnb = new byte[((Long)map.get("fileNameLength")).intValue()];
//                buf.readBytes(fnb);
//                System.out.println(new String(fnb));
//                state = -1;
//                map.clear();
//            }
//        }
//        if(state == 2) {
//            FileOutputStream fos = new FileOutputStream("1.txt");
//            while (buf.readableBytes() > 0) {
//                fos.write(buf.readByte());
//            }
//        }


//        try {
//            if (msg == null) {
//                return;
//            }
//            if (msg instanceof FileRequest) {
//                FileRequest fr = (FileRequest) msg;
//                if (Files.exists(Paths.get("server_storage/" + fr.getFilename()))) {
//                    FileMessage fm = new FileMessage(Paths.get("server_storage/" + fr.getFilename()));
//                    ctx.writeAndFlush(fm);
//                }
//            }
//        } finally {
//            ReferenceCountUtil.release(msg);
//        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
package com.flamexander.netty.example.server;


public class Server {
    public void run() throws Exception {
        EventLoopGroup mainGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(mainGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            socketChannel.pipeline().addLast(
                                    new ObjectDecoder(50 * 1024 * 1024, ClassResolvers.cacheDisabled(null)),
                                    new ObjectEncoder(),
                                    new MainHandler()
                            );
                        }
                    })
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture future = b.bind(8189).sync();
            future.channel().closeFuture().sync();
        } finally {
            mainGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        new Server().run();
    }
}
package com.flamexander.netty.servers.blockserver;


public class BlockServer {
    public void run() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() { // (4)
                        @Override
                        public void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(new StringToByteBufHandler(), new FirstHandler(), new SecondHandler(), new GatewayHandler(), new FinalHandler());
                        }
                    })
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture f = b.bind(8189).sync();
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        new BlockServer().run();
    }
}
package com.flamexander.netty.servers.blockserver;



public class FinalHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        byte[] arr = (byte[]) msg;
        Files.write(Paths.get("1.txt"), arr);
        System.out.println("РЎРѕРѕР±С‰РµРЅРёРµ Р·Р°РїРёСЃР°РЅРѕ РІ С„Р°Р№Р»");
        ctx.writeAndFlush("Java\n");
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
package com.flamexander.netty.servers.blockserver;



public class FirstHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ByteBuf buf = (ByteBuf)msg;
        if (buf.readableBytes() < 3) {
            return;
        }
        byte[] data = new byte[3];
        buf.readBytes(data);
        buf.release();
        System.out.println(Arrays.toString(data));
        ctx.fireChannelRead(data);
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
package com.flamexander.netty.servers.blockserver;



public class GatewayHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        int sum = 0;
        byte[] arr = (byte[]) msg;
        for (int i = 0; i < 3; i++) {
            sum += arr[i];
        }
        if (sum == 69) {
            ctx.fireChannelRead(arr);
        } else {
            System.out.println("РЎРѕРѕР±С‰РµРЅРёРµ СЃР»РѕРјР°РЅРѕ: " + Arrays.toString(arr));
            ctx.writeAndFlush("Р‘РёС‚РѕРµ СЃРѕРѕР±С‰РµРЅРёРµ\n");
        }
    }
}
package com.flamexander.netty.servers.blockserver;


public class MyClient {
    public static void main(String[] args) {
        try {
            Socket socket = new Socket("localhost", 8189);
            DataOutputStream out = new DataOutputStream(socket.getOutputStream());
            Scanner in = new Scanner(socket.getInputStream());
            out.write(new byte[]{11, 22, 33});
            String x = in.nextLine();
            System.out.println("A: " + x);
            in.close();
            out.close();
            socket.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
package com.flamexander.netty.servers.blockserver;



public class SecondHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        byte[] arr = (byte[])msg;
        for (int i = 0; i < 3; i++) {
            arr[i]++;
        }
        System.out.println("Р’С‚РѕСЂРѕР№ С€Р°Рі: " + Arrays.toString(arr));
        ctx.fireChannelRead(arr);
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
package com.flamexander.netty.servers.blockserver;


public class StringToByteBufHandler extends ChannelOutboundHandlerAdapter {
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        String str = (String)msg;
        byte[] arr = str.getBytes();
        ByteBufAllocator al = new PooledByteBufAllocator();
        ByteBuf buf = al.buffer(arr.length);
        buf.writeBytes(arr);
        ctx.writeAndFlush(buf);
        buf.release();
    }
}
package com.flamexander.netty.servers.decoding;


public class DecodeServer {
    private int port;

    public DecodeServer(int port) {
        this.port = port;
    }

    public void run() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() { // (4)
                        @Override
                        public void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(new FourByteDecoder(), new DecodeServerHandler());
                        }
                    })
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture f = b.bind(port).sync();
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        new DecodeServer(8189).run();
    }
}
package com.flamexander.netty.servers.decoding;


public class DecodeServerHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        String str = (String)msg;
        System.out.println(str);
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }
}
package com.flamexander.netty.servers.decoding;



public class FourByteDecoder extends ByteToMessageDecoder {
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
        if (in.readableBytes() < 4) {
            return;
        }
        byte[] data = new byte[4];
        in.readBytes(data);
        String str = new String(data);
        out.add(str);
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
package com.flamexander.netty.servers.discard;



public class DiscardServer {
    public void run() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() { // (4)
                        @Override
                        public void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(new DiscardServerHandler());
                        }
                    })
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture f = b.bind(8189).sync();
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        new DiscardServer().run();
    }
}
package com.flamexander.netty.servers.discard;


public class DiscardServerHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        System.out.println("Received and released");
        ((ByteBuf) msg).release();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         ctx.close();
    }

//    @Override
//    public void channelRead(ChannelHandlerContext ctx, Object msg) {
//        ByteBuf in = (ByteBuf) msg;
//        try {
//            while (in.isReadable()) {
//                System.out.print((char) in.readByte());
//                break;
//            }
//        } finally {
//            ReferenceCountUtil.release(msg);
//        }
//    }
}
package com.flamexander.netty.servers.order;


public class OrderServer {
    public void run() throws Exception {
        class InboundTest extends ChannelInboundHandlerAdapter {
            private String name;
            private boolean answer;

            public InboundTest(String name, boolean answer) {
                this.name = name + "(In)";
                this.answer = answer;
            }

            @Override
            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                System.out.println(this.name);
                if (answer) {
                    ctx.write("xxx");
                }
                ctx.fireChannelRead(msg);
            }
        }

        class OutboundTest extends ChannelOutboundHandlerAdapter {
            private String name;

            public OutboundTest(String name) {
                this.name = name + "(Out)";
            }

            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
                System.out.println(this.name);
                ctx.writeAndFlush("1");
            }
        }

        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() { // (4)
                        @Override
                        public void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(
                                    new InboundTest("1", false),
                                    new InboundTest("2", true),
                                    new OutboundTest("2"),
                                    new OutboundTest("1"),
                                    new InboundTest("3", true)
                            );
                        }
                    })
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture f = b.bind(8189).sync();
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        new OrderServer().run();
    }
}
package com.flamexander.netty.servers.outchain;


public class ChainClient {
    public static void main(String[] args) {
        try {
            Socket socket = new Socket("localhost", 8189);
            DataOutputStream out = new DataOutputStream(socket.getOutputStream());
            Scanner in = new Scanner(socket.getInputStream());
            out.write(10);
            String x = in.nextLine();
            System.out.println("Answer: " + x);
            in.close();
            out.close();
            socket.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
package com.flamexander.netty.servers.outchain;


public class ChainInHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ctx.write("Java\n");
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
package com.flamexander.netty.servers.outchain;


public class OutChainServer {
    public void run() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() { // (4)
                        @Override
                        public void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(new StringToByteBufHandler(), new StringUpperHandler(), new ChainInHandler());
                        }
                    })
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture f = b.bind(8189).sync();
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        new OutChainServer().run();
    }
}
package com.flamexander.netty.servers.outchain;


public class StringToByteBufHandler extends ChannelOutboundHandlerAdapter {
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        String str = (String)msg;
        byte[] arr = str.getBytes();
        ByteBufAllocator al = new PooledByteBufAllocator();
        ByteBuf buf = al.buffer(arr.length);
        buf.writeBytes(arr);
        ctx.writeAndFlush(buf);
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
package com.flamexander.netty.servers.outchain;


public class StringUpperHandler extends ChannelOutboundHandlerAdapter {
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        String str = (String)msg;
        str = str.toUpperCase();
        ctx.writeAndFlush(str);
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
package com.flamexander.netty.servers.protocol;


public class ProtocolClient {
    public static void main(String[] args) {
        try (Socket socket = new Socket("localhost", 8189)) {
            DataOutputStream out = new DataOutputStream(socket.getOutputStream());
            out.write(15);
            byte[] filenameBytes = "java.txt".getBytes();
            out.writeInt(filenameBytes.length);
            out.write(filenameBytes);
            out.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
package com.flamexander.netty.servers.protocol;



public class ProtocolHandler extends ChannelInboundHandlerAdapter {
    private enum DataType {
        EMPTY((byte)-1), FILE((byte)15), COMMAND((byte)16);

        byte firstMessageByte;

        DataType(byte firstMessageByte) {
            this.firstMessageByte = firstMessageByte;
        }

        static DataType getDataTypeFromByte(byte b) {
            if (b == FILE.firstMessageByte) {
                return FILE;
            }
            if (b == COMMAND.firstMessageByte) {
                return COMMAND;
            }
            return EMPTY;
        }
    }

    private int state = -1;
    private int reqLen = -1;
    private DataType type = DataType.EMPTY;

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ByteBuf buf = ((ByteBuf) msg);

        if (state == -1) {
            byte firstByte = buf.readByte();
            type = DataType.getDataTypeFromByte(firstByte);
            state = 0;
            reqLen = 4;
            System.out.println(type);
        }

        if (state == 0) {
            if (buf.readableBytes() < reqLen) {
                return;
            }
            reqLen = buf.readInt();
            state = 1;
            System.out.println("text size: " + reqLen);
        }

        if (state == 1) {
            if (buf.readableBytes() < reqLen) {
                return;
            }
            byte[] data = new byte[reqLen];
            buf.readBytes(data);
            String str = new String(data);
            System.out.println(type + " " + str);
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
package com.flamexander.netty.servers.protocol;


public class ProtocolServer {
    private int port;

    public ProtocolServer(int port) {
        this.port = port;
    }

    public void run() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() { // (4)
                        @Override
                        public void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(new ProtocolHandler());
                        }
                    })
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture f = b.bind(port).sync();
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        new ProtocolServer(8189).run();
    }
}
package com.flamexander.netty.servers.serialization;



public class Client {
    public static void main(String[] args) {
        ObjectEncoderOutputStream oeos = null;
        ObjectDecoderInputStream odis = null;

        try (Socket socket = new Socket("localhost", 8189)) {
            oeos = new ObjectEncoderOutputStream(socket.getOutputStream());
            MyMessage textMessage = new MyMessage("Hello Server!!!");
            oeos.writeObject(textMessage);
            oeos.flush();
            odis = new ObjectDecoderInputStream(socket.getInputStream(), 100 * 1024 * 1024);
            MyMessage msgFromServer = (MyMessage)odis.readObject();
            System.out.println("Answer from server: " + msgFromServer.getText());
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                oeos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                odis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
package com.flamexander.netty.servers.serialization;


public class CloudServer {
    public void run() throws Exception {
        EventLoopGroup mainGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(mainGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            socketChannel.pipeline().addLast(
                                    new ObjectDecoder(1024 * 1024 * 100, ClassResolvers.cacheDisabled(null)),
                                    new ObjectEncoder(),
                                    new CloudServerHandler()
                            );
                        }
                    })
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture future = b.bind(8189).sync();
            future.channel().closeFuture().sync();
        } finally {
            mainGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        new CloudServer().run();
    }
}
package com.flamexander.netty.servers.serialization;


public class CloudServerHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        System.out.println("Client connected...");
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        try {
            if (msg == null) {
                return;
            }
            System.out.println(msg.getClass());
            if (msg instanceof MyMessage) {
                System.out.println("Client text message: " + ((MyMessage) msg).getText());
                ctx.writeAndFlush(new MyMessage("Hello Client!"));
            } else {
                System.out.printf("Server received wrong object!");
                return;
            }
        } finally {
            ReferenceCountUtil.release(msg);
        }
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
package com.flamexander.netty.servers.serialization;


public class MyMessage implements Serializable {
    private static final long serialVersionUID = 5193392663743561680L;

    private String text;

    public String getText() {
        return text;
    }

    public MyMessage(String text) {
        this.text = text;
    }
}

public class DBService {

    private static Connection connection;
    private static Statement stmt;

    // РїРѕРґРєР»СЋС‡РµРЅРёРµ Рє Р‘Р”
    public void connect() throws SQLException {
        try {
            Class.forName("org.sqlite.JDBC");
            connection = DriverManager.getConnection("jdbc:sqlite:mainDB.db");
            stmt = connection.createStatement();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    // РѕС‚РєР»СЋС‡РµРЅРёРµ РѕС‚ Р‘Р”
    public void disconnect() throws SQLException {
        connection.close();
    }

    // Р·Р°РїСЂРѕСЃ РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ РёР· Р‘Р”, РµСЃР»Рё РёСЃРєРѕРјС‹Р№ РїРѕР»СЊР·РѕРІР°С‚Р»СЊ РµСЃС‚СЊ
    // С‚Рѕ РІРµСЂРЅРµС‚СЃСЏ true РµСЃР»Рё РµРіРѕ РЅРµС‚, С‚Рѕ РІРµСЂРЅРµС‚СЃСЏ false
    public boolean signIn(String login, String password) {
        try {
            if (stmt == null || stmt.isClosed()) {
                connect();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        String query = String.format("SELECT TRUE FROM users WHERE login = '%s' AND password = '%s'", login, password);
        try {
            ResultSet rs = stmt.executeQuery(query);
            if (rs.next()) {
                return true;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

}


public class Main {

    public static void main(String[] args) throws InterruptedException {
        EventLoopGroup mainGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(mainGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            socketChannel.pipeline().addLast(
                                    new ObjectDecoder(100 * 1024 * 1024, ClassResolvers.cacheDisabled(null)),
                                    new ObjectEncoder(),
                                    new MainHandler()
                            );
                        }
                    })
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture future = bootstrap.bind(9999).sync();
            future.channel().closeFuture().sync();
        } finally {
            mainGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }

}






//private static final int PORT = 9999;
//
//public static void main(String[] args) {
//        try {
//        ServerSocket serverSocket = new ServerSocket(9999);
//        System.out.println("Server started");
//        while (true) {
//        Socket socket = serverSocket.accept();
//        System.out.println("Client connected");
//        Thread thread = new Thread(new ServerThread(socket));
//        thread.start();
//        }
//        } catch (IOException e) {
//        e.printStackTrace();
//        }
//        }
//
//private static class ServerThread implements Runnable {
//    private Socket socket;
//    private static int bytesRead;
//
//    public ServerThread(Socket socket) {
//        this.socket = socket;
//    }
//
//    @Override
//    public void run() {
//        try {
//            InputStream inputStream = socket.getInputStream();
//            DataInputStream dataInputStream = new DataInputStream(inputStream);
//            FileOutputStream fileOutputStream = new FileOutputStream("C:\\2.txt");
//            byte[] buffer = new byte[4096];
//            while ((bytesRead = dataInputStream.read(buffer, 0, buffer.length)) != -1) {
//                fileOutputStream.write(buffer, 0, bytesRead);
//            }
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
//    }
//}


public class MainHandler extends ChannelInboundHandlerAdapter {

    DBService db = new DBService();

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        try {
            if (msg == null) {
                return;
            }
            String fileName = "C:\\2.txt";
            if (msg instanceof CommandMessage) {
                CommandMessage commandMessage = (CommandMessage) msg;
                Path path = Paths.get(fileName);
                if (Files.exists(path)) {
                    Files.delete(path);
                }
            }
            if (msg instanceof FileTransferMessage) {
                FileTransferMessage fileTransferMessage = (FileTransferMessage) msg;
                byte[] buffer = fileTransferMessage.getBuffer();
                try {
                    FileOutputStream fileOutputStream = new FileOutputStream(fileName, true);
                    fileOutputStream.write(buffer,0, fileTransferMessage.getLength());
                    fileOutputStream.close();
                    //ctx.writeAndFlush();
                } catch (IOException e) {
                    e.printStackTrace();
                }
//                if (Files.exists(Paths.get("server_storage/" + fr.getFilename()))) {
//                    FileMessage fm = new FileMessage(Paths.get("server_storage/" + fr.getFilename()));
//                    ctx.writeAndFlush(fm);
//                }
            }
            if (msg instanceof AuthMessage) {
                AuthMessage authMessage = (AuthMessage) msg;
                boolean isAuthorized = db.signIn(authMessage.getLogin(), authMessage.getPassword());
                if (isAuthorized) {
                    ctx.writeAndFlush(new CommandMessage(Command.AUTH, "ok"));
                } else {
                    ctx.writeAndFlush(new CommandMessage(Command.AUTH, ""));
                }
            }
        } finally {
            ReferenceCountUtil.release(msg);
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        super.exceptionCaught(ctx, cause);
    }
}
========================================
========================================
Project name: cloudstorage0
========================================
========================================
Project name: Cloud_core-master


public class ConnectWithServer {

    private static Socket socket;
    private static ObjectEncoderOutputStream out;
    private static ObjectDecoderInputStream in;

    public static void connect() {
        try {
            socket = new Socket("localhost", 8189);
            out = new ObjectEncoderOutputStream(socket.getOutputStream());
            in = new ObjectDecoderInputStream(socket.getInputStream(),20*1024*1024);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void disconnect() {
        try {
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            in.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    public static boolean sendAuthMessage(String login, String password) {
        try {
            out.writeObject(new MessageAuthentification(login,password));
            out.flush();
            return true;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return false;
    }

    public static boolean sendRegMessage(String login, String password) {
        try {
            out.writeObject(new MessageRegistration(login,password));
            out.flush();
            return true;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return false;
    }
    public static Object readInObject() throws IOException, ClassNotFoundException {
        Object object = in.readObject();
        return  object;
    }
}




public class FirstWindowController implements Initializable {
    @FXML
    VBox autorization;
    @FXML
    TextField loginField;
    @FXML
    PasswordField passwordField;
    @FXML
    VBox registration;
    @FXML
    Label messageToUser;
    @FXML
    Label messageToUserRegistration;
    @FXML
    TextField loginFieldReg;
    @FXML
    PasswordField passwordField1;
    @FXML
    PasswordField passwordField2;
    @FXML
    Button but0;
    @FXML
    HBox authHbox;


    @Override
    public void initialize(URL location, ResourceBundle resources) {
        ConnectWithServer.connect();
        ServerListener.setDaemon(true);
        ServerListener.start();
    }

    Thread ServerListener = new Thread(() -> {
        for (;;){
            Object messageFromServer = null;
            try {
                messageFromServer = ConnectWithServer.readInObject();
            } catch (IOException | ClassNotFoundException e) {
                e.printStackTrace();
            }
            if (messageFromServer.toString().startsWith("User exist/")){

                SuccessfulEnter();

            }else if (messageFromServer.toString().startsWith("WrongPassword")){

                Platform.runLater(() -> messageToUser.setText("Wrong password"));

            }else if (messageFromServer.toString().startsWith("UserNoExist")){

                Platform.runLater(() -> messageToUser.setText("Such user doesn't exist"));

            }else if (messageFromServer.toString().equals("userAlreadyExists")){

                Platform.runLater(() -> {
                    messageToUserRegistration.setText("Such user already exists");
                    loginFieldReg.clear();
                    passwordField1.clear();
                    passwordField2.clear();
                });

            } else if (messageFromServer.toString().equals("registrationIsSuccessful")){
                Platform.runLater(() -> {
                    exitReg();
                    messageToUser.setText("Registration is successful. Enter in your account");
                });
            }
        }
    });

    public void showRegForm(){
        autorization.setVisible(false);
        authHbox.setVisible(false);
        registration.setVisible(true);
    }
    public void exitReg(){
        autorization.setVisible(true);
        authHbox.setVisible(true);
        registration.setVisible(false);
    }
    public void sendAuthMessage(){
        if (!loginField.getText().isEmpty() && !passwordField.getText().isEmpty()){
            ConnectWithServer.sendAuthMessage(loginField.getText(),passwordField.getText());
            loginField.clear();
            passwordField.clear();
        }
    }
    public void sendRegMessage(){
        if (!loginFieldReg.getText().isEmpty() && !passwordField1.getText().isEmpty() && !passwordField2.getText().isEmpty()){
            if (passwordField1.getText().equals(passwordField2.getText())){
                ConnectWithServer.sendRegMessage(loginFieldReg.getText(),passwordField1.getText());
            }else {
                messageToUserRegistration.setText("Make sure the passwords match");
                passwordField1.clear();
                passwordField2.clear();
            }
        }
    }

    public void switchScene() throws IOException {
        Stage stage;
        Parent root;
        stage = (Stage)but0.getScene().getWindow();
        root = FXMLLoader.load(getClass().getResource("/MainWindow.fxml"));
        Image icon = new Image(getClass().getResourceAsStream("/iconfinder_cloud_1287533.png"));
        stage.getIcons().add(icon);
        Scene scene = new Scene(root);
        stage.setScene(scene);
        stage.setResizable(false);
        stage.setTitle("Cloud_core");
        stage.show();
    }
    public void SuccessfulEnter(){
        Platform.runLater(() -> {
            try {
                switchScene();
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
    }



}

public class Main extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {
        Parent root = FXMLLoader.load(getClass().getResource("/firstWindow.fxml"));
        primaryStage.setTitle("Oblachko");
        Image icon = new Image(getClass().getResourceAsStream("/iconfinder_cloud_1287533.png"));
        primaryStage.getIcons().add(icon);
        Scene scene = new Scene(root, 700, 450, Color.BEIGE);
        primaryStage.setResizable(false); //РЅРµРёР·РјРµРЅСЏРµРјРѕСЃС‚СЊ СЂР°Р·РјРµСЂР°
        primaryStage.setScene(scene);
        primaryStage.show();

    }
    public static void main(String[] args) {
        launch(args);
    }
}
public class MainWindowController {
}

public abstract class AbstractMessage implements Serializable {
}
public class MessageAuthentification extends AbstractMessage {
    private String login;
    private String password;

    public MessageAuthentification(String login, String password) {
        this.login = login;
        this.password = password;
    }

    public String getLogin() {
        return login;
    }

    public String getPassword() {
        return password;
    }
}
public class MessageRegistration extends AbstractMessage {
    private String login;
    private String password;

    public MessageRegistration(String login, String password) {
        this.login = login;
        this.password = password;
    }

    public String getLogin() {
        return login;
    }

    public String getPassword() {
        return password;
    }
}

public class AuthService {

    private static Connection connection;
    private static Statement stmt;

    public static void connect() throws SQLException {
        try {
            Class.forName("org.sqlite.JDBC");
            connection = DriverManager.getConnection("jdbc:sqlite:mainDB.db");
            stmt = connection.createStatement();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    public static void disconnect(){
        try {
            stmt.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static boolean checkPassword(String login, String password){
        try {
            String sql = String.format("SELECT password FROM main\n" + "where login = '%s'", login);
            ResultSet rs = stmt.executeQuery(sql);
            System.out.println("login = " + login + " password = " + password);

            int passwordFromDB = rs.getInt(1);
            System.out.println("Password from DB = " + passwordFromDB);
            System.out.println("Hashcode = " + password.hashCode());
            if (passwordFromDB == password.hashCode()) {
                System.out.println("YEEEEEEESSS");
                return true;
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

    public static void addUser(String login, String pass) {
        String sql = String.format("INSERT INTO main (login, password)" +
                "VALUES ('%s', '%s')", login, pass.hashCode());
        try {
            stmt.execute(sql);
        } catch (SQLException e) {
            e.printStackTrace();
        }

    }


    public static boolean checkHaveThisUser(String login) {
        try {
            String sql = String.format("SELECT login FROM main\n" + "where login = '%s'", login);
            ResultSet rs = stmt.executeQuery(sql);

            if (rs.next()) {
                return true;
            } else return false;

        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }


}


public class MessageHandler extends ChannelInboundHandlerAdapter {

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        if (msg == null) {
            return;
        }
            if (msg instanceof MessageAuthentification) {
                MessageAuthentification message = (MessageAuthentification) msg;
                AuthService.connect();
                if (AuthService.checkHaveThisUser(message.getLogin())) {
                    if (AuthService.checkPassword(message.getLogin(), message.getPassword())) {
                        ctx.writeAndFlush("User exist/" + message.getLogin());
                        System.out.println(message.getLogin() +" " + message.getPassword());
                    } else {
                        ctx.writeAndFlush("WrongPassword");
                    }
                } else {
                    ctx.writeAndFlush("UserNoExist");
                }
                AuthService.disconnect();
            } else if (msg instanceof MessageRegistration) {
                MessageRegistration message = (MessageRegistration) msg;
                AuthService.connect();
                if (AuthService.checkHaveThisUser(message.getLogin())) {
                 ctx.writeAndFlush("userAlreadyRegistered");
                } else {
                        AuthService.addUser(message.getLogin(), message.getPassword());
                        ctx.writeAndFlush("registrationIsSuccessful");
                    }
                }
                AuthService.disconnect();
            }



    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        AuthService.disconnect();
        ctx.close();
    }


}



public class Server {
    public void run() throws Exception {
        EventLoopGroup mainGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(mainGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            socketChannel.pipeline().addLast(
                                    new ObjectDecoder(150 * 1024 * 1024, ClassResolvers.cacheDisabled(null)),
                                    new ObjectEncoder(),
                                    new MessageHandler()
                            );
                        }
                    })
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture future = b.bind(8189).sync();
            future.channel().closeFuture().sync();
        } finally {
            mainGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }

    }
    public static void main(String[] args) throws Exception {
        new Server().run();
    }
}
========================================
========================================
Project name: JavaCloudStorage-master
package basic_client.clientstorage;


public class Test {
    public static void main(String[] args) {
        /*String filePath = "UserTXTdoc.txt";
        String[] res = filePath.split(".txt");
        for (String s:
             res) {
            System.out.println(s);
        }
        System.out.println(filePath.indexOf("."));
        System.out.println(filePath.substring(0,filePath.indexOf(".")));*/
         //System.out.println(filePath.split("."));

        BiFunction<String, String, String> str = (str1, str2) -> str1.concat(str2);

        Stream<String> strStream = Stream.of("UserTXTdoc.txt");
        Optional<String> reducedOptString = strStream.
                map(p->p.replaceAll(p.substring(p.indexOf(".")),
                        "2user".concat(p.substring(p.indexOf(".")))))
                .findFirst();
        //Optional<String> reducedOptString = strStream.map(p->p.substring(0,p.indexOf("."))).findFirst().map(p->p.concat("2user"));
        //Optional<String> optStringFormat = strStream.map(p->p.substring(p.indexOf("."))).findFirst();
        //reducedOptString.map(p->p.concat(optStringFormat));
        String str2 = reducedOptString.get();
        System.out.println(str2);
        /*Optional<String> reducedOptString = strStream.reduce((p,q)->p.substring(0,p.indexOf(".")));
        System.out.println(reducedOptString.get());*/

        //System.out.println(str.apply("Hi, ", "Tits!"));


    }

    private static String fileNameConverter(String initFileName) {
        String fileFormat = initFileName.substring(initFileName.indexOf(".")+1, initFileName.length());
        return (initFileName.substring(0,initFileName.indexOf("."))+"2user").concat(".").concat(fileFormat);
    }
}
package basic_client;



public class EasyClient {
    public static void main(String[] args) {
        Socket socket;
        String fileName = "/ServerTXTdoc.txt";
        String filePathSrc = "/home/serj/Java/GeekBrains/GEEKBRAINS/JavaCloudStorage/Senin26Cloud/src/main/java/basic_server/serverstorage";
        String filePathDest = "/home/serj/Java/GeekBrains/GEEKBRAINS/JavaCloudStorage/Senin26Cloud/src/main/java/basic_client/clientstorage";
        Thread clientInThread = new Thread(() -> {
            try {
                FilesHandler.getFile(fileName, filePathSrc, filePathDest);
                System.out.println("Server sent the file: ");
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
        clientInThread.start();
    }
}
package basic_server;



public class EasyServer {
    public static void main(String[] args) {
        ServerSocket server = null;
        Socket socket = null;
        try {
            server = new ServerSocket(ConnectionSettings.getPORT());
            System.out.println("Server started!");
            socket = server.accept();
            System.out.println("Client connected!");
            DataInputStream serverIn = new DataInputStream(socket.getInputStream());
            DataOutputStream serverOut = new DataOutputStream(socket.getOutputStream());
            Scanner scnServer = new Scanner(System.in);

            Thread serverOutThread = new Thread(() -> {
                while (true) {
                    try {
                        String serverMsg2Client = scnServer.nextLine();
                        serverOut.writeUTF(serverMsg2Client);
                        System.out.println("Server: " + serverMsg2Client);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            });
            serverOutThread.start();

            Thread serverInThread = new Thread(() -> {
                while (true) {
                    try {
                        String clientMsg = serverIn.readUTF();
                        System.out.println("Client: " + clientMsg);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            });
            serverInThread.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
package common;

public final class ConnectionSettings {

    private static final String IP_ADDRESS = "localhost";
    private static final int PORT = 8189;

    public static final String getIP_ADDRESS() {
        return IP_ADDRESS;
    }

    public static final int getPORT() {
        return PORT;
    }
}
package common;


public final class FilesHandler {

    static BiFunction<String, String, String> str1 = (s1, s2) -> s1.concat(s2);

    static Function<String, String> str2 = s -> {return Stream.of(s).
            map(p->p.replaceAll(p.substring(p.indexOf(".")),
                    "2user".concat(p.substring(p.indexOf(".")))))
            .findFirst().get();
    };

    public static void getFile(String fileName, String filePathSrc, String filePathDest) throws Exception {
        String fullFileNameSrc = str1.apply(filePathSrc,fileName);
        String fullFileNameDest = str1.apply(filePathDest,fileName);
        FileInputStream fis = new FileInputStream(str1.apply(filePathSrc,fileName));
        FileOutputStream fos = new FileOutputStream(str1.apply(filePathDest,fileName));
        int chunk;
        while ((chunk = fis.read())!=-1) {
            fos.write(chunk);
        }
        //inputStream.read();
    }

    public static void readFile(String fileName) throws Exception {
        try (FileInputStream fis = new FileInputStream(fileName)) {
            int chunk;
            while ((chunk = fis.read())!=-1) {
                System.out.print((char) chunk);;
            }
        }
    };

    public static void sendFile(OutputStream outputStream) throws Exception {
        outputStream.write(Byte.MAX_VALUE);
    }

    // todo consider replace of this for stream
    private static  String fileInputNameConverter(String filePathSrc, String fileName) {
        return filePathSrc.concat(fileName);
    }

    private static String fileNameConverter(String initFileName) {
        /*String fileFormat = initFileName.substring(initFileName.indexOf(".")+1, initFileName.length());
        return (initFileName.substring(0,initFileName.indexOf("."))+"2user").concat(".").concat(fileFormat);*/

        return Stream.of(initFileName).
                map(p->p.replaceAll(p.substring(p.indexOf(".")),
                        "2user".concat(p.substring(p.indexOf(".")))))
                .findFirst().get();
    }

}
package common.paths;

public final class PathsHandler {

    private PathsHandler() {
    }

   /* public static final String commonPathPart = "/home/serj/Java/GeekBrains/GEEKBRAINS/JavaCloudStorage/Senin26Cloud/src/main/java/";
    "/home/serj/Java/GeekBrains/GEEKBRAINS/JavaCloudStorage/Senin26Cloud/src/main/java/basic_client/clientstorage/UserTXTdoc.txt"
*/
    public static final String pathsConcatenator(String subPath1, String subPath2) {
        return subPath1.concat(subPath2);
    }

}
package training.nio;


public class App {

    public void test() throws IOException, Exception {
    }


    public static void main(String[] args) throws IOException {
         /*   Path path = Paths.get("1.txt");
            path = path.toAbsolutePath();
        System.out.println(path.toString());
        System.out.println(path.getName(2));
        System.out.println(path.getNameCount());

        Files.copy(path, Paths.get("2.txt"), StandardCopyOption.REPLACE_EXISTING);*/

        Path path = Paths.get("11");
        Files.walkFileTree(path, new FileVisitor<Path>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                System.out.println(file.getFileName().toString());
                if (file.getFileName().toString().equals("5.txt")) {
                    System.out.println("Requested file is found");
                    return FileVisitResult.TERMINATE;
                }
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                return FileVisitResult.CONTINUE;
            }
        });
    }
}
package training.nio.simplefilevisitor;


public class AppSimpleFV {


    public static void main(String[] args) throws IOException {
         /*   Path path = Paths.get("1.txt");
            path = path.toAbsolutePath();
        System.out.println(path.toString());
        System.out.println(path.getName(2));
        System.out.println(path.getNameCount());

        Files.copy(path, Paths.get("2.txt"), StandardCopyOption.REPLACE_EXISTING);*/

        Path path = Paths.get("11");
        Files.walkFileTree(path, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                Files.delete(file);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                Files.delete(dir);
                return FileVisitResult.CONTINUE;
            }
        });
    }
}
package training.RandomAccessFile;


public class RafApp {

    public static void main(String[] args) {

        /*training.RandomAccessFile raf = new training.RandomAccessFile("1.txt", "rw");
        FileChannel src = raf.getChannel();

        training.RandomAccessFile rafTo = new training.RandomAccessFile("7.txt", "rw");
        FileChannel toFC = rafTo.getChannel();

        long position = 0;
        long size = raf.length();

        toFC.transferFrom(src, position, size);
        src.transferTo(position, size, toFC);*/


       /* try(training.RandomAccessFile raf = new training.RandomAccessFile("1.txt", "rw")) {
            FileChannel channel = raf.getChannel();

            ByteBuffer buffer = ByteBuffer.allocate(4);
            int readBytes = channel.read(buffer);

            while (readBytes != -1) {
                buffer.flip();
                while (buffer.hasRemaining()) {
                    System.out.print((char) buffer.get());
                }
                buffer.clear();
                readBytes = channel.read(buffer);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }*/

        ByteBuffer bBuffer = ByteBuffer.allocate(4);
        bBuffer.put((byte) 1);
        bBuffer.put((byte) 2);
        bBuffer.put((byte) 3);
        bBuffer.flip();
        System.out.println(bBuffer.get());
        System.out.println(bBuffer.get());
        System.out.println(bBuffer.get());
        bBuffer.flip();
        bBuffer.put((byte) 4);
        bBuffer.put((byte) 5);
        bBuffer.flip();
        System.out.println(bBuffer.get());
        System.out.println(bBuffer.get());
        //System.out.println(bBuffer.get());
    }

}

public class MyMiscellTests {

    FilesHandler filesHandler;

    @Before
    public void init() {
        filesHandler = new FilesHandler();
    }

/*@Test
    public void test_fileNameConverter() {
        String exp = "MyFile2user.txt";
        Assert.assertEquals(exp, FilesHandler.fileNameConverter("MyFile.txt"));
    }

    @Test
    public void test*/


}
========================================
========================================
Project name: JCloud-lesson2_dev_nio_final
package controllers;




public class DeleteController {

    public static boolean confirmDelete = false;

    public DeleteController(String info) {

        Alert alert = new Alert(Alert.AlertType.CONFIRMATION);

        alert.setTitle("РЈРґР°Р»РµРЅРёРµ af");
        alert.setContentText("РЈРґР°Р»РёС‚СЊ Р·Р°РїРёСЃСЊ\n" + info + " ?");

        Optional<ButtonType> result = alert.showAndWait();

        confirmDelete = result.get() == ButtonType.OK;
    }
}
package controllers;


public class LoginController {
    @FXML
    TextField login;

    @FXML
    PasswordField password;

    @FXML
    VBox globParent;

    public MainController backController;

    @FXML
    public void auth(ActionEvent actionEvent) {
        dp(this, "auth " + login.getText() + ":" + password.getText());
        backController.signInCustomer(new Customer(login.getText(), password.getText()));
        globParent.getScene().getWindow().hide();
    }
}
package controllers;





public class MainController implements Initializable, MainView {

    private final String LOCAL_STORAGE = "local_storage";

    @FXML
    Hyperlink hlCloud;
    @FXML
    private Hyperlink hlSignup;
    @FXML
    private TableView<FileDescriptor> tableLocal;
    @FXML
    private TableView<FileDescriptor> tableCloud;
    @FXML
    private TableColumn<FileDescriptor, String> colLocalName;
    @FXML
    private TableColumn<FileDescriptor, String> colCloudName;
    @FXML
    private TableColumn<FileDescriptor, String> colLocalSize;
    @FXML
    private TableColumn<FileDescriptor, String> colCloudSize;

    private BlockingQueue<ClientMessage> queue;
    private FileProvider fileProvider;
    private CloudClient client;
    private SessionId sessionId;
    private ProgressView progressView;
    private boolean isAuthenticated;
    private long messageId;
    private List<String> commandArgs;

    @Override
    public void initialize(URL location, ResourceBundle resources) {
        colLocalName.setCellValueFactory(new PropertyValueFactory<>("fileName"));
        colLocalSize.setCellValueFactory(new PropertyValueFactory<>("fileSize"));
        colCloudName.setCellValueFactory(new PropertyValueFactory<>("fileName"));
        colCloudSize.setCellValueFactory(new PropertyValueFactory<>("fileSize"));

        // TODO: РџСЂРѕРІР°Р№РґРµСЂ Р»РѕРєР°Р»СЊРЅРѕРіРѕ С…СЂР°РЅРёР»РёС‰Р°
        fileProvider = new FileProvider();
        dirLocal(null);

        // TODO: РћС‡РµСЂРµРґСЊ СЃРѕРѕР±С‰РµРЅРёР№ СЃРµСЂРІРµСЂСѓ
        queue = new LinkedBlockingQueue<>(10);

        // TODO: Р—Р°РїСѓСЃРє РєР»РёРµРЅС‚Р°
        try {
            InetSocketAddress address;
            address = new InetSocketAddress("localhost", 15454);
//            if(commandArgs.size() == 2) {
//                address = new InetSocketAddress(commandArgs.get(0), Integer.parseInt(commandArgs.get(1)));
//            } else {
//                address = new InetSocketAddress("localhost", 15454);
//            }

            client = new CloudClient(address, this, LOCAL_STORAGE);
        } catch (IOException e) {
            // TODO: РќСѓР¶РµРЅ Р°Р»РµСЂС‚ Рё РґРµР°РєС‚РёРІР°С†РёСЏ РєРЅРѕРїРѕРє
            System.out.println("Client connection error");
        }
    }

    /**
     * TODO: РџРѕРєР°Р·Р°С‚СЊ РѕРєРЅРѕ Р°РІС‚РѕСЂРёР·Р°С†РёРё
     */
    @FXML
    public void signinPrompt(ActionEvent actionEvent) {
        try {
            Stage stage = new Stage();
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/login_window.fxml"));
            Parent root = loader.load();
            LoginController lc = (LoginController) loader.getController();
            lc.backController = this;

            stage.setTitle("РђРІС‚РѕСЂРёР·Р°С†РёСЏ");
            stage.setScene(new Scene(root, 400, 200));
            stage.initModality(Modality.APPLICATION_MODAL);
            stage.showAndWait();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * TODO: РџРѕРєР°Р·Р°С‚СЊ РѕРєРЅРѕ СЂРµРіРёСЃС‚СЂР°С†РёРё
     */
    @FXML
    public void signupPrompt(ActionEvent actionEvent) {
        try {
            Stage stage = new Stage();
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/signup_window.fxml"));
            Parent root = loader.load();
            SignUpController suc = (SignUpController) loader.getController();
            suc.id = 200;
            suc.backController = this;

            stage.setTitle("Р РµРіРёСЃС‚СЂР°С†РёСЏ");
            stage.setScene(new Scene(root, 400, 200));
            stage.initModality(Modality.APPLICATION_MODAL);
            stage.showAndWait();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @FXML
    public void dirLocal(ActionEvent actionEvent) {
        updateLocalStoreView();
    }

    @FXML
    public void dirRemote(ActionEvent actionEvent) {
        putInQueue(new ClientDir(messageId++, sessionId, null));
    }

    @FXML
    public void delLocalFile() {
        FileDescriptor fd = tableLocal.getSelectionModel().getSelectedItem();
        new DeleteController(fd.getFileName());
        if (DeleteController.confirmDelete) {
            if (fileProvider.deleteFile(Paths.get(LOCAL_STORAGE, fd.getFileName()))) {
                tableLocal.getItems().clear();
                updateLocalStoreView();
            }
        }
    }

    @FXML
    public void delRemoteFile() {
        FileDescriptor fd = tableCloud.getSelectionModel().getSelectedItem();
        new DeleteController(fd.getFileName());
        if (DeleteController.confirmDelete) {
            putInQueue(new ClientDelFile(messageId++, sessionId, fd.getFileName()));
        }
    }

    @FXML
    public void initiateDownload(ActionEvent actionEvent) {
        FileDescriptor fd = tableCloud.getSelectionModel().getSelectedItem();
        putInQueue(new ClientGet(messageId++, sessionId, fd.getFileName()));
    }

    @FXML
    public void initiateUpload(ActionEvent actionEvent) {
        FileDescriptor fd = tableLocal.getSelectionModel().getSelectedItem();
        try {
            putInQueue(new ClientPut(messageId++, sessionId, fd.getFileName(), Files.size(Paths.get(LOCAL_STORAGE, fd.getFileName()))));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * TODO: РћС‚РѕР±СЂР°Р·РёС‚СЊ РѕС‚РІРµС‚ СЃРµСЂРІРµСЂР°
     */
    @Override
    public void renderResponse(ServerMessage response) {
        switch (response.getResponse()) {
            case SDIR:
                FileDescriptor[] fd = ((ServerDirResponse) response).getFiles();
                if (fd.length != 0) {
                    tableCloud.setItems(fileProvider.getStorageModel(fd));
                }
                break;
            case SAUTH:
                ServerAuthResponse respAuth = (ServerAuthResponse) response;
                isAuthenticated = respAuth.isAuth();
                sessionId = respAuth.getSessionId();

                hlSignup.setDisable(isAuthenticated);
                hlCloud.setDisable(isAuthenticated);
                dp(this, "renderResponse:SAUTH. response is " + isAuthenticated);

                // TODO: Р•СЃР»Рё Р°СѓС‚РµРЅС‚РёС„РёС†РёСЂРѕРІР°РЅС‹, С‚Рѕ Р·Р°РїСЂРѕСЃРёС‚СЊ СЃРїРёСЃРѕРє С„Р°Р№Р»РѕРІ
                // TODO: РРЅР°С‡Рµ РІС‹РІРµСЃС‚Рё Р°Р»РµСЂС‚ РѕР± РѕС€РёР±РєРµ
                if (isAuthenticated) {
                    putInQueue(new ClientDir(messageId++, sessionId, null));
                } else {
                    showAlert("Incorrect password or login\nTry again");
                }
                break;
            case SSIGNUP:
                ServerSignupResponse respSignup = (ServerSignupResponse) response;
                if (!respSignup.isStatus()) {
                    showAlert(respSignup.getMessage());
                }
                hlSignup.setDisable(respSignup.isStatus());
                break;
            case SALERT:
                showAlert(((ServerAlertResponse) response).getMessage());
                break;
            case SDELETE:
                ServerDelResponse respDel = (ServerDelResponse) response;
                if (respDel.getUpdatedFileList().length != 0) {
                    tableCloud.setItems(fileProvider.getStorageModel(respDel.getUpdatedFileList()));
                }
                break;
            case SPUT_FINISH:
                ServerPutFinishedResponse respPut = (ServerPutFinishedResponse) response;
                if (respPut.getUpdatedFileList().length != 0) {
                    tableCloud.setItems(fileProvider.getStorageModel(respPut.getUpdatedFileList()));
                }

                break;
            default:
                dp(this, "renderResponse. Unknown server message");
        }
    }

    @Override
    public ClientMessage dequeueMessage() {
        ClientMessage message = null;
        try {
            message = queue.take();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        return message;
    }

    @Override
    public void updateLocalStoreView() {
        tableLocal.setItems(fileProvider.getStorageModel(LOCAL_STORAGE));
    }

    @Override
    public void updateRemoteStoreView() {
        putInQueue(new ClientDir(messageId++, sessionId, null));
    }

    @Override
    public void startProgressView() {
        try {
            Stage stage = new Stage();
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/progress_window.fxml"));
            Parent root = loader.load();
//            stage.initStyle(StageStyle.UNDECORATED);
            stage.initStyle(StageStyle.TRANSPARENT);
            progressView = (ProgressView) loader.getController();
            progressView.setWidth();
            updateProgressView(0.0);

            stage.setScene(new Scene(root, 300, 50));
            stage.initModality(Modality.APPLICATION_MODAL);
            stage.show();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void stopProgressView() {
        if (progressView != null) {
            progressView.close();
        }
        progressView = null;
    }

    @Override
    public void updateProgressView(Double progress) {
        if (progressView != null) progressView.update(progress);
    }

    /**
     * TODO: РћС‚РїСЂР°РІРєР° Р»РѕРіРёРЅР°/РїР°СЂРѕР»СЏ РЅР° СЃРµСЂРІРµСЂ
     */
    public void signInCustomer(Customer customer) {
        putInQueue(new ClientAuth(messageId++, null, customer));
    }

    /**
     * TODO: Р РµРіРёСЃС‚СЂР°С†РёСЏ
     */
    public void signUpCustomer(Customer customer) {
        putInQueue(new ClientSignup(messageId++, customer));
    }

    /**
     * TODO: РћСЃС‚Р°РЅРѕРІРєР° РїРѕС‚РѕРєР° РѕР±СЂР°Р±РѕС‚РєРё СЃРµС‚РµРІС‹С… СЃРѕРѕР±С‰РµРЅРёР№.
     */
    public void stop() {
        putInQueue(new ClientBye(messageId++, sessionId, "Bye"));
    }

    /**
     * TODO: РЎРѕС…СЂР°РЅРёС‚СЊ Р°СЂРіСѓРјРµРЅС‚С‹ РєРѕРјР°РЅРґРЅРѕР№ СЃС‚СЂРѕРєРё
     */
    public void setArgs(List<String> args) {
        commandArgs = args;
    }

    /**
     * TODO: РџРѕРјРµСЃС‚РёС‚СЊ СЃРѕРѕР±С‰РµРЅРёРµ РІ РѕС‡РµСЂРµРґСЊ РѕС‚РїСЂР°РІРєРё
     */
    private void putInQueue(ClientMessage message) {
        try {
            queue.put(message);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    // TODO: РЎРѕРѕР±С‰РµРЅРёРµ РѕР± РѕС€РёР±РєРµ
    private void showAlert(String message) {
        Alert alert = new Alert(Alert.AlertType.ERROR, message, ButtonType.CLOSE);
        alert.showAndWait();
    }
}
package controllers;


public class ProgressView {
    @FXML
    HBox globParent;

    @FXML
    ProgressBar progressBar;

    public void setWidth() {
        progressBar.setPrefWidth(250);
    }
    public void update(Double progress) {
        progressBar.setProgress(progress);
    }
    public void close() {
        globParent.getScene().getWindow().hide();
    }
}
package controllers;


public class SignUpController {

    @FXML
    TextField login;

    @FXML
    PasswordField password1;

    @FXML
    PasswordField password2;

    @FXML
    VBox globParent;

    public MainController backController;
    public int id;

    @FXML
    public void signUp(ActionEvent actionEvent) {

        if(password1.getText().equals(password2.getText())) {
            backController.signUpCustomer(new Customer(login.getText(), password1.getText()));
        } else {
            System.out.println("Passwords are not equal");
        }

        globParent.getScene().getWindow().hide();
    }
}
/**
 * Materials:
 * https://www.mkyong.com/java/java-how-to-list-all-files-in-a-directory/
 * https://dzone.com/articles/building-simple-data-access-layer-using-jdbc
 *
 * NIO:
 * http://tutorials.jenkov.com/java-nio/overview.html
 * https://www.baeldung.com/java-nio-selector
 * https://www.baeldung.com/java-nio-2-async-channels
 *
 * Streams:
 * https://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/
 */




public class MainClient extends Application {

    MainController mainController;

    @Override
    public void start(Stage primaryStage) throws Exception{
        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getClassLoader().getResource("main_window.fxml"));
        Parent root = fxmlLoader.load();
        mainController = fxmlLoader.getController();
        dp(this, "start. " + getParameters().getRaw().size());

//        mainController.setArgs(getParameters().getRaw());
//        dp(this, "start. " + getParameters().getRaw().size());
        primaryStage.setTitle("CloudStore client");
        primaryStage.setScene(new Scene(root, 800, 500));
        primaryStage.show();
    }

    @Override
    public void stop(){
        if(mainController != null) {
            mainController.stop();
        }
    }

    public static void main(String[] args) {
        launch(args);
    }
}
package network;




public class CloudClient implements Runnable {

    private static SocketChannel channel;
    private AtomicBoolean isRunning;
    private String currentDir;
    private MainView view;
    private final long block_size;

    public CloudClient(InetSocketAddress inetAddress, MainView view, String currentDir) throws IOException {
        channel = SocketChannel.open(inetAddress);
        this.isRunning = new AtomicBoolean();
        this.isRunning.set(true);
        this.currentDir = currentDir;
        this.block_size = 16384;
        this.view = view;
        new Thread(this).start();
    }

    @Override
    public void run() {
        do {
            // TODO: РћС‡РµСЂРµРґРЅР°СЏ РєРѕРјР°РЅРґР° РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ
            ClientMessage message = view.dequeueMessage();
            dp(this, "run. Dequeued message " + message);

            if (message.getRequest() == ClientRequest.BYE) {
                isRunning.compareAndSet(true, false);
                // TODO: РР·РІРµСЃС‚РёС‚СЊ СЃРµСЂРІРµСЂ, РµСЃР»Рё СЃРµСЃСЃРёСЏ РІР°Р»РёРґРЅР°
                if (message.getSessionId() != null) {
                    Exchanger.send(channel, message);
                }
            } else {
                boolean result = handleCommand(message);
                isRunning.set(result);
            }
        } while (isRunning.get());

        try {
            channel.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * TODO: РћС‚РїСЂР°РІРєР° РєРѕРјР°РЅРґ РєР»РёРµРЅС‚Р° Рё РїСЂРёРµРј РѕС‚РІРµС‚РѕРІ СЃРµСЂРІРµСЂР°
     */
    public boolean handleCommand(ClientMessage command) {
        ServerMessage response = null;
        long lastCommandId = command.getId();

        dp(this, "handleCommand. Sending command " + command);

        // TODO: РћС‚РїСЂР°РІРёС‚СЊ РєРѕРјР°РЅРґСѓ
        Exchanger.send(channel, command);

        // TODO: РџРѕР»СѓС‡РёС‚СЊ РѕС‚РІРµС‚
        try {
            response = (ServerMessage) Exchanger.receive(channel);
        } catch (RemoteHostDisconnected e) {
            dp(this, "handleCommand. Server has crashed.");
            return false;
        }

        if (response.getId() != lastCommandId) {
            dp(this, "handleCommand. Incorrect response sequence number");
            return false;
        }

        switch (response.getResponse()) {
            case SGET:
                boolean isValidFileLength = ((ServerGetResponse)response).getLength() != -1;

                if(isValidFileLength) {
                    receiveFile(currentDir,
                            ((ServerGetResponse) response).getFileName(),
                            ((ServerGetResponse) response).getLength());
                    callInMainThread(view::updateLocalStoreView);
                }
                break;
            case SPUT_READY:
                sendFile(Paths.get(currentDir, ((ServerPutReadyResponse) response).getFileName()), ((ServerPutReadyResponse) response).getLength());
                try {
                    response = (ServerMessage) Exchanger.receive(channel);
                } catch (RemoteHostDisconnected e) {
                    dp(this, "handleCommand. Server has crashed.");
                    return false;
                }

            default: {
                // TODO: РћС‚РѕР±СЂР°Р·РёС‚СЊ СЂРµР·СѓР»СЊС‚Р°С‚ РІ РїРѕС‚РѕРєРµ РѕСЃРЅРѕРІРЅРѕРіРѕ РѕРєРЅР°
                if (response != null && isRunning.get()) {
                    callInMainThread(view::renderResponse, response);
                }
            }
        }
        return true;
    }

    /**
     * TODO: Р’С‹РїРѕР»РЅРёС‚СЊ Р·Р°РіСЂСѓР·РєСѓ. Р•СЃР»Рё С„Р°Р№Р» СЃСѓС‰РµСЃС‚РІСѓРµС‚, С‚Рѕ Р±СѓРґРµС‚ РїРµСЂРµР·Р°РїРёСЃР°РЅ.
     * Р¤Р°Р№Р» РїСЂРёРЅРёРјР°РµС‚СЃСЏ Р±Р»РѕРєР°РјРё СЂР°Р·РјРµСЂРѕРј block_size. Р”Р»СЏ РїСЂРёРµРјР° РїРѕСЃР»РµРґРЅРµРіРѕ Р±Р»РѕРєР°,
     * РєРѕС‚РѕСЂС‹Р№ РЅРµ СЂР°РІРµРЅ block_size РЅСѓР¶РЅРѕ СѓСЃС‚Р°РЅРѕРІРёС‚СЊ С‚РѕС‡РЅС‹Р№ СЂР°Р·РјРµСЂ.
     */
    private void receiveFile(String dirTo, String destFileName, long length) {
        try (FileOutputStream fos = new FileOutputStream(Paths.get(dirTo, destFileName).toString());
             FileChannel toChannel = fos.getChannel()) {

            callInMainThread(view::startProgressView);

            long received = 0;

            dp(this, "receiveFile. Ready to receive " + length);
            do {
                received += toChannel.transferFrom(channel, received, length - received >= block_size ? block_size : length - received);

                final double progress = ((double) received) / (double) (length);
                callInMainThread(view::updateProgressView, progress);

            } while (received < length);

            toChannel.force(false);
            dp(this, "receiveFile. Bytes received = " + received);

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            callInMainThread(view::stopProgressView);
        }
    }

    /**
     * TODO: РћС‚РїСЂР°РІРєР°
     */
    private void sendFile(Path path, long length) {

        try (FileInputStream fis = new FileInputStream(path.toString());
             FileChannel fromChannel = fis.getChannel()) {

            callInMainThread(view::startProgressView);

            long sent = 0;

            dp(this, "sendFile. Source file length is " + length);

            // TODO: РџРµСЂРµРґР°С‚СЊ С„Р°Р№Р» Р±Р»РѕРєР°РјРё block_size
            do {
                long count = length - sent > block_size ? block_size : length - sent;
                sent += fromChannel.transferTo(sent, count, channel);

                final double progress = ((double) sent) / (double) (length);
                callInMainThread(view::updateProgressView, progress);

            } while (sent < length);

            dp(this, "sendFile. Bytes sent " + sent);

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            callInMainThread(view::stopProgressView);
        }
    }

    /**
     * TODO: Р’С‹РїРѕР»РЅРµРЅРёРµ РєРѕРґР° РІ РїРѕС‚РѕРєРµ FX
     */
    private <T> void callInMainThread(Consumer<T> op, T arg) {
        Platform.runLater(() -> {
            op.accept(arg);
        });
    }

    private void callInMainThread(Runnable op) {
        Platform.runLater(() -> {
            op.run();
        });
    }
}
package network;


public interface MainView {
    void renderResponse(ServerMessage message);
    void updateLocalStoreView();
    void updateRemoteStoreView();
    void startProgressView();
    void stopProgressView();
    void updateProgressView(Double progress);

    ClientMessage dequeueMessage();
}
package conversation;


public abstract class ClientMessage implements Serializable {
    static final long serialVersionUID = 100L;
    private final ClientRequest request;
    private long id;
    private SessionId sessionId;

    public ClientMessage(long id, SessionId sessionId, ClientRequest request) {
        this.request = request;
        this.sessionId = sessionId;
        this.id = id;
    }

    public ClientRequest getRequest() {
        return request;
    }
    public long getId() {
        return id;
    }
    public SessionId getSessionId() {
        return sessionId;
    }
}
package conversation;

public enum ClientRequest {
    AUTH, SIGNUP, DIR, DELETE, RENAME, PUT, GET, BYE
}
/**
 * Materials:
 * https://stackoverflow.com/questions/5862971/java-readobject-with-nio
 */

package conversation;



public class Exchanger {

    /**
     * TODO: РћС‚РїСЂР°РІРёС‚СЊ СЃРѕРѕР±С‰РµРЅРёРµ
     */
    public static void send(SocketChannel channel, Serializable serializable) {

        // TODO: РЎСЂР°Р·Сѓ Р¶Рµ СЃРѕР·РґР°РµС‚ Р±Р°Р№С‚РѕРІС‹Р№ РјР°СЃСЃРёРІ
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        // TODO: РџРµСЂРІС‹Рµ 4 Р±Р°Р№С‚Р° Р±СѓРґСѓС‚ РїРѕР»РµРј length. РћР±РЅСѓР»СЏРµРј.
        for (int i = 0; i < 4; i++) {
            baos.write(0);
        }

        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {

            // TODO: РЎРµСЂРёР°Р»РёР·СѓРµРј РІ РјР°СЃСЃРёРІ
            oos.writeObject(serializable);

            // TODO: РџРµСЂРµРІРѕРґРёРј РјР°СЃСЃРёРІ РІ Р±СѓС„РµСЂ
            ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());
            buffer.putInt(0, baos.size() - 4);
            channel.write(buffer);

        } catch (IOException e) {e.printStackTrace();}
    }

    /**
     * TODO: РџРѕР»СѓС‡РёС‚СЊ Рё СЂР°СЃРїР°РєРѕРІР°С‚СЊ
     */
    public static Serializable receive(SocketChannel socket) throws RemoteHostDisconnected {

        ByteBuffer lengthByteBuffer = ByteBuffer.wrap(new byte[4]);
        ByteBuffer dataByteBuffer;
        Serializable message = null;
        int bytesRead, messageLength;

        try {
            // TODO: РџСЂРѕС‡РёС‚Р°С‚СЊ РґР»РёРЅСѓ СЃРѕРѕР±С‰РµРЅРёСЏ
            bytesRead = socket.read(lengthByteBuffer);

            if(bytesRead == -1) {
                System.out.println("Exchanger:receive(): Remote host " + socket.getRemoteAddress().toString() + " closed connection");
                throw new RemoteHostDisconnected();
            }

            if (lengthByteBuffer.remaining() == 0 && lengthByteBuffer.getInt(0) > 0) {
                messageLength = lengthByteBuffer.getInt(0);
                dataByteBuffer = ByteBuffer.allocate(messageLength);

                // TODO: РџСЂРѕС‡РёС‚Р°С‚СЊ РІСЃРµ РѕСЃС‚Р°Р»СЊРЅРѕРµ СЃРѕРѕР±С‰РµРЅРёРµ
                bytesRead = socket.read(dataByteBuffer);
                if (dataByteBuffer.remaining() == 0 && bytesRead == messageLength) {
                    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(dataByteBuffer.array()));
                    message = (Serializable) ois.readObject();
                }
            }
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }

        return message;
    }
}
package conversation.protocol;


public class ClientAuth extends ClientMessage {
    static final long serialVersionUID = 101L;
    private Customer customer;

    public ClientAuth(long id, SessionId sessionId, Customer customer) {
        super(id, sessionId, ClientRequest.AUTH);
        this.customer = customer;
    }

    @Override
    public ClientRequest getRequest() {
        return super.getRequest();
    }

    @Override
    public long getId() {
        return super.getId();
    }

    public Customer getCustomer() {
        return customer;
    }
}
package conversation.protocol;


public class ClientBye extends ClientMessage {
    static final long serialVersionUID = 101L;
    private String message;

    public ClientBye(long id, SessionId sessionId, String message) {
        super(id, sessionId, ClientRequest.BYE);
        this.message = message;
    }

    public String getMessage() {
        return message;
    }
}
package conversation.protocol;


public class ClientDelFile extends ClientMessage {
    static final long serialVersionUID = 101L;
    private String fileName;

    public ClientDelFile(long id, SessionId sessionId, String fileName) {
        super(id, sessionId, ClientRequest.DELETE);
        this.fileName = fileName;
    }

    public String getFileName() {
        return fileName;
    }
}
package conversation.protocol;


public class ClientDir extends ClientMessage {
    static final long serialVersionUID = 101L;
    private String target;

    public ClientDir(long id, SessionId sessionId, String target) {
        super(id, sessionId, ClientRequest.DIR);
        this.target = target;
    }

    public String getTarget() {
        return target;
    }
}
package conversation.protocol;


public class ClientGet extends ClientMessage {
    static final long serialVersionUID = 101L;
    private String fileName;

    public ClientGet(long id, SessionId sessionId, String fileName) {
        super(id, sessionId, ClientRequest.GET);
        this.fileName = fileName;
    }

    public String getFileName() {
        return fileName;
    }
}
package conversation.protocol;


public class ClientPut extends ClientMessage {
    static final long serialVersionUID = 101L;
    private String fileName;
    private long length;

    public ClientPut(long id, SessionId sessionId, String fileName, long length) {
        super(id, sessionId, ClientRequest.PUT);
        this.fileName = fileName;
        this.length = length;
    }

    public String getFileName() {
        return fileName;
    }

    public long getLength() {
        return length;
    }
}
package conversation.protocol;


public class ClientSignup extends ClientMessage {
    static final long serialVersionUID = 101L;
    private Customer customer;

    public ClientSignup(long id, Customer customer) {
        super(id, null, ClientRequest.SIGNUP);
        this.customer = customer;
    }

    public Customer getCustomer() {
        return customer;
    }
}
package conversation.protocol;


public class ServerAlertResponse extends ServerMessage {

    private String message;

    public ServerAlertResponse(long id, String message) {
        super(id, ServerResponse.SALERT);
        this.message = message;
    }

    public String getMessage() {
        return message;
    }
}
package conversation.protocol;


public class ServerAuthResponse extends ServerMessage {
    static final long serialVersionUID = 101L;

    private boolean isAuth;
    private SessionId sessionId;

    public ServerAuthResponse(long id, boolean isAuth, SessionId sessionId) {
        super(id, ServerResponse.SAUTH);
        this.isAuth = isAuth;
        this.sessionId = sessionId;
    }

    public boolean isAuth() {
        return isAuth;
    }

    public SessionId getSessionId() {
        return sessionId;
    }
}
package conversation.protocol;


public class ServerDelResponse extends ServerMessage {
    static final long serialVersionUID = 101L;
    private FileDescriptor[] updatedFileList;
    private boolean status;

    public ServerDelResponse(long id, boolean status, FileDescriptor[] updatedFileList) {
        super(id, ServerResponse.SDELETE);
        this.updatedFileList = updatedFileList;
        this.status = status;
    }

    public FileDescriptor[] getUpdatedFileList() {
        return updatedFileList;
    }

    public boolean isStatus() {
        return status;
    }
}
package conversation.protocol;


public class ServerDirResponse extends ServerMessage {
    static final long serialVersionUID = 101L;
    private FileDescriptor[] files;

    public ServerDirResponse(long id, FileDescriptor[] files) {
        super(id, ServerResponse.SDIR);
        this.files = files;
    }

    public FileDescriptor[] getFiles() {
        return files;
    }
}
package conversation.protocol;


public class ServerGetResponse extends ServerMessage {
    private String fileName;
    private long length;

    public ServerGetResponse(long id, String fileName, long length) {
        super(id, ServerResponse.SGET);
        this.fileName = fileName;
        this.length = length;
    }

    public String getFileName() {
        return fileName;
    }
    public long getLength() {
        return length;
    }
}
package conversation.protocol;


public class ServerPutFinishedResponse extends ServerMessage {
    static final long serialVersionUID = 101L;
    private FileDescriptor[] updatedFileList;

    public ServerPutFinishedResponse(long id, FileDescriptor[] updatedFileList) {
        super(id, ServerResponse.SPUT_FINISH);
        this.updatedFileList = updatedFileList;
    }

    public FileDescriptor[] getUpdatedFileList() {
        return updatedFileList;
    }

}
package conversation.protocol;


public class ServerPutReadyResponse extends ServerMessage {
    static final long serialVersionUID = 101L;
    private String fileName;
    private long length;

    public ServerPutReadyResponse(long id, String fileName, long length) {
        super(id, ServerResponse.SPUT_READY);
        this.fileName = fileName;
        this.length = length;
    }

    public String getFileName() {
        return fileName;
    }

    public long getLength() {
        return length;
    }
}
package conversation.protocol;


public class ServerSignupResponse extends ServerMessage {
    static final long serialVersionUID = 101L;

    private String message;
    private boolean status;

    public ServerSignupResponse(long id, boolean status, String message) {
        super(id, ServerResponse.SSIGNUP);
        this.status = status;
        this.message = message;
    }

    public boolean isStatus() {
        return status;
    }

    public String getMessage() {
        return message;
    }
}
package conversation;


public abstract class ServerMessage implements Serializable {
    static final long serialVersionUID = 100L;
    private ServerResponse response;
    private long id;

    public ServerMessage(long id, ServerResponse response) {
        this.response = response;
        this.id = id;
    }

    public ServerResponse getResponse() {
        return response;
    }

    public long getId() {
        return id;
    }
}
package conversation;

public enum ServerResponse {
    SAUTH, SSIGNUP, SDIR, SDELETE, SRENAME, SPUT_READY, SPUT_FINISH, SGET, SBYE, SALERT
}
package conversation;


public class SessionId implements Serializable {
    private int id;

    public SessionId(int id) {
        this.id = id;
    }

    public int getId() {
        return id;
    }

    public String toString() {
        return String.format("%d", id);
    }

    /**
     * TODO: РџРµСЂРµРѕРїСЂРµРґРµР»РµРЅРёРµ РјРµС‚РѕРґРѕРІ equals Рё hashCode
     * TODO: РўСЂРµР±СѓРµС‚СЃСЏ РїРѕС‚РѕРјСѓ, С‡С‚Рѕ SessionID РёСЃРїРѕР»СЊР·СѓРµС‚СЃСЏ РєР°Рє key РІ HashMap
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        SessionId s = (SessionId) o;
        return this.id == s.id;
    }

    @Override
    public int hashCode() {
        return id ^ 0xabbadead;
    }

}
package data.dao;



public interface CustomerDao {
    Set<Customer> getAllCustomer();
    Customer getCustomerById(int id);
    Customer getCustomerByLogin(String login);
    Customer getCustomerByLoginAndPass(String login, String pass);
    boolean exists(Customer customer);
    boolean insertCustomer(Customer customer);
    boolean updateCustomer(Customer customer);
    boolean deleteCustomer(int id);
}
package data.provider;



public class FileProvider {

    public FileProvider() {
    }

    /**
     * TODO: РџРѕР»СѓС‡РёС‚СЊ РєРѕРЅС‚РµРЅС‚ РґР»СЏ С‚Р°Р±Р»РёС‡РЅРѕРіРѕ РѕС‚РѕР±СЂР°Р¶РµРЅРёСЏ
     */
    public ObservableList<FileDescriptor> getStorageModel(FileDescriptor[] files) {
        ObservableList<FileDescriptor> storageModel = FXCollections.observableArrayList();
        prepareObservableList(storageModel, files);
        return storageModel;
    }

    /**
     * TODO: РџРѕР»СѓС‡РёС‚СЊ РєРѕРЅС‚РµРЅС‚ РґР»СЏ С‚Р°Р±Р»РёС‡РЅРѕРіРѕ РѕС‚РѕР±СЂР°Р¶РµРЅРёСЏ
     */
    public ObservableList<FileDescriptor> getStorageModel(String storagePath) {
        ObservableList<FileDescriptor> storageModel = FXCollections.observableArrayList();
        prepareObservableList(storageModel, collectFiles(storagePath));
        return storageModel;
    }

    /**
     * TODO: РџРѕР»СѓС‡РёС‚СЊ СЃРїРёСЃРѕРє С„Р°Р№Р»РѕРІ
     */
    public FileDescriptor[] collectFiles(String path){
        return collectFiles(Paths.get(path));
    }

    public FileDescriptor[] collectFiles(Path path){
        return FileHelper.listFiles(path)
                .stream()
                .map(f -> new FileDescriptor(f.getName(), f.length()))
                .toArray(FileDescriptor[] ::new);
    }

    /**
     * TODO: РЎРѕР·РґР°С‚СЊ С„Р°Р№Р»
     */
    public Path createFile(Path filePath) {
        return FileHelper.createFile(filePath);
    }

    /**
     * TODO: РЎРѕР·РґР°С‚СЊ РєР°С‚Р°Р»РѕРі
     */
    public boolean createDirectory(Path targetDir) {
        return FileHelper.createDirectory(targetDir);
    }

    /**
     * TODO: РЈРґР°Р»РёС‚СЊ С„Р°Р№Р»
     */
    public boolean deleteFile(Path path) {
        return FileHelper.deleteFile(path);
    }

    /**
     * TODO: CРѕРґРµСЂР¶РёРјРѕРµ СЃС‚СЂРѕРє С‚Р°Р±Р»РёС†С‹
     */
    public static <T> void prepareObservableList(ObservableList<T> list, T[] elements) {
        list.removeAll();
        for (T e : elements) {
            list.add(e);
        }
    }
}
/**
 * Materials:
 * https://dzone.com/articles/building-simple-data-access-layer-using-jdbc
 */

package data.provider;



public class JdbcProvider implements CustomerDao {

    public JdbcProvider() {
    }

    @Override
    public Set<Customer> getAllCustomer() {
        return null;
    }

    @Override
    public boolean exists(Customer customer) {
        return getCustomerByLogin(customer.getLogin()) != null;
    }

    @Override
    public Customer getCustomerById(int id) {
        try {
            Connection connection = ConnectionHolder.getConnection();
            Statement statement = connection.createStatement();
            ResultSet rs = statement.executeQuery("SELECT * FROM customer WHERE id='" + id + "';");

            if (rs.next()) {
                return extractCustomer(rs);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    public Customer getCustomerByLogin(String login) {
        try {
            Connection connection = ConnectionHolder.getConnection();
            Statement statement = connection.createStatement();
            ResultSet rs = statement.executeQuery("SELECT * FROM customer WHERE login='" + login + "';");
            if (rs.next()) {
                return extractCustomer(rs);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    @Override
    public Customer getCustomerByLoginAndPass(String login, String pass) {
        try {
            Connection connection = ConnectionHolder.getConnection();
            PreparedStatement ps = connection.prepareStatement("SELECT * FROM customer WHERE login=? AND pass=?");
            ps.setString(1, login);
            ps.setString(2, pass);
            ResultSet rs = ps.executeQuery();
            if (rs.next()) {
                return extractCustomer(rs);

            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    @Override
    public boolean insertCustomer(Customer customer) {
        if(exists(customer)) {
            dp(this, "insertCustomer. Customer " + customer.getLogin() + " already exists");
            return false;
        }

        try {
            Connection connection = ConnectionHolder.getConnection();
            PreparedStatement ps = connection.prepareStatement("INSERT INTO customer VALUES (NULL, ?, ?)");
            ps.setString(1, customer.getLogin());
            ps.setString(2, customer.getPass());

            int i = ps.executeUpdate();
            if (i == 1) {
                return true;
            }
        } catch (SQLException ex) {
            ex.printStackTrace();
        }

        return false;
    }

    @Override
    public boolean updateCustomer(Customer customer) {
        try {
            Connection connection = ConnectionHolder.getConnection();
            PreparedStatement ps = connection.prepareStatement("UPDATE customer SET login=?, pass=? WHERE id=?");
            ps.setString(1, customer.getLogin());
            ps.setString(2, customer.getPass());
            ps.setInt(3, customer.getId());

            int i = ps.executeUpdate();
            if (i == 1) {
                return true;
            }
        } catch (SQLException ex) {
            ex.printStackTrace();
        }
        return false;
    }

    @Override
    public boolean deleteCustomer(int id) {
        try {
            Connection connection = ConnectionHolder.getConnection();
            Statement statement = connection.createStatement();
            int i = statement.executeUpdate("DELETE FROM customer WHERE id='" + id + "';");
            if(i == 1) {
                return true;
            }
        } catch (SQLException ex) {
            ex.printStackTrace();
        }
        return false;
    }

    private Customer extractCustomer(ResultSet rs) throws SQLException {
        Customer customer = new Customer();
        customer.setId(rs.getInt("id"));
        customer.setLogin(rs.getString("login"));
        customer.setPass(rs.getString("pass"));
        return customer;
    }
}
package data.repository.file;


public class FileHelper {

    /**
     * TODO: РџРѕР»СѓС‡РёС‚СЊ СЃРїРёСЃРѕРє С„Р°Р№Р»РѕРІ РІ РїР°РїРєРµ path
     */
    public static List<File> listFiles(String path) {
        return listFiles(Paths.get(path));
    }

    /**
     * TODO: РџРѕР»СѓС‡РёС‚СЊ СЃРїРёСЃРѕРє С„Р°Р№Р»РѕРІ РІ РїР°РїРєРµ path
     */
    public static List<File> listFiles(Path path) {
        List<File> result = null;

        try (Stream<Path> walk = Files.walk(path)) {
            result = walk.filter(Files::isRegularFile)
                    .map(p -> p.toFile())
                    .collect(Collectors.toList());
        } catch (IOException e) {
            e.printStackTrace();
        }

        return result;
    }

    /**
     * TODO: РЎРѕР·РґР°С‚СЊ С„Р°Р№Р» (РїРѕРєР° Р±РµР· Р°С‚СЂРёР±СѓС‚РѕРІ)
     */
    public static Path createFile(Path filePath) {
        if(!Files.exists(filePath)) {
            try {
                return Files.createFile(filePath);
            } catch (IOException e) {e.printStackTrace();}
        }
        return null;
    }

    /**
     * TODO: РЎРѕР·РґР°С‚СЊ РєР°С‚Р°Р»РѕРі
     */
    public static boolean createDirectory(Path targetDir) {
        boolean result = false;
        if(!Files.exists(targetDir)) {
            try {
                Files.createDirectories(targetDir);
                result = true;
            } catch (IOException e) {e.getStackTrace();}

        } else {
            System.out.println("Directory " + targetDir.toString() + " already exists");
        }
        return result;
    }

    /**
     * TODO: РЈРґР°Р»РёС‚СЊ, РµСЃР»Рё СЃСѓС‰РµСЃС‚РІСѓРµС‚
     */
    public static boolean deleteFile(Path path) {
        try {
            return Files.deleteIfExists(path);
        } catch (IOException e) {e.printStackTrace();}

        return false;
    }
}
package data.repository.jdbc;


public class JdbcRepository {

    private final String JDBC_URL = "jdbc:sqlite:cloudstore.db";
    private final String JDBC_CLASS = "org.sqlite.JDBC";

    private Connection connection;

    private JdbcRepository() {
        try {
            Class.forName(JDBC_CLASS);
            connection = DriverManager.getConnection(JDBC_URL);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static class ConnectionHolder {
        private static final JdbcRepository jdbc = new JdbcRepository();

        public static Connection getConnection() {
            return jdbc.connection;
        }
    }

    // РћС‚РєР»СЋС‡РёС‚СЊСЃСЏ РѕС‚ Р±Р°Р·С‹
    public void disconnect() {
        try {
            connection.close();
        } catch (Exception e) {e.printStackTrace();}
    }
}
package domain;


public class Customer implements Serializable {
    private int id;
    private String login;
    private String pass;

    public Customer() {
    }

    public Customer(String login, String pass) {
        this.login = login;
        this.pass = pass;
    }

    public Customer(int id, String login, String pass) {
        this.id = id;
        this.login = login;
        this.pass = pass;
    }

    public int getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getLogin() {
        return login;
    }
    public void setLogin(String login) {
        this.login = login;
    }
    public String getPass() {
        return pass;
    }
    public void setPass(String pass) {
        this.pass = pass;
    }
}

package domain;


public class FileDescriptor implements Serializable {
    static final long serialVersionUID = 100L;
    private String fileName;
    private long fileSize;

    public FileDescriptor(String fileName, long fileSize) {
        this.fileName = fileName;
        this.fileSize = fileSize;
    }

    public String getFileName() {
        return fileName;
    }

    public long getFileSize() {
        return fileSize;
    }
}
package domain;




public class Session {
    private SessionId sessionId;
    private Customer customer;
    private Path currentDir;

    public Session(SessionId sessionId, Customer customer, Path currentDir) {
        this.sessionId = sessionId;
        this.customer = customer;
        this.currentDir = currentDir;
    }

    public SessionId getSessionId() {
        return sessionId;
    }

    public Customer getCustomer() {
        return customer;
    }

    public Path getCurrentDir() {
        return currentDir;
    }
}
package exception;

public class RemoteHostDisconnected extends Exception {
}
package utils;


public class Debug {
    public static void dp(Object o, String message) {
        System.out.println("debug: Thread#" + Thread.currentThread().getId() + " [" + o.getClass().getSimpleName() + "::" + message + "]");
    }
}
package controller;



public class CommandController {

    private FileProvider fileProvider;
    private CloudServer server;
    private String storageRoot;

    public CommandController(CloudServer server, FileProvider fileProvider, String storageRoot) {
        this.server = server;
        this.fileProvider = fileProvider;
        this.storageRoot = storageRoot;
    }

    public ServerDirResponse commandDir(ClientDir clientMessage, Session session){
        Path path = clientMessage.getTarget() == null ? session.getCurrentDir() : Paths.get(session.getCurrentDir().toString(), clientMessage.getTarget());
        ServerDirResponse response = new ServerDirResponse(clientMessage.getId(), fileProvider.collectFiles(path));
        return response;
    }

    public ServerDelResponse commandDel(ClientDelFile clientMessage, Session session){
        boolean isDeleted = fileProvider.deleteFile(Paths.get(session.getCurrentDir().toString(), clientMessage.getFileName()));
        return new ServerDelResponse(clientMessage.getId(), isDeleted, fileProvider.collectFiles(session.getCurrentDir()));
    }

    public ServerGetResponse  commandGet(ClientGet clientMessage, Session session) {
        long length = -1;
        Path path = Paths.get(session.getCurrentDir().toString(), clientMessage.getFileName());
        try {
            length = Files.size(path);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return new ServerGetResponse(clientMessage.getId(), clientMessage.getFileName(), length);
    }

    public ServerPutReadyResponse commandPutReady(ClientPut clientMessage, Session session) {
        return new ServerPutReadyResponse(clientMessage.getId(), clientMessage.getFileName(), clientMessage.getLength());
    }

    public ServerPutFinishedResponse commandPutFinished(ClientPut clientMessage, Session session) {
        return new ServerPutFinishedResponse(clientMessage.getId(), fileProvider.collectFiles(session.getCurrentDir()));
    }
}


Р”РѕР±СЂС‹Р№ РґРµРЅСЊ, РђР»РµРєСЃР°РЅРґСЂ !
РџРѕРґРіРѕС‚РѕРІРёР» Рє РїСЂРѕРІРµСЂРєРµ СЂР°Р±РѕС‡СѓСЋ РІРµСЂСЃРёСЋ РїСЂРѕРµРєС‚Р° РЅР° Р±Р°Р·Рµ NIO.

РљР»РёРµРЅС‚ СЂР°Р±РѕС‚Р°РµС‚ РІ 2 РїРѕС‚РѕРєР°: РѕСЃРЅРѕРІРЅРѕР№ - СЌС‚Рѕ GUI, РІС‚РѕСЂРѕР№ РІР·Р°РёРјРѕРґРµР№СЃС‚РІРёРµ СЃ СЃРµСЂРІРµСЂРѕРј (РѕС‚РїСЂР°РІРєР° РєРѕРјР°РЅРґ, РѕР±СЂР°Р±РѕС‚РєР° РѕС‚РІРµС‚РѕРІ Рё РѕР±РјРµРЅ С„Р°Р№Р»Р°РјРё).
РЎРµСЂРІРµСЂ: РІ РѕСЃРЅРѕРІРЅРѕРј РїРѕС‚РѕРєРµ СЂР°Р±РѕС‚Р°РµС‚ СЃРµР»РµРєС‚РѕСЂ (РѕР±СЂР°Р±РѕС‚РєР° РєРѕРјР°РЅРґ РєР»РёРµРЅС‚Р°), Р° РґРѕРїРѕР»РЅРёС‚РµР»СЊРЅС‹Рµ РїРѕС‚РѕРєРё СЃРѕР·РґР°СЋС‚СЃСЏ РґР»СЏ РѕРїРµСЂР°С†РёР№ РїСЂРёРµРјР°/РїРµСЂРµРґР°С‡Рё С„Р°Р№Р»РѕРІ. РќР° СЃС‚РѕСЂРѕРЅРµ СЃРµСЂРІРµСЂР° СЂРµР°Р»РёР·РѕРІР°РЅ СЃР»РµРґСѓСЋС‰РёР№ РјРµС…Р°РЅРёР·Рј: РєР»РµРЅС‚СЃРєРёР№ SocketChannel РѕР±СЃР»СѓР¶РёРІР°РµС‚СЃСЏ СЃРµР»РµРєС‚РѕСЂРѕРј РґР»СЏ РѕР±РјРµРЅР° СЃРѕРѕР±С‰РµРЅРёСЏРјРё. РљРѕРіРґР° РїРѕСЃС‚СѓРїР°РµС‚ РєРѕРјР°РЅРґР° РЅР° РїРµСЂРµРґР°С‡Сѓ С„Р°Р№Р»Р°, С‚Рѕ SocketChannel СѓРґР°Р»СЏРµС‚СЃСЏ РёР· СЃРµР»РµРєС‚РѕСЂР° Рё РїРµСЂРµРґР°РµС‚СЃСЏ РЅРѕРІРѕРјСѓ РїРѕС‚РѕРєСѓ, РєРѕС‚РѕСЂС‹Р№ Р·Р°РЅРёРјР°РµС‚СЃСЏ РїРµСЂРµРґР°С‡РµР№ С„Р°Р№Р»Р°. РџРѕСЃР»Рµ Р·Р°РІРµСЂС€РµРЅРёСЏ РѕРїРµСЂР°С†РёРё SocketChannel СЃРЅРѕРІР° СЂРµРіРёСЃС‚СЂРёСЂСѓРµС‚СЃСЏ РІ СЃРµР»РµРєС‚РѕСЂРµ.

РўР°РєР¶Рµ СЏ СЃРґРµР»Р°Р» progressbar, РїСЂРё РїРµСЂРµРґР°С‡Рµ РґР»РёРЅРЅС‹С… С„Р°Р№Р»РѕРІ РµРіРѕ С…РѕСЂРѕС€Рѕ РІРёРґРЅРѕ ) РќР° РјР°Р»РµРЅСЊРєРёС… РјРѕР¶РЅРѕ РЅРµ Р·Р°РјРµС‚РёС‚СЊ.

Р’РµСЃСЊ РїСЂРѕРµРєС‚ С‚СѓС‚: https://github.com/ciscoff/JCloud/tree/lesson2_dev_nio_final

public class MainServer {
    public static void main(String[] args) throws IOException {
        Thread server = new Thread(new CloudServer());
        server.start();

        try {
            server.join();
        } catch (InterruptedException e) {
            System.out.println("Server stopped");
        }
    }
}
package server;





public class CloudServer implements Runnable {
    public final String CLOUD_STORAGE = "remote_storage";
    private Map<SessionId, Session> activeClients;
    private CommandController controller;

    private ServerSocketChannel serverSocket;
    private Selector selector;

    private FileProvider fileProvider;
    private CustomerDao customerDao;
    private ReentrantLock registerLock;

    public CloudServer() throws IOException {
        this.selector = Selector.open();
        this.serverSocket = ServerSocketChannel.open();
        this.serverSocket.bind(new InetSocketAddress("localhost", 15454));
        this.serverSocket.configureBlocking(false);
        this.serverSocket.register(selector, SelectionKey.OP_ACCEPT);
        this.activeClients = new HashMap<>();
        this.registerLock = new ReentrantLock();

        // TODO: РџСЂРѕРІР°Р№РґРµСЂ Р»РѕРєР°Р»СЊРЅРѕРіРѕ С…СЂР°РЅРёР»РёС‰Р°
        fileProvider = new FileProvider();

        // TODO: РџСЂРѕРІР°Р№РґРµСЂ Рє С‚Р°Р±Р»РёС†Рµ Customer
        customerDao = new JdbcProvider();

        this.controller = new CommandController(this, fileProvider, CLOUD_STORAGE);
    }

    /**
     * https://bit.ly/2KZbpRm - РЅР° СЃС‡РµС‚ iter.remove()
     *
     */
    @Override
    public void run() {

        try {
            System.out.println("Server started on port 15454\n");
            Iterator<SelectionKey> iter;

            while (serverSocket.isOpen()) {

                // TODO: РЎРёРЅС…СЂРѕРЅРёР·Р°С†РёСЏ СЃ РјРµС‚РѕРґРѕРј attachToSelector()
                registerLock.lock();
                registerLock.unlock();

                int keysQty = selector.select(500);

                if(keysQty == 0){
                    continue;
                }
                else {
                    dp(this, "run. Keys selected " + keysQty);
                }

                Set<SelectionKey> selectedKeys = selector.selectedKeys();
                iter = selectedKeys.iterator();
                while (iter.hasNext()) {
                    SelectionKey key = iter.next();
                    iter.remove();

                    if (key.isAcceptable()) {
                        registerConnect(selector, serverSocket);
                    }
                    if (key.isReadable()) {
                        handleRequest(key);
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * TODO: РќРѕРІС‹Р№ СЃРµС‚РµРІРѕР№ РєРѕРЅРЅРµРєС‚ СЂРµРіРёСЃС‚СЂРёСЂСѓРµРј РІ СЃРµР»РµРєС‚РѕСЂРµ
     */
    private void registerConnect(Selector selector, ServerSocketChannel serverSocket) throws IOException {
        SocketChannel client = serverSocket.accept();
        if (client != null) {
            client.configureBlocking(false);
            client.register(selector, SelectionKey.OP_READ);
            dp(this, "registerConnect. Received a new connection from " + client.socket().getRemoteSocketAddress());
        }
    }

    /**
     * TODO: Р РµРіРёСЃС‚СЂР°С†РёСЏ РєР°РЅР°Р»Р° РІ СЃРµР»РµРєС‚РѕСЂРµ.
     * РњРµС‚РѕРґ РІС‹Р·С‹РІР°РµС‚СЃСЏ РёР· СЂР°Р·РЅС‹С… РїРѕС‚РѕРєРѕРІ (CloudServer, FileTransfer),
     * РїРѕСЌС‚РѕРјСѓ С‚СЂРµР±СѓРµС‚СЃСЏ РґРѕРїРѕР»РЅРёС‚РµР»СЊРЅР°СЏ СЃРёРЅС…СЂРѕРЅРёР·Р°С†РёСЏ (Р·РґРµСЃСЊ СЂРµР°Р»РёР·РѕРІР°РЅРѕ С‡РµСЂРµР· Lock)
     * https://bit.ly/2ULK9KM
     * https://bit.ly/2IxCTeW
     */
    private void attachToSelector(SocketChannel client) {
        if (client != null) {
            try {
                registerLock.lock();
                client.configureBlocking(false);
                client.register(selector, SelectionKey.OP_READ);
                dp(this, "attachToSelector. Attached " + client.toString());
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                registerLock.unlock();
            }
        }
    }

    /**
     * TODO: Р’С‹РїРѕР»РЅРёС‚СЊ РґРѕРїРѕР»РЅРёС‚РµР»СЊРЅС‹Рµ РґРµР№СЃС‚РІРёСЏ РїРѕСЃР»Рµ РїРµСЂРµРґР°С‡Рё С„Р°Р№Р»Р°
     */
    private void postFileTransferHandler(SocketChannel client, ClientMessage message) {
        attachToSelector(client);

        if(message.getRequest() == ClientRequest.PUT) {
            // TODO: РћС‚РїСЂР°РІРёС‚СЊ РєР»РёРµРЅС‚Сѓ РѕР±РЅРѕРІР»РµРЅРЅС‹Р№ СЃРїРёСЃРѕРє С„Р°Р№Р»РѕРІ РІ РїР°РїРєРµ
            Exchanger.send(
                    client,
                    controller.commandPutFinished((ClientPut) message, activeClients.get(message.getSessionId())));
        }
    }

    /**
     * TODO: РџСЂРёРµРј СЃРѕРѕР±С‰РµРЅРёР№ РѕС‚ РєР»РёРµРЅС‚РѕРІ
     */
    private void handleRequest(SelectionKey key) {
        SocketChannel clientChannel = (SocketChannel) key.channel();

        try {
            ClientMessage message = (ClientMessage) Exchanger.receive(clientChannel);

            if (message != null) {
                dp(this, "handleRequest. Received " + message.getRequest());
                switch (message.getRequest()) {
                    case AUTH:
                        ClientAuth authCommand = (ClientAuth) message;
                        SessionId sessionId = createSessionId(key);
                        Exchanger.send(clientChannel, new ServerAuthResponse(
                                message.getId(),
                                authenticateClient(authCommand.getCustomer(), sessionId),
                                sessionId));
                        break;
                    case SIGNUP:
                        ClientSignup cs = (ClientSignup) message;
                        Exchanger.send(clientChannel, signupClient(message.getId(), cs.getCustomer(), createSessionId(key)));
                        break;
                    default:
                        commandProcessor(key, message);
                }
            }
        } catch (RemoteHostDisconnected ex) {
            try {
                dp(this, "handleRequest. Client with sessionId  " + createSessionId(key).getId() + " disconnected");
                activeClients.remove(createSessionId(key));
                clientChannel.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * TODO: Р’Р·Р°РёРјРѕРґРµР№СЃС‚РІРёРµ СЃ РєР»РёРµРЅС‚РѕРј
     */
    private void commandProcessor(SelectionKey key, ClientMessage message) {
        SocketChannel clientChannel = (SocketChannel) key.channel();
        Session session = activeClients.get(message.getSessionId());

        // TODO: РђРІС‚РѕСЂРёР·Р°С†РёСЏ СЃРµСЃСЃРёРё
        if (session == null) {
            Exchanger.send(clientChannel, new ServerAlertResponse(message.getId(), "You should authenticate first"));
            return;
        }

        switch (message.getRequest()) {
            case DIR:
                Exchanger.send(clientChannel, controller.commandDir((ClientDir) message, session));
                break;
            case DELETE:
                Exchanger.send(clientChannel, controller.commandDel((ClientDelFile) message, session));
                break;
            case BYE:
                activeClients.remove(message.getSessionId());
                dp(this, String.format("Client terminated with message:'%s'", ((ClientBye) message).getMessage()));
                break;
            case GET:
                // TODO: Response READY + file length
                Exchanger.send(clientChannel, controller.commandGet((ClientGet) message, session));
                // TODO: Disconnect from selector
                key.cancel();
                // TODO: Send file in new thread
                new FileTransfer(clientChannel,
                        message,
                        Paths.get(session.getCurrentDir().toString(), ((ClientGet) message).getFileName()),
                        this::postFileTransferHandler);
                break;
            case PUT:
                // TODO: Response READY
                Exchanger.send(clientChannel, controller.commandPutReady((ClientPut) message, session));
                // TODO: Disconnect from selector
                key.cancel();
                dp(this, "commandProcessor. Ready to receive file with size " + ((ClientPut) message).getLength());
                // TODO: Receive file in new thread
                new FileTransfer(clientChannel,
                        message,
                        Paths.get(session.getCurrentDir().toString(), ((ClientPut) message).getFileName()),
                        ((ClientPut) message).getLength(),
                        this::postFileTransferHandler);
                break;
            default:
                dp(this, "commandProcessor. Unknown client message");
        }
    }

    /**
     * TODO: Client authentication
     */
    private boolean authenticateClient(Customer customer, SessionId sessionId) {

        if (isAuthenticated(sessionId)) {
            return true;
        } else if (customerDao.getCustomerByLoginAndPass(customer.getLogin(), customer.getPass()) != null) {
            activeClients.put(sessionId, new Session(sessionId, customer, Paths.get(CLOUD_STORAGE, customer.getLogin())));
            return true;
        }
        return false;
    }

    /**
     * TODO: РћРіСЂР°РЅРёС‡РµРЅРёСЏ РЅР° СЂРµРіРёСЃС‚СЂР°С†РёСЋ:
     * TODO:    - РєР»РёРµРЅС‚ РЅРµ РґРѕР»Р¶РµРЅ Р±С‹С‚СЊ Р°СѓС‚РµРЅС‚РёС„РёС†РёСЂРѕРІР°РЅ (sessionId == null),
     * TODO:    - РІ Р±Р°Р·Рµ РІСЃРµ Р»РѕРіРёРЅС‹ СѓРЅРёРєР°Р»СЊРЅС‹
     * TODO:    - ??
     */
    private ServerSignupResponse signupClient(long messageId, Customer customer, SessionId sessionId) {

        if (activeClients.get(sessionId) == null
                && customerDao.insertCustomer(customer)
                && fileProvider.createDirectory(Paths.get(CLOUD_STORAGE, customer.getLogin()))) {
            return new ServerSignupResponse(messageId, true, "ok");
        }
        return new ServerSignupResponse(messageId, false, "Try again with another login");
    }

    /**
     * TODO:
     */
    private boolean isAuthenticated(SessionId sessionId) {
        return activeClients.get(sessionId) != null;
    }

    /**
     * TODO:
     */
    private SessionId createSessionId(SelectionKey key) {
        return new SessionId(((SocketChannel) key.channel()).socket().getRemoteSocketAddress().hashCode());
    }
}
package server;




public class FileTransfer implements Runnable {

    private BiConsumer<SocketChannel, ClientMessage> callBack;
    private SocketChannel channel;
    private ClientMessage message;
    private Path filePath;
    private final long block_size;
    private long fileLength;

    public FileTransfer(SocketChannel channel, ClientMessage message, Path filePath, BiConsumer<SocketChannel, ClientMessage> callBack) {
        this.channel = channel;
        this.message = message;
        this.filePath = filePath;
        this.block_size = 16384;
        this.callBack = callBack;
        this.fileLength = 0;

        if (message.getRequest() == ClientRequest.GET) {
            try {
                fileLength = Files.size(filePath);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        new Thread(this).start();
    }

    public FileTransfer(SocketChannel channel, ClientMessage message, Path filePath, long fileLength, BiConsumer<SocketChannel, ClientMessage> callBack) {
        this.channel = channel;
        this.message = message;
        this.filePath = filePath;
        this.block_size = 8192;
        this.callBack = callBack;
        this.fileLength = fileLength;

        new Thread(this).start();
    }

    @Override
    public void run() {

        switch (message.getRequest()) {
            case GET:
                sendFile(filePath, fileLength);
                break;
            case PUT:
                receiveFile(filePath, fileLength);
                break;
            default:
        }

        // TODO: РџРѕСЃР»Рµ РѕРїРµСЂР°С†РёРё СЃ С„Р°Р№Р»РѕРј РёР·РІРµСЃС‚РёС‚СЊ РѕСЃРЅРѕРІРЅРѕР№ РїРѕС‚РѕРє
        callBack.accept(channel, message);
    }

    /**
     * TODO: РћС‚РїСЂР°РІРёС‚СЊ С„Р°Р№Р»
     */
    private void sendFile(Path path, long length) {
        if (length == 0) {
            dp(this, "sendFile. Invalid file length");
            return;
        }

        try (FileInputStream fis = new FileInputStream(path.toString());
             FileChannel fromChannel = fis.getChannel()) {
            long sent = 0;

            dp(this, "sendFile. Source file length is " + length);
            // TODO: РџРµСЂРµРґР°С‚СЊ С„Р°Р№Р» Р±Р»РѕРєР°РјРё block_size
            do {
                long count = length - sent > block_size ? block_size : length - sent;
                sent += fromChannel.transferTo(sent, count, channel);
            } while (sent < length);

            dp(this, "sendFile. Bytes sent " + sent);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * TODO: Р’С‹РїРѕР»РЅРёС‚СЊ Р·Р°РіСЂСѓР·РєСѓ. Р•СЃР»Рё С„Р°Р№Р» СЃСѓС‰РµСЃС‚РІСѓРµС‚, С‚Рѕ Р±СѓРґРµС‚ РїРµСЂРµР·Р°РїРёСЃР°РЅ.
     * Р¤Р°Р№Р» РїСЂРёРЅРёРјР°РµС‚СЃСЏ Р±Р»РѕРєР°РјРё СЂР°Р·РјРµСЂРѕРј block_size. Р”Р»СЏ РїСЂРёРµРјР° РїРѕСЃР»РµРґРЅРµРіРѕ Р±Р»РѕРєР°,
     * РєРѕС‚РѕСЂС‹Р№ РЅРµ СЂР°РІРµРЅ block_size РЅСѓР¶РЅРѕ СѓСЃС‚Р°РЅРѕРІРёС‚СЊ С‚РѕС‡РЅС‹Р№ СЂР°Р·РјРµСЂ.
     */
    private void receiveFile(Path path, long length) {
        if (length == 0) {
            dp(this, "receiveFile. Invalid file length");
            return;
        }

        try (FileOutputStream fos = new FileOutputStream(path.toString());
             FileChannel toChannel = fos.getChannel()) {

            long received = 0;

            dp(this, "receiveFile. Ready to receive " + length);
            do {
                received += toChannel.transferFrom(channel, received, length - received >= block_size ? block_size : length - received);
            } while (received < length);

            toChannel.force(false);
            dp(this, "receiveFile. Bytes received = " + received);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
========================================
========================================
Project name: MyCloud-master
РќР° РґР°РЅРЅС‹Р№ РјРѕРјРµРЅС‚ РєР»РёРµРЅС‚ СѓРјРµРµС‚ РѕР±РјРµРЅРёРІР°С‚СЊСЃСЏ С„Р°Р№Р»Р°РјРё СЃ СЃРµСЂРІРµСЂРѕРј Рё РµСЃС‚СЊ РїСЂРёРјРёС‚РёРІРЅР°СЏ Р°СѓС‚РµРЅС‚РёС„РёРєР°С†РёСЏ.
РЈ РјРµРЅСЏ РІРѕРїСЂРѕСЃ: РєР°Рє Р»СѓС‡С€Рµ СЂРµР°Р»РёР·РѕРІР°С‚СЊ РѕР±РјРµРЅ СЃРѕРѕР±С‰РµРЅРёСЏРјРё РєР»РёРµРЅС‚Р° СЃ СЃРµСЂРІРµСЂРѕРј?
РЈ РјРµРЅСЏ Р±С‹Р» РєР»Р°СЃСЃ Command РІ РєРѕС‚РѕСЂРѕРј Р±С‹Р»Рѕ РїРѕР»Рµ СЃ id-РЅР°Р·РЅР°С‡РµРЅРёРµРј С„Р°Р№Р»Р° (Р·Р°РїСЂРѕСЃ, РѕС€РёР±РєР° Рё С‚Р°Рє РґР°Р»РµРµ). Р’ Р·Р°РІРёСЃРёРјРѕСЃС‚Рё РѕС‚ СЌС‚РѕРіРѕ Рё СЂРµС€Р°Р»РѕСЃСЊ, С‡С‚Рѕ РґРµР»Р°С‚СЊ СЃ РѕР±СЉРµРєС‚РѕРј. РџРѕС‚РѕРј РїРѕРґСѓРјР°Р», С‡С‚Рѕ РЅР°РіСЂРѕРјРѕР¶РґР°С‚СЊ РІСЃРµ РІ РѕРґРёРЅ РєР»Р°СЃСЃ РЅРµСЂР°Р·СѓРјРЅРѕ Рё СЃРґРµР»Р°Р» РєР»Р°СЃСЃ Message РѕС‚ РєРѕС‚РѕСЂРѕРіРѕ РЅР°СЃР»РµРґСѓСЋС‚СЃСЏ РєР»Р°СЃСЃС‹ РїРѕ РЅР°Р·РЅР°С‡РµРЅРёСЋ. Р РІРјРµСЃС‚Рѕ РїСЂРѕРІРµСЂРєРё id С‚РµРїРµСЂСЊ РїСЂРѕРІРµСЂРєР° РєР»Р°СЃСЃР° С‡РµСЂРµР· instanceof. Р›СѓС‡С€Рµ РѕСЃС‚Р°РІРёС‚СЊ РёР»Рё РІРµСЂРЅСѓС‚СЊ, РёР»Рё РІРѕРѕР±С‰Рµ РґСЂСѓРіРѕРµ РїСЂРёРґСѓРјР°С‚СЊ?



public class Controller implements Initializable {
    @FXML
    Button downloadBtn;

    @FXML
    Button uploadBtn;

    @FXML
    ListView<String> filesList;

    @FXML
    TextField textField;

    @FXML
    TextArea textArea;

    @FXML
    HBox upperPanel;

    @FXML
    VBox bottomPanel;

    @FXML
    TextField loginField;

    @FXML
    PasswordField passwordField;

    private boolean isAuthorized;

    public void setAuthorized(boolean isAuthorized){
        this.isAuthorized = isAuthorized;
        if (!isAuthorized){
            upperPanel.setVisible(true);
            upperPanel.setManaged(true);
            bottomPanel.setVisible(false);
            bottomPanel.setManaged(false);
        }else {
            upperPanel.setVisible(false);
            upperPanel.setManaged(false);
            bottomPanel.setVisible(true);
            bottomPanel.setManaged(true);
        }
    }

    @Override
    public void initialize(URL location, ResourceBundle resources) {
        Network.start();
        System.out.println("initialized");
        Thread t = new Thread(() -> {
            try {
                while (true) {
                    AbstractBox box = Network.readObject();
                    System.out.println("Object is read");
                    if (box instanceof Command){
                        Command command = (Command) box;
                        if (command.getId() == Commands.AUTH) setAuthorized(true);
                        if (command.getId() == Commands.ERROR) textArea.appendText(command.getError().toString());
                        if (command.getId() == Commands.SERVER_RESPONSE){
                            textArea.appendText(command.getFileName() + " " + command.getMsg());
                        }
                    }
                    if (box instanceof FileBox){
                        FileBox fileBox = (FileBox) box;
                        System.out.println(fileBox.getFileName());
                        Files.write(Paths.get("client_storage/" + fileBox.getFileName()),
                                fileBox.getContent(),
                                StandardOpenOption.CREATE);
                        textArea.appendText("Р¤Р°Р№Р» " + fileBox.getFileName() + " СѓСЃРїРµС€РЅРѕ Р·Р°РіСЂСѓР¶РµРЅ РІ С…СЂР°РЅРёР»РёС‰Рµ");
                    }
                }
            } catch (ClassNotFoundException | IOException e) {
                e.printStackTrace();
            } finally {
                Network.stop();
            }
        });
        t.setDaemon(true);
        t.start();
        refreshLocalFilesList();
    }

    public void refreshLocalFilesList() {
        if (Platform.isFxApplicationThread()) {
            try {
                filesList.getItems().clear();
                Files.list(Paths.get("client_storage")).map(p -> p.getFileName().toString()).forEach(o -> filesList.getItems().add(o));
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            Platform.runLater(() -> {
                try {
                    filesList.getItems().clear();
                    Files.list(Paths.get("client_storage")).map(p -> p.getFileName().toString()).forEach(o -> filesList.getItems().add(o));
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });
        }
    }

    public void downloadFile(){
        if (textField.getLength() > 0){
            Network.sendMsg(new Command(Commands.RECEIVE_FILE, textField.getText()));
            textField.clear();
        }
    }

    public void uploadFile() {
        if (textField.getLength() > 0) {
            try {
                Network.sendMsg(new FileBox(Paths.get("client_storage/" + textField.getText())));
            } catch (IOException e) {
                e.printStackTrace();
            }
            textField.clear();
        }
    }

    public void tryToAuth() {
        Network.tryToAuth(loginField.getText(), passwordField.getText());
    }
}




public class Main extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception{
        Parent root = FXMLLoader.load(getClass().getResource("/FXML/main.fxml"));
        primaryStage.setTitle("Hello World");
        primaryStage.setScene(new Scene(root, 400, 400));
        primaryStage.show();
    }


    public static void main(String[] args) {
        launch(args);
    }
}


public class Network {
    private static Socket socket;
    private static ObjectEncoderOutputStream out;
    private static ObjectDecoderInputStream in;

    public static void start() {
        try {
            socket = new Socket("localhost", 8189);
            out = new ObjectEncoderOutputStream(socket.getOutputStream());
            in = new ObjectDecoderInputStream(socket.getInputStream(), 50 * 1024 * 1024);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    static void tryToAuth(String login, String password) {
        int hash = password.hashCode();
        sendMsg(new Command(login + " " + hash, Commands.AUTH));
    }

    public static void stop() {
        try {
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            in.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static boolean sendMsg(AbstractBox msg) {
        try {
            out.writeObject(msg);
            return true;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return false;
    }

    public static AbstractBox readObject() throws ClassNotFoundException, IOException {
        Object obj = in.readObject();
        return (AbstractBox) obj;
    }
}

public abstract class AbstractBox implements Serializable {
}

public class Command extends AbstractBox{
    private Commands id;

    private Errors error;
    private String filename;
    private String msg;
    public Command(Commands id){
        this.id = id;
    }

    public Command(Commands id, String filename){
        this.id = id;
        this.filename = filename;
    }

    public Command(String msg, Commands id){
        this.id = id;
        this.msg = msg;
    }

    public Command(Commands id, String filename, String message){
        this.id = id;
        this.filename = filename;
        this.msg = message;
    }

    public Command(Commands id, Errors error) {
        this.id = id;
        this.error = error;
    }

    public Commands getId() {
        return id;
    }

    public String getFileName() {
        return filename;
    }

    public String getMsg() {
        return msg;
    }

    public Errors getError() {
        return error;
    }
}
public enum Commands {
    ERROR, RECEIVE_FILE, SERVER_RESPONSE, UPLOAD_FILE, AUTH;
}
public class CommandTable {
    public static final int SNAFU = 0;
    public static final int SEND_MESSAGE = 1;
    public static final int SEND_FILE = 2;
    public static final int RECEIVE_FILE = 3;
    public static final int SERVER_RESPONSE = 4;
    public static final int UPLOAD_FILE = 5;

}
public enum Errors {
    WRONG_LOGIN_OR_PASSWORD, FILE_DOES_NOT_EXIST;
}

public class FileBox extends AbstractBox {
    private static final int PACKAGE_VOLUME = 10485760;
    private byte[] content;
    private String fileName;
    private int length;

    public FileBox(Path path) throws IOException {
        fileName = path.getFileName().toString();
        content = Files.readAllBytes(path);
    }

    public byte[] getContent() {
        return content;
    }

    public String getFileName() {
        return fileName;
    }

//    static synchronized FileBox receiveFile(DataInputStream in) throws IOException {
//        FileBox file = new FileBox();
//        try{
//            ObjectInputStream ois = new ObjectInputStream(in);
//            file = (FileBox) ois.readObject();
//            System.out.println("File transfer completed");
//        } catch (IOException e) {
//            e.printStackTrace();
//        } catch (ClassNotFoundException e) {
//            e.printStackTrace();
//        }
//        return file;
//    }

}

public class AuthService {

    private static Connection connection;
    private static Statement statement;

    public static void connect() throws SQLException {
        try {
            Class.forName("org.sqlite.JDBC");
            connection = DriverManager.getConnection("jdbc:sqlite:main.db");
            statement = connection.createStatement();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    public static boolean checkUserByLoginAndPass(String login, int pass){
        String sql = String.format("SELECT password FROM mane\n" +
                "WHERE login = '%s'", login);
        try {
            ResultSet rs = statement.executeQuery(sql);

            if(rs.next()){
                int dbHash = rs.getInt(1);
                System.out.println(pass + " " + dbHash);
                return pass == dbHash;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

    public static void addUser(String login, String pass, String nick){
        String sql = String.format("INSERT INTO mane (login, password, nickname)\n" +
                "VALUES ('%s','%s', '%s')", login, pass.hashCode(), nick);
        try {
            statement.execute(sql);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void disconnect(){
        try {
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
//import java.io.*;
//import java.net.Socket;
//
//public class ClientHandler {
//
//    Socket socket = null;
//    Server server;
//    DataInputStream in;
//    DataOutputStream out;
//
//
//    private String nick;
//
//    public ClientHandler(Server server, Socket socket) {
//        try {
//            this.server = server;
//            this.socket = socket;
//            this.in = new DataInputStream(socket.getInputStream());
//            this.out = new DataOutputStream(socket.getOutputStream());
//
//            new Thread(new Runnable() {
//                @Override
//                public void run() {
//                    try {
//                        nick = in.readUTF();
//                        while (true) {
//                            byte i = in.readByte();
//                            if (i == 97){
//                                Command command = Command.receiveCommand(in);
//                                System.out.println("РєРѕРјР°РЅРґР° РїРѕР»СѓС‡РµРЅР°");
//                                System.out.println(command.getId());
//                                System.out.println(command.getMsg());
//                                if (command.getId() == CommandTable.SEND_FILE){
//                                    sendResponseTo(true, "ok", command.getFileName()); //Р·РґРµСЃСЊ РµС‰Рµ РґРѕР»Р¶РЅР° Р±С‹С‚СЊ РїСЂРѕРІРµСЂРєР° РІРѕР·РјРѕР¶РЅРѕСЃС‚Рё РїРµСЂРµРґР°С‡Рё С„Р°Р№Р»Р°
//                                    FileBox file = FileBox.receiveFile(in);
//
//                                }
//                                if (command.getId() == CommandTable.UPLOAD_FILE){
//                                    System.out.println("РљР»РёРµРЅС‚ С…РѕС‡РµС‚ РѕС‚РїСЂР°РІРёС‚СЊ С„Р°Р№Р»");
//                                    //РґРѕР±Р°РІРёС‚СЊ РїСЂРѕРІРµСЂРєСѓ РІРѕР·РјРѕР¶РЅРѕСЃС‚Рё Р·Р°РіСЂСѓР·РєРё С„Р°Р№Р»Р° (РµСЃС‚СЊ Р»Рё РјРµСЃС‚Рѕ)
//                                    sendResponseTo(true, "ok", command.getMsg());
//                                    System.out.println("РѕС‚РІРµС‚ РѕС‚РїСЂР°РІР»РµРЅ");
//                                    FileBox file = FileBox.receiveFile(in);
//                                    System.out.println("File is received");
//                                    FileOutputStream fos = new FileOutputStream("new" + file.getFileName());
//                                    for (byte b:file.getContent()) {
//                                        fos.write(b);
//                                    }
//                                    System.out.println("file is uploaded");
//                                    sendResponseTo("Р¤Р°Р№Р» " + file.getFileName() + " Р·Р°РіСЂСѓР¶РµРЅ СѓСЃРїРµС€РЅРѕ");
//                                }
//                                if (command.getId() == CommandTable.SEND_MESSAGE){
//
//                                }
//                            }
//
//                        }
//                    } catch (IOException e) {
//                        e.printStackTrace();
//                    } finally {
//                        try {
//                            in.close();
//                        } catch (IOException e) {
//                            e.printStackTrace();
//                        }
//                        try {
//                            out.close();
//                        } catch (IOException e) {
//                            e.printStackTrace();
//                        }
//                        try {
//                            socket.close();
//                        } catch (IOException e) {
//                            e.printStackTrace();
//                        }
//                    }
//                }
//            }).start();
//
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
//    }
//
//    private void sendResponseTo(boolean permission, String msg, String file) {
//        Command response = new Command(CommandTable.SERVER_RESPONSE, permission, msg, file);
//        try {
//            ObjectOutputStream oos = new ObjectOutputStream(out);
//            oos.writeObject(response);
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
//    }
//
//    private void sendResponseTo(String msg) {
//        Command response = new Command(CommandTable.SERVER_RESPONSE, msg);
//        try {
//            ObjectOutputStream oos = new ObjectOutputStream(out);
//            oos.writeObject(response);
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
//    }
//
//    public void sendMsg(String msg) {
//        try {
//            out.writeUTF(msg);
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
//    }
//
//    public String getNick() {
//        return this.nick;
//    }
//
//}


public class InputHandler extends ChannelInboundHandlerAdapter {
    private boolean isAuthorised = false;
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        if (!isAuthorised) {
            if (msg instanceof Command){
                Command command = (Command) msg;
                System.out.println("auth try");
                if (command.getId() == Commands.AUTH){
                    String[] user = command.getMsg().split(" ");
                    if (AuthService.checkUserByLoginAndPass(user[0], Integer.parseInt(user[1]))){
                        isAuthorised = true;
                        System.out.println("auth success");
                        ctx.writeAndFlush(new Command(Commands.AUTH));
                    } else {
                        System.out.println("auth failed");
                        ctx.writeAndFlush(new Command(Commands.ERROR, Errors.WRONG_LOGIN_OR_PASSWORD));
                    }
                }
            }
        } else
        try {
            if (msg == null) {
                return;
            }
            if (msg instanceof Command) {
                Command command = (Command) msg;
                System.out.println("Command is received");
                System.out.println(command.getId());
                if (command.getId() == Commands.RECEIVE_FILE){
                    if (Files.exists(Paths.get("server_storage/" + command.getFileName()))) {
                        System.out.println("File exists");
                        FileBox fb = new FileBox(Paths.get("server_storage/" + command.getFileName()));
                        ctx.writeAndFlush(fb);
                        System.out.println("File is sent");
                    }
                }
            }
            if (msg instanceof FileBox) {
                FileBox fb = (FileBox) msg;
                Files.write(Paths.get("server_storage/" + fb.getFileName()),
                        fb.getContent(),
                        StandardOpenOption.CREATE);
                ctx.writeAndFlush(new Command(Commands.SERVER_RESPONSE, fb.getFileName(), "РґРѕСЃС‚Р°РІР»РµРЅ СѓСЃРїРµС€РЅРѕ"));
            }
        } finally {
            ReferenceCountUtil.release(msg);
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}

public class Server {

    //private Vector<ClientHandler> clients;

    public void run() throws Exception {
        EventLoopGroup mainGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        AuthService.connect();
        System.out.println("РЎРµСЂРІРµСЂ РІРєР»СЋС‡РµРЅ!");
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(mainGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            socketChannel.pipeline().addLast(
                                    new ObjectDecoder(50 * 1024 * 1024, ClassResolvers.cacheDisabled(null)),
                                    new ObjectEncoder(),
                                    new InputHandler()
                            );
                        }
                    })
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture future = b.bind(8189).sync();
            future.channel().closeFuture().sync();
        } finally {
            mainGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
            AuthService.disconnect();
        }
    }

//    public void broadcastMsg(ClientHandler client, String msg) {
//        for (ClientHandler o: clients) {
//            o.sendMsg(dateFormat.format(date) + "\n" + msg);
//        }
//    }
//
//    public ClientHandler getClientByNick(String nick){
//        ClientHandler client = null;
//        for (ClientHandler c:clients) {
//            if (c.getNick().equals(nick)){
//                client = c;
//            }
//        }
//        return client;
//    }

}
public class StartServer {
    public static void main(String[] args) throws Exception {
        new Server().run();
    }
}

public class Test {

    public static void main(String[] args) {
        Thing thing = new Thing(44);

        try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("p.dat"))){

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

public class Thing implements Serializable {
    private int age;

    public Thing(int age){
        this.age = age;
    }

    public int getAge() {
        return age;
    }
}
========================================
========================================
Project name: project
РџСЂРѕСЂР°Р±РѕС‚Р°РЅ РєР»РёРµРЅС‚.
РЎРµСЂРІРµСЂ РЅРµ РїСЂРѕСЂР°Р±РѕС‚Р°РЅ. Р РёС… РІР·Р°РёРјРѕРґРµР№СЃС‚РІРёРµ РїРѕРєР° РЅРµ РЅР°Р»Р°Р¶РµРЅРѕ.
package client;



/**
 * РЎС‚Р°СЂС‚РѕРІС‹Р№ РєР»Р°СЃСЃ РґР»СЏ РєР»РёРµРЅС‚Р°
 */
public class Client {

    public static void main(String[] args) throws Exception {

        ClientOperation operation = null;
        FilesList filesList = returnFilesListFromDB();

        do {
            operation = askOperation();
            CommandExecutor.execute(operation);
        } while (operation != ClientOperation.EXIT);

    }

    /**
     * РњРµС‚РѕРґ РІС‹РІРѕРґРёС‚ РЅР° СЌРєСЂР°РЅ РІР°СЂРёР°РЅС‚С‹ С‚РѕРіРѕ, С‡С‚Рѕ РјРѕР¶РµС‚ СЃРґРµР»Р°С‚СЊ РїРѕР»СЊР·РѕРІР°С‚РµР»СЊ,
     * Рё СЃС‡РёС‚С‹РІР°РµС‚ РѕС‚ РЅРµРіРѕ С†РёС„СЂСѓ СЃРѕРѕС‚РІРµС‚СЃС‚РІСѓСЋС‰СѓСЋ РЅРѕРјРµСЂСѓ РѕРїРµСЂР°С†РёРё,
     * РєРѕС‚РѕСЂСѓСЋ РїРѕР»СЊР·РѕРІР°С‚РµР»СЊ С…РѕС‡РµС‚ РІС‹РїРѕР»РЅРёС‚СЊ.
     * @return
     * @throws IOException
     */
    public static ClientOperation askOperation() throws IOException {
        ConsoleHelper.writeMessage("");
        ConsoleHelper.writeMessage("Р’С‹Р±РµСЂРёС‚Рµ РѕРїРµСЂР°С†РёСЋ:");
        ConsoleHelper.writeMessage(String.format("\t %d - РґРѕР±Р°РІРёС‚СЊ С„Р°Р№Р» РІ СЃРїРёСЃРѕРє С„Р°Р№Р»РѕРІ РґР»СЏ РѕС‚РїСЂР°РІРєРё", ClientOperation.ADD.ordinal()));
        ConsoleHelper.writeMessage(String.format("\t %d - СѓРґР°Р»РёС‚СЊ С„Р°Р№Р» РёР· СЃРїРёСЃРєР° С„Р°Р№Р»РѕРІ РґР»СЏ РѕС‚РїСЂР°РІРєРё", ClientOperation.REMOVE.ordinal()));
        ConsoleHelper.writeMessage(String.format("\t %d - РїСЂРѕСЃРјРѕС‚СЂРµС‚СЊ СЃСЃРїРёСЃРѕРє С„Р°Р№Р»РѕРІ РґР»СЏ РѕС‚РїСЂР°РІРєРё", ClientOperation.CONTENT.ordinal()));
        ConsoleHelper.writeMessage(String.format("\t %d - РІС‹С…РѕРґ", ClientOperation.EXIT.ordinal()));

        return ClientOperation.values()[ConsoleHelper.readInt()];
    }
}
package client;

public enum  ClientOperation {
    ADD,
    REMOVE,
    CONTENT,
    EXIT
}
package client;



/**
 * РљР»Р°СЃСЃ СЂРµР°Р»РёР·СѓРµС‚ РїР°С‚С‚РµСЂРЅ Command
 */
public class CommandExecutor {
    private static final Map<ClientOperation, Command> allKnownCommandsMap = new HashMap<ClientOperation, Command>();

    static {
        allKnownCommandsMap.put(ClientOperation.ADD, new CommandADD());
        allKnownCommandsMap.put(ClientOperation.REMOVE, new CommandREMOVE());
        allKnownCommandsMap.put(ClientOperation.CONTENT, new CommandCONTENT());
        allKnownCommandsMap.put(ClientOperation.EXIT, new CommandEXIT());
    }

    private CommandExecutor() {
    }

    public static void execute(ClientOperation operation) throws Exception {
        allKnownCommandsMap.get(operation).execute();
    }

}
package client;




/**
 * РљР»Р°СЃСЃ Р±СѓРґРµС‚ РѕС‚РІРµС‡Р°С‚СЊ Р·Р° СЂР°Р±РѕС‚Сѓ СЃ Р±Р°Р·РѕР№ РґР°РЅРЅС‹С…
 */
public class DBManager {
    private static Connection connection;
    private static Statement statement;
    private static String tableName = "fileslist";

    /**
     * РЈСЃС‚Р°РЅР°РІР»РёРІР°РµРј СЃРѕРµРґРёРЅРµРЅРёРµ СЃ Р‘Р”
     * @throws ClassNotFoundException
     * @throws SQLException
     */
    public static void connect() throws ClassNotFoundException, SQLException {
        Class.forName("org.sqlite.JDBC");
        connection = DriverManager.getConnection("jdbc:sqlite:Client/src/main/java/database/files.db");
        statement = connection.createStatement();
    }

    /**
     * Р—Р°РєСЂС‹РІР°РµРј СЃРѕРµРґРёРЅРµРЅРёРµ СЃ Р‘Р”
     */
    public static void disconnect(){
        try {
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * РњРµС‚РѕРґ РґРѕР±Р°РІР»СЏРµС‚ Р·Р°РїРёСЃСЊ РІ С‚Р°Р±Р»РёС†Сѓ
     * @param name
     * @param size
     * @param absolutePath
     * @param timeWhenAdd
     * @throws SQLException
     */
    public static void insertIntoTable(String name, long size, String absolutePath, long timeWhenAdd) throws SQLException {
        try {
            connect();
            String sql = String.format("INSERT INTO %s (name, size, absolutePath, timeWhenAdd) " +
                    "VALUES ('%s', '%d', '%s', '%d');", tableName, name, size, absolutePath, timeWhenAdd);
            statement.execute(sql);
        } catch (ClassNotFoundException e) {
            ConsoleHelper.writeMessage("РћС€РёР±РєР° РїСЂРё СЃРѕС…СЂР°РЅРµРЅРёРё РґР°РЅРЅС‹С…");
        } finally {
            disconnect();
        }
    }

    /**
     * РњРµС‚РѕРґ РІРµСЂРЅРµС‚ FilesList, РєРѕС‚РѕСЂС‹Р№ СЃС„РѕСЂРјРёСЂСѓРµС‚ РёР· Р‘Р”.
     * @throws SQLException
     */
    public static FilesList returnFilesListFromDB() throws SQLException, PathIsNotFoundException {
        FilesList filesList = getFilesList();;
        try {
            connect();
            String sql = String.format("SELECT * FROM %s;", tableName);
            ResultSet rs = statement.executeQuery(sql);
            while (rs.next()){
                filesList.addFileFromDB(new FileProperties(
                        rs.getString(2),
                        rs.getLong(3),
                        Paths.get(rs.getString(4)),
                        new Date(rs.getLong(5))
                ));
            }
        } catch (ClassNotFoundException e) {
            ConsoleHelper.writeMessage("РћС€РёР±РєР° РїСЂРё Р·Р°РіСЂСѓР·РєРµ РґР°РЅРЅС‹С…");
        } finally {
            disconnect();
        }
        return filesList;
    }

    /**
     * РњРµС‚РѕРґ СѓРґР°Р»СЏРµС‚ РІСЃРµ РґР°РЅРЅС‹Рµ РёР· С‚Р°Р±Р»РёС†С‹.
     * @throws SQLException
     */
    public static void deleteAllFromTable() throws SQLException {
        try {
            connect();
            String sql = String.format("DELETE FROM %s ", tableName);
            statement.execute(sql);
        } catch (ClassNotFoundException e) {
            ConsoleHelper.writeMessage("РћС€РёР±РєР° РїСЂРё СЂР°Р±РѕС‚Рµ СЃ Р‘Р”");
        } finally {
            disconnect();
        }
    }

}
package client;


/**
 * РљР»Р°СЃСЃ СЂР°Р±РѕС‚Р°РµС‚ СЃ С„Р°Р№Р»Р°РјРё Рё РґРёСЂСЂРµРєС‚РѕСЂРёСЏРјРё
 * TODO
 */
public class FileManager {
    private Path rootPath;
    private List<Path> fileList;

    public FileManager(Path rootPath) throws IOException {
        this.rootPath = rootPath;
        this.fileList = new ArrayList<>();
        collectFileList(rootPath);
    }

    public List<Path> getFileList() {
        return fileList;
    }

    private void collectFileList(Path path) throws IOException {

        // Р”РѕР±Р°РІР»СЏРµРј С‚РѕР»СЊРєРѕ С„Р°Р№Р»С‹
        if (Files.isRegularFile(path)) {
            Path relativePath = rootPath.relativize(path);
            fileList.add(relativePath);
        }

        // Р”РѕР±Р°РІР»СЏРµРј СЃРѕРґРµСЂР¶РёРјРѕРµ РґРёСЂРµРєС‚РѕСЂРёРё
        if (Files.isDirectory(path)) {
            // Р РµРєСѓСЂСЃРёРІРЅРѕ РїСЂРѕС…РѕРґРёРјСЃСЏ РїРѕ РІСЃРµРјСѓ СЃРѕРґРµСЂР¶РјРѕРјСѓ РґРёСЂРµРєС‚РѕСЂРёРё
            // Р§С‚РѕР±С‹ РЅРµ РїРёСЃР°С‚СЊ РєРѕРґ РїРѕ РІС‹Р·РѕРІСѓ close РґР»СЏ DirectoryStream, РѕР±РµСЂРЅРµРј РІС‹Р·РѕРІ newDirectoryStream РІ try-with-resources
            try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(path)) {
                for (Path file : directoryStream) {
                    collectFileList(file);
                }
            }
        }
    }
}
package client;


/**
 * Р’ РєР»Р°СЃСЃРµ Р±СѓРґСѓС‚ С…СЂР°РЅРёС‚СЊСЃСЏ РґР°РЅРЅС‹Рµ Рѕ РѕР±СЉРµРєС‚Рµ
 * РёРјСЏ С„Р°Р№Р»Р°
 * СЂР°Р·РјРµСЂ С„Р°Р№Р»Р°
 * Р°Р±СЃРѕР»СЋС‚РЅС‹Р№ РїСѓС‚СЊ
 * РІСЂРµРјСЏ РґРѕР±Р°РІР»РµРЅРёСЏ TODO - С„РѕСЂРјР°С‚РёСЂРѕРІР°РЅРёРµ РґР°С‚С‹
 */
public class FileProperties {
    private String name;
    private long size;
    private Path absolutePath;
    private Date timeWhenAdd;
    private boolean fileExist;

    /**
     * РљРѕРЅСЃС‚СЂСѓРєС‚РѕСЂ РґР»СЏ РёР·РІР»РµС‡РµРЅРёСЏ С„Р°Р№Р»РѕРІ РёР· Р‘Р”
     * @param name
     * @param size
     * @param absolutePath
     * @param timeWhenAdd
     */
    public FileProperties(String name, long size, Path absolutePath, Date timeWhenAdd) {
        this.name = name;
        this.size = size;
        this.absolutePath = absolutePath;
        this.timeWhenAdd = timeWhenAdd;
        this.fileExist = true;
    }

    public FileProperties(Path sourcePath) throws IOException {
        this.name = sourcePath.getFileName().toString();
        this.size = Files.size(sourcePath);
        this.absolutePath = sourcePath;
        this.timeWhenAdd = new Date();
        this.fileExist = true;
    }

    public String getName() {
        return name;
    }

    public long getSize() {
        return size;
    }

    public Path getAbsolutePath() {
        return absolutePath;
    }

    public Date getTimeWhenAdd() {
        return timeWhenAdd;
    }

    public boolean isFileExist() {
        return fileExist;
    }

    public void setFileExist(boolean fileExist) {
        this.fileExist = fileExist;
    }

    @Override
    public String toString() {
        // РЎС‚СЂРѕРёРј РєСЂР°СЃРёРІСѓСЋ СЃС‚СЂРѕРєСѓ РёР· СЃРІРѕР№СЃС‚РІ
        StringBuilder builder = new StringBuilder();
        builder.append(name);
        builder.append("\t");
        builder.append(size / 1024);
        builder.append(" Kb, ");
        builder.append("absolute path: ");
        builder.append(absolutePath);
        builder.append(", when added: ");
        builder.append(timeWhenAdd.getTime());
        builder.append(" file exist: ");
        builder.append(isFileExist());
        return builder.toString();
    }

    @Override
    public int hashCode() {
        return super.hashCode();
    }
/*
    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if ((o == null) || o.getClass() != this.getClass()) return false;
        FileProperties fileProperties = (FileProperties) o;
        if (!(o instanceof FileProperties)) return false;
        return (name == fileProperties.name || (name != null && name.equals(fileProperties.name)))
                && size == fileProperties.size
                && (absolutePath == fileProperties.absolutePath || (absolutePath != null && absolutePath.equals(fileProperties.absolutePath)));
    }
*/

    /**
     * РњРµС‚РѕРґ СЃСЂР°РІРЅРёРІР°РµС‚ С‚РѕР»СЊРєРѕ Р°Р±СЃРѕР»СЋС‚РЅС‹Рµ РїСѓС‚Рё Рє С„Р°Р№Р»Р°Рј
     * @param o
     * @return
     */
    public boolean equalsByAbsolutePath(Object o) {
        if (o == this) return true;
        if ((o == null) || o.getClass() != this.getClass()) return false;
        FileProperties fileProperties = (FileProperties) o;
        if (!(o instanceof FileProperties)) return false;
        return (absolutePath == fileProperties.absolutePath ||
                (absolutePath != null && absolutePath.equals(fileProperties.absolutePath)));
    }
}
package client;



/**
 * The class keeps a list of the files
 * that the user wants to send to the server.
 */
public class FilesList {

    private static FilesList filesList;
    private List<FileProperties> fileList;

    private FilesList() {
        this.fileList = new ArrayList<>();
    }

    public static synchronized FilesList getFilesList(){
        if (filesList == null) filesList = new FilesList();
        return filesList;
    }

    public void addFiles(List<FileProperties> fileList) throws PathIsNotFoundException {
        for (FileProperties fileProperty : fileList) {
            addFile(fileProperty);
        }
    }

    /**
     * РњРµС‚РѕРґ РґРѕР±Р°РІР»СЏРµС‚ С‚РѕР»СЊРєРѕ СЃСѓС‰РµСЃС‚РІСѓСЋС‰РёРµ С„Р°Р№Р»С‹
     * @param file
     * @throws PathIsNotFoundException
     */
    public void addFile(FileProperties file) throws PathIsNotFoundException {
        if(Files.notExists(file.getAbsolutePath())){
            throw new PathIsNotFoundException();
        } else {
            this.fileList.add(file);
        }
    }

    /**
     * РњРµС‚РѕРґ РѕС‚Р»РёС‡Р°РµС‚СЃСЏ РѕС‚ public void addFile(FileProperties file) С‚РµРј,
     * С‡С‚Рѕ РґРѕР±Р°РІР»СЏРµС‚ РІСЃРµ С„Р°Р№Р»С‹ РёР· Р±Р°Р·С‹ РґР°РЅРЅС‹С…, РЅРµ Р·Р°РІРёСЃРёРјРѕ РѕС‚ С‚РѕРіРѕ,
     * РЅР°Р№РґРµРЅ-Р»Рё РѕРЅ РЅР° РџРљ РёР»Рё РЅРµС‚.
     * @param file
     * @throws PathIsNotFoundException
     */
    public void addFileFromDB(FileProperties file) throws PathIsNotFoundException {
        if(Files.notExists(file.getAbsolutePath())){
            file.setFileExist(false);
        }
        this.fileList.add(file);
    }

    public void removeFiles(List<FileProperties> fileList){
        for (FileProperties fileProperty : fileList) {
            if (this.fileList.contains(fileProperty))
                this.fileList.remove(fileProperty);
        }
    }

    public void removeFile(Path sourcePath){
        for (int i = 0; i < fileList.size(); i++) {
            if (fileList.get(i).getAbsolutePath().equals(sourcePath)){
                ConsoleHelper.writeMessage(String.format("Р¤Р°Р№Р» %s СѓРґР°Р»РµРЅ.", fileList.get(i).getAbsolutePath()));
                fileList.remove(i);
                return;
            }
        }
        ConsoleHelper.writeMessage(String.format("Р¤Р°Р№Р» %s РЅРµ РЅР°Р№РґРµРЅ.", sourcePath));
    }

    public int size(){
        return fileList.size();
    }

    public List<FileProperties> getFileList() {
        return fileList;
    }

    public void setFileList(List<FileProperties> fileList) {
        this.fileList = fileList;
    }
}
package client;

/**
 * РљР»Р°СЃСЃ Р±СѓРґРµС‚ РѕС‚РІРµС‡Р°С‚СЊ Р·Р° СЂР°Р±РѕС‚Сѓ РєР»РёРµРЅС‚Р° СЃ СЃРµС‚СЊСЋ
 */
public class NetworkManager {
}
package command;

/**
 * РљР°Р¶РґР°СЏ РєРѕРјР°РЅРґР° РґРѕР»Р¶РЅР° РёРјРµС‚СЊ РјРµС‚РѕРґ void execute()
 * TODO РІРѕР·РјРѕР¶РЅРѕ РїРµСЂРµРЅРµСЃС‚Рё РµРіРѕ РІ РѕР±С‰РёР№ РјРѕРґСѓР»СЊ
 */
public interface Command {
    void execute() throws Exception;
}
package command;



public class CommandADD extends CommandClientOnly {
    public void execute() throws Exception {
        try {
            ConsoleHelper.writeMessage("Р”РѕР±Р°РІР»РµРЅРёРµ РЅРѕРІРѕРіРѕ С„Р°Р№Р»Р° РІ СЃРїРёСЃРѕРє С„Р°Р№Р»РѕРІ, РґР»СЏ РѕС‚РїСЂР°РІРєРё РЅР° СЃРµСЂРІРµСЂ.");

            FilesList filesList = getFilesList();

            ConsoleHelper.writeMessage("Р’РІРµРґРёС‚Рµ РїРѕР»РЅРѕРµ РёРјСЏ С„Р°Р№Р»Р° РґР»СЏ РґРѕР±Р°РІР»РµРЅРёСЏ:");

            Path sourcePath = Paths.get(ConsoleHelper.readString());
            if (Files.notExists(sourcePath)) throw new PathIsNotFoundException();
            filesList.addFile(new FileProperties(sourcePath));

            ConsoleHelper.writeMessage("Р”РѕР±Р°РІР»РµРЅРёРµ С„Р°Р№Р»Р° Р·Р°РІРµСЂС€РµРЅРѕ СѓСЃРїРµС€РЅРѕ.");

        } catch (PathIsNotFoundException e) {
            ConsoleHelper.writeMessage("Р¤Р°Р№Р» РЅРµ Р±С‹Р» РЅР°Р№РґРµРЅ.");
        }
    }
}
package command;


/**
 * РљРѕРЅС‚СЂР°РєС‚ РґР»СЏ РІСЃРµС… РєРѕРјР°РЅРґ, РѕС‚РЅРѕСЃСЏС‰РёС…СЃСЏ С‚РѕР»СЊРєРѕ Рє РєР»РёРµРЅС‚Сѓ
 */
public abstract class CommandClientOnly implements Command {
    public FilesList getFilesList() throws Exception{
        return FilesList.getFilesList();
    }
}
package command;


public class CommandCONTENT extends CommandClientOnly {
    public void execute() throws Exception {
        try {
            ConsoleHelper.writeMessage("РџСЂРѕСЃРјРѕС‚СЂ СЃРїРёСЃРѕРєР° С„Р°Р№Р»РѕРІ, РґР»СЏ РѕС‚РїСЂР°РІРєРё РЅР° СЃРµСЂРІРµСЂ.");

            FilesList filesList = getFilesList();

            for (FileProperties file : filesList.getFileList()) {
                ConsoleHelper.writeMessage(file.toString());
            }

        } catch (PathIsNotFoundException e) {
            ConsoleHelper.writeMessage("Р¤Р°Р№Р» РЅРµ Р±С‹Р» РЅР°Р№РґРµРЅ.");
        }
    }
}
package command;




/**
 * The command is executed at the end of the program.
 */
public class CommandEXIT extends CommandClientOnly {

    public void execute() throws Exception {
        try {
            FilesList filesList = getFilesList();
            DBManager dbManager = new DBManager();
            deleteAllFromTable(); //РїРµСЂРµРґ РєР°Р¶РґС‹Рј СЃРѕС…СЂР°РЅРµРЅРёРµРј СѓРґР°Р»СЏРµРј РІСЃРµ РёР· Р‘Р”
            if (filesList.size() > 0){
                for (FileProperties file : filesList.getFileList()) {
                    insertIntoTable(
                            file.getName(),
                            file.getSize(),
                            file.getAbsolutePath().toString(),
                            file.getTimeWhenAdd().getTime()
                    );
                }
                ConsoleHelper.writeMessage("РЎРїРёСЃРѕРє С„Р°Р№Р»РѕРІ СЃРѕС…СЂР°РЅРµРЅ.");
            }
        } catch (PathIsNotFoundException e) {
            ConsoleHelper.writeMessage("Р¤Р°Р№Р» РЅРµ Р±С‹Р» РЅР°Р№РґРµРЅ.");
        }
        ConsoleHelper.writeMessage("Р”Рѕ РІСЃС‚СЂРµС‡Рё!");
    }
}
package command;



public class CommandREMOVE extends CommandClientOnly {
    public void execute() throws Exception {
        try {
            ConsoleHelper.writeMessage("РЈРґР°Р»РµРЅРёРµ С„Р°Р№Р»Р° РёР· СЃРїРёСЃРѕРєР° С„Р°Р№Р»РѕРІ, РґР»СЏ РѕС‚РїСЂР°РІРєРё РЅР° СЃРµСЂРІРµСЂ.");

            FilesList filesList = getFilesList();

            ConsoleHelper.writeMessage("Р’РІРµРґРёС‚Рµ РїРѕР»РЅРѕРµ РёРјСЏ С„Р°Р№Р»Р° РґР»СЏ СѓРґР°Р»РµРЅРёСЏ:");

            Path sourcePath = Paths.get(ConsoleHelper.readString());
            filesList.removeFile(sourcePath);

        } catch (PathIsNotFoundException e) {
            ConsoleHelper.writeMessage("Р¤Р°Р№Р» РЅРµ Р±С‹Р» РЅР°Р№РґРµРЅ.");
        }
    }
}
package exception;

public class PathIsNotFoundException extends Exception {
}
package common;


public class ConsoleHelper {
    private static BufferedReader bis = new BufferedReader(new InputStreamReader(System.in));

    public static void writeMessage(String message) {
        System.out.println(message);
    }

    public static String readString() throws IOException {
        String text = bis.readLine();
        return text;
    }

    public static int readInt() throws IOException {
        String text = readString();
        return Integer.parseInt(text.trim());
    }
}
package server;


//@example
public class DiscardServerHandler extends ChannelInboundHandlerAdapter { //(1)
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {     //(2)
        ByteBuf in = (ByteBuf) msg;
        try {
            while (in.isReadable()) {        // (1)
                System.out.print((char) in.readByte());
                System.out.flush();
            }
            ctx.write(msg.toString());
            ctx.flush();
        } finally {
            ReferenceCountUtil.release(msg); // (2)
        }
    }

    @Override
    // (4)
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        // Close the connection when an exception is raised.
        cause.printStackTrace();
        ctx.close();
    }
}
package server;


public class Server {

    private int port;

    public Server(int port) {
        this.port = port;
    }

    public void run() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup(); // (1)
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap(); // (2)
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class) // (3)
                    .childHandler(new ChannelInitializer<SocketChannel>() { // (4)
                        @Override
                        public void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(new DiscardServerHandler());
                        }
                    })
                    .option(ChannelOption.SO_BACKLOG, 128)          // (5)
                    .childOption(ChannelOption.SO_KEEPALIVE, true); // (6)

            // Bind and start to accept incoming connections.
            ChannelFuture f = b.bind(port).sync(); // (7)

            // Wait until the server socket is closed.
            // In this example, this does not happen, but you can do that to gracefully
            // shut down your server.
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        int port = 7777;
        if (args.length > 0) {
            port = Integer.parseInt(args[0]);
        }

        new Server(port).run();
    }
}
========================================
========================================
Project name: project2
package client;



public class Client {
    private final String host;
    private final int port;
    private Command command = new Command();
    private String fileName = new String();

    public static final AttributeKey<String> myAtt = new AttributeKey<>("myAtt");
    public static final AttributeKey<String> fn = new AttributeKey<>("fn");


    public Client(String host, int port) {
        this.host = host;
        this.port = port;
    }

    public void run() throws Exception, InterruptedException {
        String command = new String(); // in this string write dwnl or send
        String fileName = new String();// name of file needed to transfer

        EventLoopGroup eventLoopGroup = new NioEventLoopGroup();
        try {
            Bootstrap bootstrap = new Bootstrap()
                    .group(eventLoopGroup)
                    .channel(NioSocketChannel.class)
                    .handler(new ClientInitializer());
            Channel channel = bootstrap.connect(host, port).syncUninterruptibly().channel();

            command = "dwnl";
            fileName ="1.txt";
            channel.attr(myAtt).set(command);
            channel.attr(fn).set(fileName);
            System.out.println(channel.attr(myAtt).get());

            channel.writeAndFlush(command+" "+fileName +"\n");


              while (true){


              }

        } finally {
            eventLoopGroup.shutdownGracefully();
        }
    }

}
package client;



public class ClientHandler extends SimpleChannelInboundHandler<String> {
    String storage ;

    protected void channelRead0(ChannelHandlerContext ctx, String s) throws Exception {


        if(ctx.channel().attr(Client.myAtt).get().equals("dwnl")){
            storage = "client_storage/";
            dwnl(s,storage+ctx.channel().attr(Client.fn).get());
        }
        else {
            if(ctx.channel().attr(Client.myAtt).get().equals("send")){
                storage = "client_storage/";
                send(ctx,storage+ctx.channel().attr(Client.fn).get());
            }
            else System.out.println("wrong command");
        }


    }

    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        System.out.println("Connected!");


        ctx.fireChannelActive();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
    }

    private void send(ChannelHandlerContext ctx, String fileName) throws FileNotFoundException {
        ctx.writeAndFlush(new ChunkedStream(new FileInputStream(fileName)));

    }

    private void dwnl(String s, String fileName) throws IOException {
        FileOutputStream  fileOutputStream = new FileOutputStream(fileName, true);
        fileOutputStream.write((s+"\n").getBytes());
        fileOutputStream.close();
        System.out.println(s);
    }


}
package client;




public class ClientInitializer extends ChannelInitializer<io.netty.channel.socket.SocketChannel> {


    @Override
    protected void initChannel(io.netty.channel.socket.SocketChannel socketChannel) throws Exception {
            ChannelPipeline pipeline = socketChannel.pipeline();
            pipeline.addLast("framer", new DelimiterBasedFrameDecoder(2556, Delimiters.lineDelimiter()));
            pipeline.addLast("decoder", new StringDecoder());
            pipeline.addLast("encoder", new StringEncoder());
            pipeline.addLast("handler1", new ChunkedWriteHandler());
            pipeline.addLast("handler2",  new ClientHandler());


    }
}
package client;

public class clientStart {
    public static void main(String[] args) throws Exception {
        new Client("localhost", 8000).run();
    }

}
package common;


public class Command {
    @JsonProperty("marker")
    private String marker;
    @JsonProperty("authMsg")
    private String storage;
    @JsonProperty("fileName")
    private String fileName;
    @JsonProperty("fileStructure")
    private String filesStructure;

    public Command() {

    }

    public Command(String marker, String storage, String fileName, String filesStructure) {
        this.marker = marker;
        this.storage = storage;
        this.fileName = fileName;
        this.filesStructure = filesStructure;
    }

    public String getMarker() {
        return marker;
    }

    public void setMarker(String marker) {
        this.marker = marker;
    }

    public String getStorage() {
        return storage;
    }

    public void setStorage(String line) {
        this.storage = storage;
    }

    public String getFileName() {
        return fileName;
    }

    public void setFileName(String fileName) {
        this.fileName = fileName;
    }

    public String getFilesStructure() {
        return filesStructure;
    }

    public void setFilesStructure(String filesStructure) {
        this.filesStructure = filesStructure;
    }

    @Override
    public String toString() {
        return "Command{" +
                "marker='" + marker + '\'' +
                ", storage='" + storage + '\'' +
                ", fileName='" + fileName + '\'' +
                ", filesStructure='" + filesStructure + '\'' +
                '}';
    }


}
package server;



public class Server implements Runnable {
    private final int port;

    public Server(int port) {
        this.port = port;
    }

    @Override
    public void run() {
        EventLoopGroup eventWork = new NioEventLoopGroup();
        EventLoopGroup eventBoss = new NioEventLoopGroup();
        try {
            ServerBootstrap bootstrap = new ServerBootstrap()
                    .group(eventBoss, eventWork)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ServerInitializer());

            bootstrap.bind(this.port).sync().channel().closeFuture().sync();
        } catch (InterruptedException ignored) {
        } finally {
            eventBoss.shutdownGracefully();
            eventWork.shutdownGracefully();
        }
    }
}
package server;


public class ServerHandler  extends SimpleChannelInboundHandler<String> {
    private static final ChannelGroup channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
    private Command fromClient = new Command();

    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        Channel incoming = ctx.channel();
        channels.add(incoming);
        for (Channel channel : channels) {
            if (channel != incoming){
                channel.writeAndFlush("server message: new client joined " + incoming.remoteAddress() +"\n");
            }
        }

    }

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, String s) throws Exception {
          Channel incoming = ctx.channel();
          System.out.println(incoming);
        for (Channel channel : channels) {
           // if (channel != incoming)
                channel.writeAndFlush( s +"echo"+ "\n");
        }
       // fromClient= new  ObjectMapper().readValue(s, Command.class);
//        if(fromClient.getMarker().equals("msg")){
//           incoming.writeAndFlush("servers answer: "+ fromClient.getLine());
//        }
//        else ctx.writeAndFlush("wrong command");

    }
//

//    @Override
//    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
//        Channel incoming = ctx.channel();
//        for (Channel channel : channels) {
//
//                channel.writeAndFlush(Unpooled.EMPTY_BUFFER);
//        }
//    }


    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
        Channel incoming = ctx.channel();
        for (Channel channel : channels) {
            if (channel != incoming)
                channel.writeAndFlush("server message: client removed " + incoming.remoteAddress());
        }
        channels.remove(ctx.channel());
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
    }

}
package server;



public class ServerInitializer extends ChannelInitializer<io.netty.channel.socket.SocketChannel> {

    @Override
    protected void initChannel(io.netty.channel.socket.SocketChannel channel) throws Exception {
        ChannelPipeline pipeline = channel.pipeline();
        pipeline.addLast("framer", new DelimiterBasedFrameDecoder(2556, Delimiters.lineDelimiter()));
        pipeline.addLast("decoder", new StringDecoder());
        pipeline.addLast("encoder", new StringEncoder());
        pipeline.addLast("handler1", new ChunkedWriteHandler());
        pipeline.addLast("handler2", new WriteStreamHandler());
    }
}
package server;

public class serverStart {
    public static void main(String[] args) throws Exception {
        new Server(8000).run();
    }
}
package server;



public class WriteStreamHandler extends SimpleChannelInboundHandler<String> {

    String storage = new String();
    String fileName = new String();

    @Override
    protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception {
       Channel incoming = channelHandlerContext.channel();

          String[] toSplit = s.split(" ");
          if(toSplit[0].equals("dwnl")){
              storage = "server_storage/";
              fileName = toSplit[1];

              incoming.writeAndFlush(new ChunkedStream(new FileInputStream(storage+fileName)));
          }
        else {
              if (toSplit[0].equals("send")) {

                  storage = "server_storage/";
                  fileName = toSplit[1];

                  FileOutputStream fileOutputStream = new FileOutputStream(storage + fileName, true);
                  fileOutputStream.write((s + "\n").getBytes());

                  fileOutputStream.close();
                  System.out.println(s);
              }
          }
    }




    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
    }

}
package acidsore;



/**
 * Unit test for simple App.
 */
public class AppTest
{
    /**
     * Rigorous Test :-)
     */
    @Test
    public void shouldAnswerWithTrue()
    {
        assertTrue( true );
    }
}
========================================
========================================




===
РґРѕРєС‚РѕСЂ СЃРєР°Р·Р°Р»Р° РїРѕРєР°, [28.04.19 17:48]
РђР»РµРєСЃР°РЅРґСЂ, РїСЂРёРІРµС‚СЃС‚РІСѓСЋ.
СЏ С‡С‚Рѕ-С‚Рѕ РјРЅРѕРіРѕ РЅР°РјСѓРґСЂРёР», С‚РµРїРµСЂСЊ СЂР°Р·РѕР±СЂР°С‚СЊСЃСЏ РЅРµ РјРѕРіСѓ.
РµСЃС‚СЊ РѕРґРёРЅ С…СЌРЅРґР»РµСЂ:
public class AuthServerHandler extends ChannelInboundHandlerAdapter {

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ByteBuf in = (ByteBuf) msg;
        System.out.println(in.toString(CharsetUtil.UTF_8));
        ByteBuf buf = Unpooled.copiedBuffer("/authok", CharsetUtil.UTF_8);  //in the future there will be a request for db.
        ctx.writeAndFlush(buf);

    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
//        ctx.channel().pipeline().remove(this);
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
С‚СѓРґР° Р·Р°Р»РµС‚Р°СЋС‚ Р±Р°Р№С‚С‹ РёР·
public void tryToAuth() throws IOException {
        checkData();
        Main.out.write((login.getText() + pass.getText()).getBytes());
        Main.out.flush();
        setAuthorized(new CommandDecoder().decode());
    }
РґР°РЅРЅС‹Рµ РІС‹РІРѕРґСЏС‚СЃСЏ, РѕС‚РІРµС‚ РЅР°РїСЂР°РІР»СЏРµС‚СЃСЏ СЃСЋРґР°
private void setAuthorized(String response) {
        try {
            if (response.equals("/authok")) {
                userPath = Paths.get(".", "users", "login");
                changeScene();
            } else {
                tryToAuth();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

РґРѕРєС‚РѕСЂ СЃРєР°Р·Р°Р»Р° РїРѕРєР°, [28.04.19 17:50]
СЃР±СЃС‚РІРЅРЅРѕ,
private void changeScene() throws IOException {
        Stage stage = (Stage) authorization.getScene().getWindow();
        stage.close();
        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("/storage.fxml"));
        Parent root1 = fxmlLoader.load();
        stage = new Stage();
        stage.initModality(Modality.APPLICATION_MODAL);
        stage.setTitle(login.getText());
        stage.setScene(new Scene(root1));
        stage.show();
    }
РїРµСЂРµРєР»СЋС‡Р°РµРј РЅР° РґСЂСѓРіРѕРµ РѕРєРѕС€РєРѕ Рё РїС‹С‚Р°РµРјСЃСЏ РїРѕСЃР»Р°С‚СЊ РєР°РєРёРµ-РЅРёР±СѓРґСЊ РґР°РЅРЅС‹Рµ, С‚РµРѕСЂРµС‚РёС‡РµСЃРєРё РёСЃРїРѕР»СЊР·СѓСЏ С‚РѕС‚ Р¶Рµ СЃРѕРєРµС‚ Рё datainput/outputstream

РґРѕРєС‚РѕСЂ СЃРєР°Р·Р°Р»Р° РїРѕРєР°, [28.04.19 17:52]
РЅРѕ РЅРёС‡РµРіРѕ РЅРµ РѕС‚РїСЂР°РІР»СЏРµС‚СЃСЏ Рё Р»РѕРІРёРј SocketException

РґРѕРєС‚РѕСЂ СЃРєР°Р·Р°Р»Р° РїРѕРєР°, [28.04.19 17:53]
СЏ РїСЂРµРґРїРѕР»Р°РіР°СЋ, С‡С‚Рѕ РїСЂРѕР±Р»РµРјР° РІ СЃРјРµРЅРµ stage, РЅРѕ РїРѕРєР° РЅРёС‡РµРіРѕ РЅР°РіСѓРіР»РёС‚СЊ РЅРµ СЃРјРѕРі

РґРѕРєС‚РѕСЂ СЃРєР°Р·Р°Р»Р° РїРѕРєР°, [28.04.19 17:53]
РјРѕР¶РµС‚ Р»Рё Р±С‹С‚СЊ РїСЂРѕР±Р»РµРјР° РІ СЌС‚РѕРј?

РґРѕРєС‚РѕСЂ СЃРєР°Р·Р°Р»Р° РїРѕРєР°, [28.04.19 17:55]
network, in, out  Р·Р°РїСѓСЃРєР°РµРј РІ Main Application
public Main() {
        try {
            network = new Network();
            network.start();
            in = new DataInputStream(network.getSocket().getInputStream());
            out = new DataOutputStream(network.getSocket().getOutputStream());
        } catch (IOException e) {


Finish!!!